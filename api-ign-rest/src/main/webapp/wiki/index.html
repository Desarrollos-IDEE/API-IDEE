<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Documentation </title>
    <link rel="stylesheet" href="main.css">
    <script src="lib.js"></script>

</head>

<body id="page-top" class="html-doc">
    <!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand doc-title" href="#page-top">Documentation </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">

            </div>
            <!--/.nav-collapse -->
        </div>
    </div>
    <div id="documentation-container" class="container">
        <div class="row">
            <div class="col-md-3">
                <div class="nav-container">
                    <div class="nav-inner" id="scroll-spy" style="width: min-content; overflow: auto; top: 60px; bottom: 0; padding 10px 0 10px 0;">
                        <span class="toc"></span>
                        <p><a href="#">
                                <strong>Inicio</strong>
                            </a><br><a href="#Primeros-pasos">
                                <strong>Primeros pasos</strong>
                            </a><br><a href="#Personalizar-el-mapa">
                                <strong>Personalizar del mapa</strong>
                            </a><br><a href="#Capas">
                                <strong>Capas</strong>
                            </a><br>&nbsp;
                            &nbsp; <a href="#Capas-raster">
                                <strong>&gt; Capas raster</strong>
                            </a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#WMS">WMS</a>, <a href="#WMC">WMC</a>, <a href="#WMTS">WMTS</a> <br>&nbsp; <a href="#Capas-vectoriales"><strong>&gt; Capas vectoriales</strong>
                            </a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#WFS">WFS</a>, <a href="#GeoJSON">GeoJSON</a>, <a href="#KML">KML</a><br><a href="#features">Features</a><br><a href="#filtros">Filtros</a><br><a href="#simbologia">Simbología</a><br>&nbsp;&nbsp;&nbsp;<a href="#M.style.Point">&#8226; Puntos</a>, <a href="#M.style.Line">Líneas</a>, <a href="#M.style.Polygon">Polígonos</a><br>&nbsp;&nbsp;&nbsp;<a href="#Coropletas">&#8226; Coropletas</a>, <a href="#Proporcional">Proporcional</a>, <a href="#Categorias">Categorías</a>,<a href="#Heatmap">Mapas de Calor</a><br>&nbsp;&nbsp;&nbsp;<a href="#Cluster">&#8226; Cluster</a>, <a href="#Composite">Composición</a><br>&nbsp;<a href="#Controles"><strong>&gt; Controles básicos</strong></a><br>&nbsp;<a href="#Opciones"><strong>&gt; Opciones</strong></a><br>&nbsp;<a href="#Paneles"><strong>&gt; Paneles</strong></a><br><a href="#Plugins"><strong>Plugins</strong></a><br><a href="#Proxys"><strong>Proxys</strong></a><br><a href="#Eventos"><strong>Eventos</strong></a><br><a href="#Utilidades"><strong>Utilidades</strong></a><br><a href="#Acceso-libreria-base"><strong>Acceso librerías base</strong></a><br><a href="#Mapea-iframe"><strong>Mapea iframe</strong></a><br><a href="#Solucion-de-problemas"><strong>Solución de problemas</strong></a> </p>
                    </div>
                </div>
            </div>

            <div class="col-md-9">
                <h1><strong>Mapea</strong></h1>
                <p>
                   Mapea</a>  es una herramienta que permite integrar de una forma muy sencilla un visualizador de mapas interactivo en
                    cualquier página web y configurarlo consumiendo ficheros WMC, servicios WMS, servicios WFS, ficheros KML, etc. Además,
                    provee la capacidad de añadir una gran cantidad de herramientas y controles.
                </p>
                <p>
                    Para adaptarse a las necesidades de los usuarios y ser mucho más flexible, Mapea cuenta con dos APIs. De esta manera, es
                    el propio usuario el que selecciona la que más se adapta a las necesidades que necesite cubrir en cada momento:
                </p>

                <p>
                    A través de una API REST muy sencilla y documentada permite incluir un visualizador interactivo en cualquier página web
                    sin necesidad de disponer de conocimientos específicos en programación ni en el ámbito de los SIG.
                    A través de una API JavaScript que permite crear desde visualizadores de mapas básico hasta otros de mayor complejidad.
                    Mapea se presenta como una solución gratuita para la incorporación de clientes de mapas interactivos en nuestras páginas
                    web muy facilmente.
                </p>
                <p>La versión inicial de Mapea junto con su código puede consultarse en el repositorio de GitHub del <a href="https://github.com/sigcorporativo-ja/Mapea4">
                    SIG Corporativo de la Junta de Andalucía</a>. La versión del CNIG es un <em>fork</em> de este repositorio que está pendiente de su publicación</p>


                <p class="page" id="Primeros-pasos"></p>
                <h1><strong>Primeros pasos</strong></h1>
                <p>Para añadir un mapa básico a tu página web, realiza los siguientes pasos:</p>
                <p>1.- Importa los siguientes ficheros en tu html:</p>
                <pre class="hljs"><span class="hljs-comment">&lt;!-- fichero estilos --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://URL_MAPEA_CNIG/assets/css/mapea-x.y.z.ol.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- ficheros javascript --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://URL_MAPEA_CNIG/js/mapea-x.y.z.ol.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://URL_MAPEA_CNIG/js/configuration-x.y.z.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></pre>
                <p>Donde <em>x.y.z</em> es el número de la versión a integrar. La versión más reciente es la <strong>5.1.0</strong> </p>
                <p>2.- Añade un elemento <em>div</em> donde quieras que se muestre el mapa, asignándole un id:</p>
                <pre class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></pre>
                <p>3.- Crea el mapa mediante la siguiente instrucción javascript, especificando el id del <em>div</em> que hemos creado: </p>
                <pre class="hljs">mapajs = M.map({
   <span class="hljs-attr">container</span>:<span class="hljs-string">"map"</span>
});</pre>
                <p>Como no hemos especificado qué datos o capas queremos ver, por defecto Mapea muestra el <strong>Callejero del IGN</strong>, consulta otras secciones de esta wiki para ver cómo cambiarlo y mostrar la información geográfica que quieras.
                    <p><strong>JSONP</strong></p>
                    <p>Además de programarlo directamente, otra alternativa al paso 3 sería llamar al API Rest, que generará el código javascript
                        del visor por nosotros. Para este ejemplo básico, únicamente necesitaría conocer el id del <em>div</em> donde dibujar el mapa:</p>
                    <pre class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://URL_MAPEA_CNIG/api/js?container=map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></pre>
                    <p>Y en caso de que queramos manipular el objeto mapa después de que nos sea devuelto, podemos indicar como parámetro opcional una función de <strong>callback</strong>: </p>
                    <pre class="hljs">&lt;script src=<span class="hljs-string">"https://URL_MAPEA_CNIG/api/js?container=map&amp;callback=mifuncion"</span>&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mifuncion</span>(<span class="hljs-params">json</span>) </span>{
  <span class="hljs-keyword">var</span> mapajs = json;
  mapajs.addControls([<span class="hljs-string">'scale'</span>, <span class="hljs-string">'location'</span>, <span class="hljs-string">'layerswitcher'</span>]);
}</pre>
                    <p class="page" id="Personalizar-el-mapa"></p>
                    <h1><strong>Personalizar del mapa</strong></h1>
                    <p>La personalización del mapa que queremos construir recae en las siguientes categorías: </p>
                    <ul>
                        <li><strong>Capas</strong>: Son los datos a mostrar, y conforman el mapa que se dibujará. Actualmente, Mapea acepta los principales orígenes de datos OGC: <em>WMS</em>, <em>WFS</em>, <em>KML</em>, <em>WMTS</em>, <em>Geojson</em>, y <em>WMC</em> (Web Map Context). <a href="#Capas">Más información sobre las Capas</a> </li>
                        <li><strong>Controles</strong>: Son las herramientas que incluye el mapa y que permiten trabajar con él, tales como herramientas de medición, de coordenadas, etc. Se dividen en dos categorías: <em>básicos</em> y <em>plugins</em>. <a href="#Controles">Más información sobre los Controles</a> </li>
                        <li><strong>Opciones</strong>: Permiten establecer características concretas del mapa o del área a visualizar, como son el centrado en un punto, nivel de zool inicial, sistema de referencia, etc. <a href="#Opciones">Consulta las Opciones existentes</a></li>
                    </ul>
                    <p class="page" id="Capas"></p>
                    <h1>Capas</h1>
                    <p>Las <strong>capas</strong> son para Mapea los proveedores de información espacial que mostrar en el mapa. Existen
                        diversos formatos bajo los que ofrecer esas capas, y estos son los que acepta Mapea:</p>
                    <p><a href="#WMS">WMS</a>, <a href="#WFS">WFS</a> , <a href="#WMC">WMC</a>, <a href="#WMTS">WMTS</a>, <a href="#KML">KML</a>, <a href="#GeoJSON">GeoJSON</a> </p>
                    <p>Existen varios métodos que permiten gestionar las capas de un mapa. </p>
                    <pre class="hljs"><span class="hljs-comment">// Acceder y eliminar las capas del mapa</span>
                    <span class="hljs-keyword">var</span> capas = mapajs.getLayers();
                    mapajs.removeLayers(layer1); <span class="hljs-comment">// eliminar una o varias capas</span>
                    
                    <span class="hljs-comment">// Capas específicas por tipo/filtro: WMS, WFS, WMC, KML, WMTS</span>
                    <span class="hljs-keyword">var</span> layersWMS = mapajs.getWMS({<span class="hljs-attr">name</span>:<span class="hljs-string">'batimetría'</span>}); <span class="hljs-comment">// capas WMS que cumplen el filtro</span>
                    <span class="hljs-keyword">var</span> layersWFS = mapajs.getWFS(); <span class="hljs-comment">// todas las capas WFS</span>
                    
                    <span class="hljs-comment">// Buscar las capas base, si hay alguna</span>
                    <span class="hljs-keyword">var</span> capasBase = mapajs.getBaseLayers(); <span class="hljs-comment">// capas WMS o WMTS que sean base</span></pre>
                    <blockquote>
                        <p> <a> Las capas <a href="#WMC">WMC</a> son especiales, ya que
                                definen y generan a su vez otras capas que se añaden al mapa. </a> </p>
                    </blockquote>

                    <p class="page" id="Capas-raster"></p>
                    <h1><strong>&gt; Capas raster</strong></h1>
                    <p>Las <strong>capas</strong> son para Mapea la información espacial que mostrar en el mapa. Son de tipo <strong>raster</strong> cuando consisten en imágenes, formadas a su vez por un conjunto de pixeles, creadas generalmente por servidores de mapas externos al cliente en función de los parámetros que indiquemos. El cliente, por tanto, recibe una <em>representación</em> de los datos geográficos, no los datos en sí. </p>
                    <p>Mapea soporta los siguientes tipos de capas raster:</p>
                    <p><a href="#WMS">WMS</a>, <a href="#WMTS">WMTS</a>, <a href="#WMC">WMC</a> </p>
                    <p>Existen varios métodos que permiten gestionar las capas de un mapa. </p>
                    <pre class="hljs"><span class="hljs-comment">// Acceder y eliminar las capas del mapa</span>
<span class="hljs-keyword">var</span> capas = mapajs.getLayers();
mapajs.removeLayers(layer1); <span class="hljs-comment">// eliminar una o varias capas</span>

<span class="hljs-comment">// Capas específicas por atributo: WMS, WFS, WMC, KML, WMTS</span>
<span class="hljs-keyword">var</span> layersWMS = mapajs.getWMS({<span class="hljs-attr">name</span>:<span class="hljs-string">'batimetría'</span>}); <span class="hljs-comment">// capas WMS que cumplen la condicion</span>

<span class="hljs-comment">// Buscar las capas base, si hay alguna</span>
<span class="hljs-keyword">var</span> capasBase = mapajs.getBaseLayers(); <span class="hljs-comment">// capas WMS o WMTS que sean base</span></pre>
                    <blockquote>
                        <p><a> Las capas <a href="#WMC">WMC</a> son especiales, ya que definen y generan a su vez otras capas que se añaden al mapa. </a> </p>
                    </blockquote>
                    <p class="page" id="WMS"></p>
                    <h1>WMS</h1>
                    <p><strong>WMS</strong> (Web Map Service)<br>Definido por una url, el servicio puede ofrecer una o muchas capas, individuales o agrupadas, cada una con un nombre propio. Hay varias formas de añadir capas WMS en Mapea: </p>
                    <p>1.- En el constructor del mapa:</p>
                    <pre class="hljs"><span class="hljs-comment">// En modo cadena u objeto    </span>
  mapajs = M.map({
    <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
    <span class="hljs-attr">layers</span>: [<span class="hljs-string">"WMS*Municipios*http://www.ideandalucia.es/wms/dea100_divisiones_administrativas?*terminos_municipales*false*true"</span>,
      <span class="hljs-keyword">new</span> M.layer.WMS({
        <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.callejerodeandalucia.es/servicios/base/wms?'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'batimetria'</span>,
        <span class="hljs-attr">legend</span>: <span class="hljs-string">'Batimetria'</span>,
        <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">tiled</span>: <span class="hljs-literal">false</span>
      })
    ]
  });</pre>
                    <p>2.- Mediante los métodos addWMS/addLayers:</p>
                    <pre class="hljs">  mapajs.addWMS(<span class="hljs-keyword">new</span> M.layer.WMS({
    <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.callejerodeandalucia.es/servicios/base/wms?'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'CDAU_toponimia'</span>,
    <span class="hljs-attr">legend</span>: <span class="hljs-string">'Toponimia'</span>,
    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">tiled</span>: <span class="hljs-literal">false</span>
  }));</pre>
                    <p>Los parámetros <strong>url</strong> y <strong>name</strong> especifican la url del servicio y el nombre de la capa en el mismo. Los otros parámetros indican: </p>
                    <ul>
                        <li><strong>legend</strong>: Nombre asociado en el árbol de contenidos, si usamos uno. </li>
                        <li><strong>transparent</strong>: &#39;<em>false</em>&#39; si es una capa base, &#39;<em>true</em>&#39; en caso contrario. </li>
                        <li><strong>tiled</strong>: &#39;<em>true</em>&#39; si queremos dividir la capa en tiles, &#39;<em>false</em>&#39; en caso contrario. </li>
                    </ul>
                    <p>Opcionalmente, pueden especificarse las <strong>resoluciones mínima y máxima</strong> de dibujado de las capas, con lo que se establecerían los niveles de zoom en los que sería visible. Esto se hace en un segundo array de opciones, mediante los parámetros &#39;maxResolution&#39; y &#39;minResolution&#39;: </p>
                    <pre class="hljs"> <span class="hljs-keyword">var</span> layerWMS = <span class="hljs-keyword">new</span> M.layer.WMS({
        <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.callejerodeandalucia.es/servicios/base/wms?'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'CDAU_toponimia'</span>,
        <span class="hljs-attr">legend</span>: <span class="hljs-string">'Toponimia'</span>,
        <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">tiled</span>: <span class="hljs-literal">false</span>
      },
      {
        <span class="hljs-attr">maxResolution</span>: <span class="hljs-number">3270.877524508511</span>,
        <span class="hljs-attr">minResolution</span>: <span class="hljs-number">1635.4387622542556</span>
      });</pre>
                    <p>Los métodos de mapa <em>getWMS(layer)</em> y <em>removeWMS(layer)</em> permiten gestionar las capas WMS existentes.</p>
                    <p class="page" id="WMC"></p>
                    <h1>WMC</h1>
                    <p><strong>WMC</strong> (Web Map Context, o Web View Context) es un <a href="http://www.opengeospatial.org/standards/wmc?iframe=true&amp;width=100%&amp;height=100%">estándar de definición de mapas OGC</a>. Trabajar con capas WMS independientes puede ser suficiente en muchos casos, pero si manejamos un número elevado de las mismas, o si queremos personalizar comportamientos tales como activación/desactivación de visibilidad por escala o personalización de la leyenda, es conveniente agruparlas en un único <strong>contexto de mapas</strong>.</p>
                    <p>El siguiente es un wmc que incluye diversas capas: <a href="http://www.callejerodeandalucia.es/wmc/context_cdau_callejero.xml">http://www.callejerodeandalucia.es/wmc/context_cdau_callejero.xml</a> </p>
                    <p>Para construir un mapa a partir de uno o varios wmc, basta con indicar al constructor su <em>url</em>, y un <em>nombre</em> o alias para cada uno. <strong>El único requisito es que dichas url sean públicas</strong>:</p>
                    <pre class="hljs">mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">'map'</span>,
  <span class="hljs-attr">controls</span>: [<span class="hljs-string">'layerswitcher'</span>],
  <span class="hljs-attr">wmcfiles</span>: [<span class="hljs-string">'http://www.callejerodeandalucia.es/wmc/context_cdau_callejero.xml*Mapa'</span>]
});</pre>
                    <p>También puede añadirse mediante el método <em>addWMC</em>:</p>
                    <pre class="hljs"><span class="hljs-keyword">var</span> miWmc = <span class="hljs-keyword">new</span> M.layer.WMC({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.callejerodeandalucia.es/wmc/context_cdau_satelite.xml'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Satélite'</span>
});
mapajs.addWMC(miWmc);</pre>
                    <p>Como se ve también en el ejemplo anterior, si en un mapa se añade más de un contexto, aparece un <strong>selector de contextos</strong> con el que el usuario puede seleccionar el que desea activar en cada momento.</p>
                    <p><strong>Contextos predefinidos en Mapea</strong></p>
                    <p>Mapea incluye como contextos predefinidos los tres contextos creados para el Callejero Digital de Andalucía Unificado. Para usarlos, basta con indicar su nombre, no es necesario conocer las urls de los mismos:</p>
                    <ul>
                        <li>Callejero: "cnig_mapa" </li>
                        <li>Imagen: "cnig_imagen" </li>
                        <li>Híbrido: "cnig_hibrido" </li>
                    </ul>
                    <pre class="hljs"><span class="hljs-keyword">var</span> mapajs = M.map({
    <span class="hljs-attr">container</span>:<span class="hljs-string">'map'</span>,
  <span class="hljs-attr">wmcfiles</span>:[<span class="hljs-string">'cnig_mapa'</span>,<span class="hljs-string">'cnig_imagen'</span>,<span class="hljs-string">'cnig_hibrido'</span>],
});</pre>
                    <p><strong>Capas definidas en el wmc y el objeto mapa</strong><br>Las capas WMC, al ser en realidad una agrupación de capas, tienen un comportamiento especial respecto al mapa: cuando se añade una capa WMC, se activa un proceso que genera, una a una, las capas que incluye dicho WMC, que podrán ser gestionadas individualmente.</p>
                    <p>Este proceso de generación de las capas internas es <strong>asíncrono</strong>, lo que significa que las capas internas no estarán disponibles hasta que se lance el evento M.evt.COMPLETED del mapa. </p>
                    <pre class="hljs"><span class="hljs-comment">// satelite contiene la definicion de capas WMS</span>
mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">'map'</span>,
  <span class="hljs-attr">controls</span>: [<span class="hljs-string">'layerswitcher'</span>],
  <span class="hljs-attr">wmcfiles</span>: [<span class="hljs-string">'cnig_imagen'</span>]
});

<span class="hljs-built_in">console</span>.log(mapajs.getLayers().length);
<span class="hljs-comment">// 1: el wmc</span>

mapajs.on(M.evt.COMPLETED, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>{
  <span class="hljs-built_in">console</span>.log(mapajs.getLayers().length);
  <span class="hljs-comment">// las demás</span>
});
</pre>
                    <p><strong>Otras capas</strong> </p>
                    <p>Un mapa puede combinar wmc y capas (WMS, WFS, etc.) tanto como quiera. Al cambiar de contexto, seguirán respetándose las capas que se han añadido externamente al mismo.</p>
                    <p class="page" id="WMTS"></p>
                    <h1>WMTS</h1>
                    <p><strong>WMTS</strong> (<strong>W</strong>eb <strong>M</strong>ap <strong>T</strong>ile <strong>S</strong>ervice) es un <a href="http://www.opengeospatial.org/standards/wmts">estándar OGC</a> para servir información geográfica en forma de tiles pregenerados a unas resoluciones específicas. Mapea permite visualizar este tipo de capas. </p>
                    <p>1.- Añadiéndolas en el constructor del mapa </p>
                    <pre class="hljs">  mapajs = M.map({
    <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
    <span class="hljs-attr">layers</span>: [<span class="hljs-string">"WMTS*http://www.ign.es/wmts/pnoa-ma?*OI.OrthoimageCoverage*EPSG:25830*PNOA"</span>],
    <span class="hljs-attr">center</span>: [<span class="hljs-number">363063</span>, <span class="hljs-number">4150610</span>],
    <span class="hljs-attr">zoom</span>: <span class="hljs-string">'4'</span>,
    <span class="hljs-attr">controls</span>: [<span class="hljs-string">'layerswitcher'</span>]
  });</pre>
                    <p>2.- Con el método correspondiente: </p>
                    <pre class="hljs">  <span class="hljs-keyword">var</span> layer = <span class="hljs-keyword">new</span> M.layer.WMTS({
    <span class="hljs-attr">url</span>: <span class="hljs-string">"http://www.ideandalucia.es/geowebcache/service/wmts"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"toporaster"</span>,
    <span class="hljs-attr">matrixSet</span>: <span class="hljs-string">"EPSG:25830"</span>,
    <span class="hljs-attr">legend</span>: <span class="hljs-string">"Toporaster"</span>
  },
  {
    <span class="hljs-attr">format</span>: <span class="hljs-string">'image/png'</span>
  });

  mapajs.addWMTS(layer);</pre>
                    <p>Donde: </p>
                    <ul>
                        <li><strong>url</strong>: Url del servicio WMTS.</li>
                        <li><strong>name</strong>: Identifier de la Layer en el Capabilities del servicio.</li>
                        <li><strong>matrixSet</strong>: La matriz seleccionada de las definidas en el Capabilities del servicio.</li>
                        <li><strong>legend</strong>: Nombre que mostrará la capa en el árbol de contenido, si existe.</li>
                        <li><strong>format</strong>: Opcionalmente, el formato en el que solicitar la imagen</li>
                    </ul>
                    
                    <p class="page" id="Capas-vectoriales"></p>
                    <h1><strong>&gt; Capas vectoriales</strong></h1>
                    <p>A diferencia de las capas raster, donde el cliente recibe una imagen de la misma generada por el servidor de mapas, las capas vectoriales se descargan al cliente, y éste es el que las representa. Mapea soporta los siguientes tipos de capas vectoriales: </p>
                    <p><a href="#WFS">WFS</a>, <a href="#GeoJSON">GeoJSON</a>, <a href="#KML">KML</a> </p>
                    <p>El cliente dispone de los elementos geográficos o <strong>features</strong> que forman la capa, y de cada uno de ellos posee a su vez todos sus atributos, tanto su geometría como los campos alfanuméricos. </p>
                    <p>Algunos métodos comunes a todas las capas vectoriales: </p>
                    <pre class="hljs"><span class="hljs-comment">// Añadir/Eliminar features</span>
capaVectorial.addFeatures([feat1,feat2]);
capaVectorial.removeFeatures([feat1,feat2]);
<span class="hljs-comment">// Array con los elementos de la capa</span>
<span class="hljs-keyword">var</span> elementos = capaVectorial.getFeatures();
<span class="hljs-comment">// Obtener la extension de los features</span>
<span class="hljs-keyword">var</span> bbox = capaVectorial.getFeaturesExtent();
<span class="hljs-comment">// O eliminarlos todos</span>
capaVectorial.clear();
</pre>
                    <p>En las secciones de <a href="#features">features</a> y <a href="#filtros">filtros</a> puede obtener más información relativa a este tipo de capas. </p>
                    <p class="page" id="WFS"></p>
                    <h1>WFS</h1>
                    <p><strong>WFS</strong> (<strong>W</strong>eb <strong>F</strong>eature <strong>S</strong>ervice) es un <a href="http://www.opengeospatial.org/standards/wfs">estándar OGC</a> para la transferencia de información geográfica, donde los elementos geográficos o <em>features</em> se transmiten en su totalidad al cliente.</p>
                    <p>Para visualizar capas WFS en Mapea, se pueden:</p>
                    <p>1.- Añadir en el constructor del mapa, tanto en modo cadena como objeto: </p>
                    <pre class="hljs"><span class="hljs-comment">// Ejemplo de caps WFS en modo cadena </span>
<span class="hljs-keyword">var</span> mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
  <span class="hljs-attr">controls</span>: [<span class="hljs-string">"layerswitcher"</span>],
  <span class="hljs-attr">wmcfiles</span>: [<span class="hljs-string">"cdau"</span>],
  <span class="hljs-attr">layers</span>: [<span class="hljs-string">"WFST*Campamentos*http://geostematicos-sigc.juntadeandalucia.es/geoserver/sepim/ows?*sepim:campamentos*MPOINT"</span>]
});</pre>
                    <p>2.- O añadiéndolas con el método correspondiente:</p>
                    <pre class="hljs"><span class="hljs-keyword">var</span> layer = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?"</span>,
  <span class="hljs-attr">namespace</span>: <span class="hljs-string">"tematicos"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">legend</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MPOLYGON'</span>,
  <span class="hljs-attr">ids</span>:<span class="hljs-string">"3,4"</span>
});

mapajs.addWFS(layer);</pre>
                    <p>Donde:</p>
                    <ul>
                        <li><strong>url</strong>: url del servicio WFS. </li>
                        <li><strong>namespace</strong>: workspace asociado a la capa. </li>
                        <li><strong>name</strong>: nombre de la capa en el servidor. </li>
                        <li><strong>legend</strong>: indica el nombre que queremos que aparezca en el árbol de contenidos, si lo hay. </li>
                        <li><strong>geometry</strong>: Tipo de geometría: POINT, MPOINT, LINE, MLINE, POLYGON o MPOLYGON.</li>
                        <li><strong>ids</strong>: <em>Opcional</em> - identificadores por los que queremos filtrar los features.</li>
                        <li><strong>cql</strong>: <em>Opcional</em> - Sentencia CQL para filtrar los features. El método _setCQL(cadena_cql)_ refresca la capa aplicando el nuevo predicado CQL que reciba. </li>
                        <li><strong>version</strong>: <em>Opcional</em> - Versión del estandar a usar. Por defecto es 1.0.0. </li>
                    </ul>
                    <blockquote>
                        <p> <a> Una capa WFS puede ser editada si el servidor tiene habilitadas las operaciones transaccionales sobre la misma. Consulta el plugin de <strong>edición WFST</strong> de Mapea para saber más. </a> </p>
                    </blockquote>
                    <p><strong>Formato de salida</strong><br>Mapea pide las capas WFS al servidor OGC en formato geojson usando por defecto como outputFormat &#39;<em>application/json</em>&#39;. Sin embargo, en función del tipo de servidor OGC que esté atendiendo las peticiones (Geoserver, Mapserver, etc.), puede que tenga asignando un nombre diferente. En ese caso, se puede establecer el nombre del outputFormat para las peticiones getFeature y describeFeature, se usan las opciones de usuario &#39;<strong>getFeatureOutputFormat</strong>&#39; y &#39;<strong>describeFeatureTypeOutputFormat</strong>&#39;: </p>
                    <pre class="hljs">lAguasSupRediam = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.juntadeandalucia.es/medioambiente/mapwms/REDIAM_WFS_RN_Aguas?bbox=508887.12101065,4131323.42844933,509462.159552335,4131744.12235486'</span>,
  <span class="hljs-attr">legend</span>: <span class="hljs-string">'Cursos de Agua Rediam'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'a_red_hidrografica'</span>,
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MLINE'</span>
}, {
  <span class="hljs-attr">getFeatureOutputFormat</span>: <span class="hljs-string">'geojson'</span>,
  <span class="hljs-attr">describeFeatureTypeOutputFormat</span>: <span class="hljs-string">'geojson'</span>
});</pre>
                    <p><strong>Parámetros vendor</strong><br>Algunos servidores de mapas son capaces de procesar en las peticiones OGC parámetros adicionales propios, conocidos como <em>vendor parameters</em>. En las capas WFS podemos especificar cualquier parámetro de este tipo si lo incluimos dentro de la estructura correspondiente en el segundo parámetro del constructor: &#39;vendor -&gt; request OGC asociado -&gt; parametro:valor&#39;, por ejemplo: </p>
                    <pre class="hljs">lAguasSupRediam = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://www.juntadeandalucia.es/medioambiente/mapwms/REDIAM_WFS_RN_Aguas?bbox=508887.12101065,4131323.42844933,509462.159552335,4131744.12235486'</span>,
  <span class="hljs-attr">legend</span>: <span class="hljs-string">'Cursos de Agua Rediam'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'a_red_hidrografica'</span>,
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MLINE'</span>
 },{
  <span class="hljs-attr">vendor</span>:{
    <span class="hljs-attr">getFeature</span>: {
       <span class="hljs-string">'parametro1'</span>: <span class="hljs-string">'valor1'</span>,
       <span class="hljs-string">'parametro2'</span>: <span class="hljs-string">'valor2'</span>
    }
 }
});</pre>
                    <p>El ejemplo anterior crearía peticiones getFeatures que incluirían los parámetros vendor especificados: </p>
                    <pre class="hljs">http:<span class="hljs-comment">//...?request=getFeature&amp;....&amp;parametro1=valor1&amp;parametro2=valor2</span></pre>
                    <p class="page" id="GeoJSON"></p>
                    <h1>GeoJSON</h1>
                    <p><strong>GeoJSON</strong>, pese a no ser un estándar OGC (está <a href="http://www.opengeospatial.org/pressroom/pressreleases/2299">camino de convertirse en ello</a>), es un formato de intercambio de información geográfica muy extendido que, al igual que <a href="#WFS">WFS</a>, permite tener todos los elementos en el cliente.</p>
                    <p>Un ejemplo de GeoJSON:</p>
                    <pre class="hljs">{
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Feature"</span>,
  <span class="hljs-attr">"geometry"</span>: {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Point"</span>,
    <span class="hljs-attr">"coordinates"</span>: [<span class="hljs-number">125.6</span>, <span class="hljs-number">10.1</span>]
  },
  <span class="hljs-attr">"properties"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Dinagat Islands"</span>
  }
}</pre>
                    <p>Dependiendo la fuente del GeoJSON, para añadirlo a Mapea:</p>
                    <blockquote>
                        <p> <a> En el caso de las capas de tipo GeoJSON, se diferencia si el mismo es servido (<em>url</em>) o si por el contrario lo tenemos en local (<em>source</em>). </a></p>
                    </blockquote>
                    <p>1.- GeoJSON local: </p>
                    <pre class="hljs">mapajs.addLayers(<span class="hljs-keyword">new</span> M.layer.GeoJSON({
    <span class="hljs-attr">name</span>: <span class="hljs-string">"capaJson"</span>,
    <span class="hljs-attr">source</span>: {
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"FeatureCollection"</span>,
    <span class="hljs-string">"features"</span>: [{
        <span class="hljs-string">"properties"</span>: {
            <span class="hljs-string">"estado"</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">"vendor"</span>: {
                <span class="hljs-string">"mapea"</span>: {}
            },
            <span class="hljs-string">"sede"</span>: <span class="hljs-string">"/Sevilla/CHGCOR003-Oficina de la zona regable del Genil"</span>,
            <span class="hljs-string">"tipo"</span>: <span class="hljs-string">"ADSL"</span>,
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"/Sevilla/CHGCOR003-Oficina de la zona regable del Genil"</span>
        },
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"Feature"</span>,
        <span class="hljs-string">"geometry"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"Point"</span>,
            <span class="hljs-string">"coordinates"</span>: [<span class="hljs-number">-5.278075</span>, <span class="hljs-number">37.69374444444444</span>]
        }
    }],
    <span class="hljs-string">"crs"</span>: {
        <span class="hljs-string">"properties"</span>: {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"EPSG:4326"</span>
        },
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"name"</span>
    }
}));

<span class="hljs-comment">// También es posible crear una capa vacía</span>
<span class="hljs-keyword">var</span> layer = <span class="hljs-keyword">new</span> M.layer.GeoJSON({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Catastro"</span>,
  <span class="hljs-attr">crs</span>: <span class="hljs-string">"25830"</span>
});
<span class="hljs-comment">// Y añadirle posteriormente features</span>
...
layer.addFeatures(f);</pre>
                    <blockquote>
                        <p>:warning: <a> Hay que tener en cuenta que, en el caso de no establecer el crs, se tomará el establecido por defecto en el estándar: EPSG:4326 </a></p>
                    </blockquote>
                    <p>Donde:</p>
                    <ul>
                        <li><strong>name</strong>: nombre de la capa en la leyenda. </li>
                        <li><strong>source</strong>: el propio GeoJSON. </li>
                        <li><strong>extract</strong>: <em>opcional</em> Activa la consulta por click en el feature.</li>
                    </ul>
                    <p>2.- GeoJSON servido:</p>
                    <pre class="hljs"><span class="hljs-keyword">var</span> layer = <span class="hljs-keyword">new</span> M.layer.GeoJSON(
            {<span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>, 
             <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?service=WFS&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=tematicos:Provincias&amp;maxFeatures=50&amp;outputFormat=application/json"</span>});

mapajs.addLayers(layer);</pre>
                    <p>Donde:</p>
                    <ul>
                        <li><strong>name</strong>: nombre de la capa en la leyenda. </li>
                        <li><strong>url</strong>: url del fichero o servicio que genera el GeoJSON. </li>
                        <li><strong>extract</strong>: <em>opcional</em> Activa la consulta por click en el feature.</li>
                    </ul>
                    <p>Si se desea personalizar un manejador propio para mostrar un popup o label al hacer click en alguno de los features, hay que establecer el atributo <strong>extract</strong> a <em>false</em>, para que no sólo se active nuestro manejador.</p>
                    <p class="page" id="KML"></p>
                    <h1>KML</h1>
                    <p><strong>KML</strong> (<strong>K</strong>eyhole <strong>M</strong>arkup <strong>L</strong>anguage)</p>
                    <p>Las capas KML pueden ser estáticas o dinámicas</p>
                    <ul>
                        <li><strong>estática</strong>: fichero servido a través de un servidor de aplicaciones (p.ej. <a href="http://mapea4-sigc.juntadeandalucia.es/files/kml/museos_utf.kml">http://mapea4-sigc.juntadeandalucia.es/files/kml/museos_utf.kml</a>)</li>
                        <li><strong>dinámica</strong>: servicio que genera el KML al vuelo (p.ej. <a href="http://mapea-sigc.juntadeandalucia.es/sepim_server/api/datos/kml/1193/item/341">http://mapea-sigc.juntadeandalucia.es/sepim_server/api/datos/kml/1193/item/341</a>) </li>
                    </ul>
                    <p>Hay varias formas de añadir capas KML en Mapea:</p>
                    <p>1.- En el constructor del mapa:</p>
                    <pre class="hljs">mapajs = M.map({
          <span class="hljs-attr">container</span>:<span class="hljs-string">"map"</span>,
          <span class="hljs-attr">layers</span>: [<span class="hljs-string">"KML*capaKML*http://mapea-sigc.juntadeandalucia.es/sepim_server/api/datos/kml/1273/item/329*true"</span>]
         });</pre>
                    <p>2.- Mediante los métodos addKML/addLayers:</p>
                    <pre class="hljs"><span class="hljs-comment">//modo objeto </span>
mapajs.addKML(<span class="hljs-keyword">new</span> M.layer.KML({
                <span class="hljs-attr">url</span>: <span class="hljs-string">"http://mapea-sigc.juntadeandalucia.es/sepim_server/api/datos/kml/1273/item/329"</span>,
                <span class="hljs-attr">name</span>: <span class="hljs-string">"capaKML"</span>,
                <span class="hljs-attr">extract</span>: <span class="hljs-literal">true</span>
              }));
<span class="hljs-comment">//modo cadena</span>
mapajs.addKML(<span class="hljs-string">"KML*capaKML*http://mapea-sigc.juntadeandalucia.es/sepim_server/api/datos/kml/1273/item/329*true"</span>);</pre>
                    <p>Los parametros indicados corresponden a:</p>
                    <ul>
                        <li><strong>url</strong>: url del fichero o servicio</li>
                        <li><strong>name</strong>: nombre de la capa que aparecerá en la leyenda</li>
                        <li><strong>extract</strong>: indica si debe mostrar el popup de información al pinchar sobre un elemento</li>
                    </ul>
                    <p>Los métodos de mapa <em>getKML(layer)</em> y <em>removeKML(layer)</em> permiten gestionar las capas KML existentes. </p>
                    <p><strong>Simbologia</strong> </p>
                    <p>Algunas indicaciones respecto a la simbología de los KML: </p>
                    <ul>
                        <li>Si la capa es puntual y dispone de simbología que usa imágenes externas, en el mapa se mostrarán las imágenes con su tamaño real. Puede reducirse o ampliarse definiendo un &#39;scale&#39; en su estilo asociado. </li>
                        <li>Cada elemento de la capa KML se etiqueta por defecto con el valor de su atributo &#39;name&#39;. Se puede modificar el estilo del etiquetado mediante un &#39;LabelStyle&#39;. Para eliminarlo por completo, basta con especificar un scale 0. </li>
                    </ul>
                    <pre class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"estilo1"</span>&gt;</span><span class="xml">
 <span class="hljs-tag">&lt;<span class="hljs-name">IconStyle</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>&gt;</span>0.5<span class="hljs-tag">&lt;/<span class="hljs-name">scale</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">href</span>&gt;</span>url_imagen.png<span class="hljs-tag">&lt;/<span class="hljs-name">href</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Icon</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">IconStyle</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">LabelStyle</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">scale</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">LabelStyle</span>&gt;</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span></pre>
                    <p>Ejemplo de estilo que reduce a la mitad el tamaño del icono, y elimina el etiquetado. </p>
                    <p class="page" id="features"></p>
                    <h1>Features</h1>
                    <p>Un <strong>feature</strong> representa un fenómeno o elemento geográfico de una <a href="#Capas-vectoriales">capa vectorial</a>. Está formado por un <em>identificador</em>, una <em>geometría</em> y una serie de atributos alfanuméricos o <em>propiedades</em>. Cuando un servidor de mapas nos devuelve una capa vectorial, nos está mandando el conjunto de todos los features o elementos que la forman: </p>
                    <pre class="hljs"><span class="hljs-keyword">var</span> mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
  <span class="hljs-attr">wmcfiles</span>: [<span class="hljs-string">"cdau"</span>]
});

<span class="hljs-comment">//capa vectorial GeoJSON de provincias servida  </span>
<span class="hljs-keyword">let</span> layer = <span class="hljs-keyword">new</span> M.layer.GeoJSON({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?service=WFS&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=tematicos:Provincias&amp;maxFeatures=50&amp;outputFormat=application/json"</span>
});

mapajs.addLayers(layer);

<span class="hljs-comment">// Cada feature es una provincia en esta capa</span>
layer.on(M.evt.LOAD, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  layer.getFeatures().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feature</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Provincia: '</span> + feature.getAttribute(<span class="hljs-string">'nombre'</span>));
  })
});</pre>
                    <p>Dispone de métodos para obtener/establecer su id, sus atributos y su geometría.
                        <blockquote>
                            <p> Dos features serán iguales si tienen el mismo id. </p>
                        </blockquote>
                        <p>También es posible definir un feature desde cero mediante la <a href="http://geojson.org/">especificación GeoJSON</a> correspondiente: </p>
                        <pre class="hljs"><span class="hljs-keyword">var</span> miFeature = <span class="hljs-keyword">new</span> M.Feature(<span class="hljs-string">"featurePrueba002"</span>, {
                  <span class="hljs-string">"type"</span>: <span class="hljs-string">"Feature"</span>,
                  <span class="hljs-string">"id"</span>: <span class="hljs-string">"prueba_pol_wfst.1985"</span>,
                  <span class="hljs-string">"geometry"</span>: {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"Polygon"</span>,
                    <span class="hljs-string">"coordinates"</span>: [
                        [
                          [<span class="hljs-number">263770.72265536943</span>,<span class="hljs-number">4085361.4590256726</span>],
                          [<span class="hljs-number">230910.00600234355</span>,<span class="hljs-number">4031901.3328427672</span>],
                          [<span class="hljs-number">288293.77947248437</span>,<span class="hljs-number">4017678.0840030923</span>],
                          [<span class="hljs-number">263770.72265536943</span>,<span class="hljs-number">4085361.4590256726</span>]
                        ]
                      ]
                  },
                  <span class="hljs-string">"geometry_name"</span>: <span class="hljs-string">"geometry"</span>,
                  <span class="hljs-string">"properties"</span>: {
                    <span class="hljs-string">"cod_ine_municipio"</span>: <span class="hljs-string">"41091"</span>, 
                    <span class="hljs-string">"cod_ine_provincia"</span>: <span class="hljs-string">"-"</span>, 
                    <span class="hljs-string">"area"</span>: <span class="hljs-number">1234</span>,
                    <span class="hljs-string">"perimetro"</span>: <span class="hljs-number">345</span>, 
                    <span class="hljs-string">"cod_ine_comunidad"</span>: <span class="hljs-string">"-"</span>,
                    <span class="hljs-string">"nombre"</span>: <span class="hljs-string">"feature2"</span>,
                    <span class="hljs-string">"nom_provincia"</span>: <span class="hljs-string">"Cádiz"</span>,
                    <span class="hljs-string">"alias"</span>: <span class="hljs-string">"f2"</span>,
                    <span class="hljs-string">"nom_ccaa"</span>: <span class="hljs-string">"Andalucía"</span>
                  }
              });

<span class="hljs-keyword">var</span> capaGeoJSON = <span class="hljs-keyword">new</span> M.layer.GeoJSON({
          <span class="hljs-attr">source</span>: {
            <span class="hljs-string">"crs"</span>: {<span class="hljs-string">"properties"</span>: {<span class="hljs-string">"name"</span>: <span class="hljs-string">"EPSG:25830"</span>},<span class="hljs-string">"type"</span>: <span class="hljs-string">"name"</span>},
            <span class="hljs-comment">// Se añade su notacion GeoJSON</span>
            <span class="hljs-string">"features"</span>: [miFeature.getGeoJSON()],
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"FeatureCollection"</span>
          },
          <span class="hljs-attr">name</span>: <span class="hljs-string">'prueba'</span>
        });

       mapajs.addLayers(capaGeoJSON);

       <span class="hljs-comment">// Otra opción: añadir el feature a la capa</span>
       <span class="hljs-comment">//capaGeoJSON.addFeatures(miFeature);</span>
</pre>
                        <p class="page" id="filtros"></p>
                        <h1>Filtros</h1>
                        <p>Con Mapea4 se pueden establecer <strong>filtros en las capas vectoriales</strong> que permiten comprobar si los
                            elementos (features) cumplen o no con determinadas condiciones. Estos filtros se aplican <strong>en
                                memoria</strong>, es decir, estando la capa cargada ya con todos sus elementos en el cliente, aplicar un filtro
                            <strong>no supone realizar ninguna nueva petición al servidor</strong>. </p>
                        <p>Hay que tener en cuenta que una vez se aplica un filtro a una capa, este queda aplicado <strong>hasta que el mismo se
                                elimine o se modifique</strong>, por lo que a todos los efectos, es como si la capa tuviese únicamente aquellos
                            features que cumplen el filtro: dibujado en el mapa, recorrido por sus features, etc.</p>
                        <p>Los filtros actualmente implementados son:</p>
                        <h4 id="filtros-alfanum-ricos">Filtros alfanuméricos</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Filtro</th>
                                    <th>Descripción</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><em>M.filter.AND</em></td>
                                    <td>Condición Y </td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.OR</em></td>
                                    <td>Condición O</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.NOT</em></td>
                                    <td>Condición NO</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.EQUAL</em></td>
                                    <td>Condición IGUAL</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.LIKE</em></td>
                                    <td>Condición de PATRÓN</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.LT</em></td>
                                    <td>Condición MENOR QUE</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.GT</em></td>
                                    <td>Condición MAYOR QUE</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.LTE</em></td>
                                    <td>Condición MENOR O IGUAL QUE</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.GTE</em></td>
                                    <td>Condición MAYOR O IGUAL QUE</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Mediante los filtros <em>M.filter.AND</em> y <em>M.filter.OR</em> podemos encadenar tantos filtros como queramos</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> mapajs = M.map({
   <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
   <span class="hljs-attr">wmcfile</span>: <span class="hljs-string">"callejero"</span>,
   <span class="hljs-attr">controls</span>: [<span class="hljs-string">"layerswitcher"</span>]
 });

<span class="hljs-keyword">let</span> lyProvincias = <span class="hljs-keyword">new</span> M.layer.WFS({
   <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?"</span>,
   <span class="hljs-attr">namespace</span>: <span class="hljs-string">"tematicos"</span>,
   <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
   <span class="hljs-attr">legend</span>: <span class="hljs-string">"Provincias"</span>,
   <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MPOLYGON'</span>
 });

<span class="hljs-comment">//Filtro por atributo nombre</span>
<span class="hljs-keyword">let</span> filter = M.filter.OR(
                     [M.filter.EQUAL(<span class="hljs-string">"nombre"</span>, <span class="hljs-string">"Sevilla"</span>),
                      M.filter.EQUAL(<span class="hljs-string">"nombre"</span>, <span class="hljs-string">"Málaga"</span>)]);
lyProvincias.setFilter(filter); 
<span class="hljs-comment">//lyProvincias.removeFilter(); eliminar el filtro</span>

mapajs.addLayers(lyProvincias);</pre>
                        <h4 id="filtros-espaciales">Filtros espaciales</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Filtro</th>
                                    <th>Descripción</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><em>M.filter.spatial.CONTAIN</em></td>
                                    <td>Comprueba que el un elemento A esté dentro de otro B</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.spatial.DISJOINT</em></td>
                                    <td>Comprueba que los elementos A y B no tengan ningún punto en común</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.spatial.WITHIN</em></td>
                                    <td>Comprueba que el elemento B esté dentro de A</td>
                                </tr>
                                <tr>
                                    <td><em>M.filter.spatial.INTERSECT</em></td>
                                    <td>Comprueba si los elementos A y B tienen puntos en común</td>
                                </tr>
                            </tbody>
                        </table>
                        <blockquote>
                            <p> <a> Para los filtros espaciales, se ha implementado la librería <a href="http://bjornharrtell.github.io/jsts/">jsts</a>. Esto permite acceder a ella y realizar multitud de
                                    operaciones espaciales adicionales.
                        </blockquote>
                        <pre class="hljs"><span class="hljs-keyword">let</span> mapajs = M.map({
   <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
   <span class="hljs-attr">wmcfile</span>: <span class="hljs-string">"callejero"</span>,
   <span class="hljs-attr">controls</span>: [<span class="hljs-string">"layerswitcher"</span>]
});

<span class="hljs-keyword">var</span> lyProvincias = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?"</span>,
  <span class="hljs-attr">namespace</span>: <span class="hljs-string">"tematicos"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">legend</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MPOLYGON'</span>
 });

<span class="hljs-keyword">var</span> miFeature = <span class="hljs-keyword">new</span> M.Feature(<span class="hljs-string">"featurePrueba002"</span>, {
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"Feature"</span>,
  <span class="hljs-string">"id"</span>: <span class="hljs-string">"prueba_pol_wfst.1985"</span>,
  <span class="hljs-string">"geometry"</span>: {
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"Polygon"</span>,
    <span class="hljs-string">"coordinates"</span>: [
      [
        [<span class="hljs-number">263770.72265536943</span>, <span class="hljs-number">4085361.4590256726</span>],
        [<span class="hljs-number">230910.00600234355</span>, <span class="hljs-number">4031901.3328427672</span>],
        [<span class="hljs-number">288293.77947248437</span>, <span class="hljs-number">4017678.0840030923</span>],
        [<span class="hljs-number">263770.72265536943</span>, <span class="hljs-number">4085361.4590256726</span>]
      ]
    ]
  },
  <span class="hljs-string">"properties"</span>: {
    <span class="hljs-string">"nombre"</span>: <span class="hljs-string">"feature2"</span>
  }
});
lyProvincias.addFeatures(miFeature);
mapajs.addLayers(lyProvincias);

<span class="hljs-comment">//Filtro los features de la capa que intersecten con miFeature</span>
<span class="hljs-keyword">let</span> filter = M.filter.spatial.INTERSECT(miFeature);
lyProvincias.setFilter(filter);
</pre>

                        <p>También se ofrece la posibilidad de transformar cualquier de estos filtros al estándar CQL, por si se quiere hacer
                            uso de filtrado desde el servidor</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> filtroCQL = filter.toCQL(); <span class="hljs-comment">//devuelve un string con el filtro en formato CQL</span>
lyProvincias.setCQL(filtroCQL);</pre>
                        <h4 id="filtros-personalizados">Filtros personalizados</h4>
                        <p>Si ninguno de los filtros disponibles se adaptan a nuestras necesidades, Mapea también ofrece la posibilidad de
                            definir cualquier filtro mediante una función, de forma que no quedamos limitados a la hora de poder realizar
                            cualquier filtro:</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> mapajs = M.map({
   <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
   <span class="hljs-attr">wmcfile</span>: <span class="hljs-string">"callejero"</span>,
   <span class="hljs-attr">controls</span>: [<span class="hljs-string">"layerswitcher"</span>]
 });

 <span class="hljs-keyword">var</span> lyProvincias = <span class="hljs-keyword">new</span> M.layer.WFS({
   <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/ows?"</span>,
   <span class="hljs-attr">namespace</span>: <span class="hljs-string">"tematicos"</span>,
   <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
   <span class="hljs-attr">legend</span>: <span class="hljs-string">"Provincias"</span>,
   <span class="hljs-attr">geometry</span>: <span class="hljs-string">'MPOLYGON'</span>
 });

 mapajs.addLayers(lyProvincias);

 <span class="hljs-comment">//se crea un filtro personalizado que sólo devuelve las features </span>
 <span class="hljs-comment">//que tengan la letra 'C' en el atributo nombre</span>
 <span class="hljs-keyword">let</span> filter = <span class="hljs-keyword">new</span> M.filter.Function(<span class="hljs-function"><span class="hljs-params">feature</span> =&gt;</span> {
   <span class="hljs-keyword">return</span> feature.getAttribute(<span class="hljs-string">'nombre'</span>).indexOf(<span class="hljs-string">'C'</span>) &gt;= <span class="hljs-number">0</span>;
 });

 lyProvincias.setFilter(filter);</pre>
                        <p class="page" id="simbologia"></p>
                        <h1>Simbología</h1>
                        <p>Las capa vectoriales están formadas por elementos o features que poseen información geométrica con la que representarlos en el mapa. Mapea asigna un estilo de representación por defecto a estas capas, pero el usuario puede definir y asignar sus propios estilos.</p>
                        <p>Dichos estilos pueden ser:</p>
                        <ol>
                            <li><strong>Básicos</strong> - el usuario define las características de la simbología que quiera establecer, según el tipo de geometría de la capa: colores de relleno, transparencias, etiquetado, etc. </li>
                            <li><a href="#M.style.Point">Simbología para puntos</a>.</li>
                            <li><a href="#M.style.Line">Simbología para líneas</a>.</li>
                            <li>
                                <p><a href="#M.style.Polygon">Simbología para polígonos</a>.</p>
                            </li>
                            <li>
                                <p><strong>Temáticos</strong> - el usuario establece unos parámetros de configuración en base a los cuales Mapea genera la simbología automáticamente: </p>
                            </li>
                            <li><a href="#Proporcional">Símbolos proporcionales.</a></li>
                            <li><a href="#Categor%C3%ADas">Simbología por categorías</a>.</li>
                            <li><a href="#Coropletas">Símbología por coropletas</a>.</li>
                            <li><a href="#Estad%C3%ADsticos">Simbología estadística</a>.</li>
                            <li><a href="#Cluster">Clusters</a>.</li>
                        </ol>
                        <p>Puede obtenerse más información de cada uno de estos tipos en sus secciones correspondientes de esta wiki. </p>
                        <h2 id="trabajar-con-estilos-b-sicos">Trabajar con estilos básicos</h2>
                        <p>Independientemente de la definición y particularidad de cada tipo de estilo, el funcionamiento en general es el siguiente: </p>
                        <pre class="hljs"><span class="hljs-comment">// Creamos un estilo, en este caso para una capa puntual </span>
<span class="hljs-comment">// con relleno de color rojo y borde amarillo</span>
<span class="hljs-keyword">let</span> estiloPoint = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">fill</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.7</span>
  },
  <span class="hljs-attr">stroke</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
  },
  <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span>
});
<span class="hljs-comment">// Asignamos el estilo a la capa</span>
capaPuntual.setStyle(estiloPoint);  </pre>
                        <p>A los atributos se les pueden asignar valores de tres formas diferentes, como muestra el siguiente ejemplo con el atributo &#39;label.text&#39;: </p>
                        <pre class="hljs"><span class="hljs-comment">// 1: directamente</span>
<span class="hljs-keyword">let</span> estiloPoint = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">label</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-string">'etiqueta fija'</span>
...
<span class="hljs-comment">// 2: el valor de un atributo del feature</span>
<span class="hljs-comment">// mediante notacion '{{nombre_atributo}}'</span>
<span class="hljs-keyword">let</span> estiloPoint = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">label</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-string">'{{nombre}}'</span>
...
<span class="hljs-comment">// 3: mediante una funcion</span>
<span class="hljs-comment">// recibe como parametro el propio feature</span>
<span class="hljs-comment">// y en la v5.0.0+, también el objeto mapa,</span>
<span class="hljs-comment">// con acceso a su escala, etc.</span>
<span class="hljs-keyword">let</span> estiloPoint = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">label</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feature,map</span>) </span>{
      <span class="hljs-keyword">return</span> feature.getAttribute(<span class="hljs-string">'nombre'</span>).trim();
    }
...</pre>
                        <p>El estilo puede asignarse a una capa, o directamente a uno o varios features, con lo que solo aplicaría a esos elementos. Es decir, tanto un objeto <em>layer</em> como uno <em>feature</em>, tienen un atributo &#39;estilo&#39;: </p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> feature = capaPuntual.getFeatures()[<span class="hljs-number">0</span>];
<span class="hljs-keyword">let</span> estiloFeature = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">fill</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.7</span>
  },
  <span class="hljs-attr">stroke</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
  },
  <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span>
});

feature.setStyle(estiloFeature):</pre>
                        <p>El estilo de una capa aplica a todos sus features por defecto, sin que estos tengan que tener ningún estilo asociado. Pero en caso de tenerlo, un estilo a nivel de feature tiene preferencia a la hora de dibujarse respecto al de la capa. </p>
                        <p>Existe la opción de <strong>forzar la propagación del estilo de una capa a todos sus features</strong>, de modo que dichos features obtengan su propio objeto estilo, incluso aunque sean similares. Esto puede ser importante a la hora de realizar cambios posteriores en la simbología, como se explica más adelante. Para ello, al asignar el estilo a la capa, basta con establecer el parámetro &#39;<em>applyToFeature</em>&#39; a true: </p>
                        <pre class="hljs"><span class="hljs-comment">// Asignamos el estilo a la capa propagando a features</span>
capaPuntual.setStyle(estiloPoint, <span class="hljs-literal">true</span>);  </pre>
                        <blockquote>
                            <p> Los estilos temáticos siempre propagan a los features, es decir, cada uno de ellos tendrá un estilo propio resultado de la aplicación del temático.</p>
                        </blockquote>
                        <h2 id="acceder-y-modificar-estilos-ya-existentes">Acceder y modificar estilos ya existentes</h2>
                        <p>Podemos acceder al estilo de una capa o feature, y en caso de ser un estilo temático, tener acceso a través del mismo a sus propiedades, para consultarlas, modificarlas, etc. </p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> estiloCapa = capa.getStyle();  
<span class="hljs-keyword">let</span> estiloFeature = feature.getStyle();</pre>
                        <p>Como norma general, siempre aplicará el último estilo que se asigne. Por lo tanto, la opción más directa para modificar la simbología de una capa o feature es establecer una nueva. </p>
                        <p>Sin embargo, es posible también cambiar directamente el atributo que se desee, de la siguiente manera: </p>
                        <pre class="hljs"><span class="hljs-comment">// La capa tiene un color de relleno rojo</span>
<span class="hljs-keyword">let</span> colorAnterior = capaPuntual.getStyle().get(<span class="hljs-string">"fill.color"</span>);
<span class="hljs-comment">// Modificamos el color de relleno de la capa.</span>
capaPuntual.getStyle().set(<span class="hljs-string">"fill.color"</span>,<span class="hljs-string">"blue"</span>);  </pre>
                        <p>Es importante tener en cuenta que, <strong>si hemos asignado un estilo a una capa sin propagación a los features, estos no tienen estilo propio</strong>, por lo que el ejemplo anterior funcionaría a nivel de capa, pero no a nivel de feature.</p>
                        <blockquote>
                            <p> Cuidado con las <strong>referencias</strong>. Si asignamos un mismo objeto estilo a una capa y a uno de sus features, y se cambia posteriormente un atributo del estilo en el feature, cambiará en toda la capa, ya que ambos comparten el mismo estilo. Podemos clonar estilos a través de su método <em>.clone()</em>. </p>
                        </blockquote>
                        <h2 id="dibujado-de-la-leyenda">Dibujado de la leyenda</h2>
                        <p>Todo estilo tiene <strong>la capacidad de generar su leyenda automáticamente</strong> en formato base64 a través de la función <strong><em>toImage</em></strong>. Si el estilo es autocontenido, obtendremos directamente la imagen, pero si el estilo incluye iconos o imágenes externas (por ejemplo urls), obtendremos el <em>Promise</em> correspondiente, que al finalizar podrá devolver la imagen. Esto es útil para incrustar la leyenda en un elemento img de html, en nuestra página, etc: </p>
                        <pre class="hljs">capa.on(M.evt.LOAD, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">// Obtenemos la leyenda</span>
  <span class="hljs-keyword">let</span> estilo = capa.getStyle();
  <span class="hljs-keyword">let</span> leyenda =  estilo.toImage();

  <span class="hljs-comment">// La leyenda puede ser un Promise</span>
 <span class="hljs-keyword">if</span>(leyenda <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>){
      leyenda.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{
         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise finalizado'</span>,response);
      });
 } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Tenemos la imagen directamente'</span>,leyenda);
 }
});</pre>
                        <h2 id="serializaci-n-de-estilos-vectoriales">Serialización de estilos vectoriales</h2>
                        <p><strong>Serializar</strong> un estilo consiste en codificar el objeto que define dicho estilo en una cadena de texto que posteriormente puede <strong>deserializarse</strong>, que es realizar el proceso inverso para obtener el objeto estilo partiendo de la cadena serializada. Esto permite compartir el estilo y almacenarlo a través de unos canales que no serían funcionales si estuviera en forma de objeto, como por ejemplo a través de una url. </p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> estilo = <span class="hljs-keyword">new</span> M.style.Polygon({
   <span class="hljs-attr">fill</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'pink'</span>,
     <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
   },
   <span class="hljs-attr">stroke</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#FF0000'</span>,
     <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
   }
});
<span class="hljs-comment">// Mostramos por consola el estilo serializado </span>
<span class="hljs-keyword">let</span> estiloSerializado = estilo.serialize();
<span class="hljs-built_in">console</span>.log(estiloSerializado);

<span class="hljs-comment">// Un estilo serializado se puede asignar directamente a una capa</span>
capa.setStyle(estiloSerializado);

<span class="hljs-comment">// O ser deserializado</span>
<span class="hljs-keyword">let</span> estiloDeserializado = M.Style.deserialize(estiloSerializado);</pre>
                        <p>El API REST de Mapea acepta un <a href="http://mapea4-sigc.juntadeandalucia.es/?wmcfile=mapa&amp;layers=GeoJSON*Provincias*http%3A%2F%2Fgeostematicos-sigc.juntadeandalucia.es%2Fgeoserver%2Ftematicos%2Fows%3Fservice%3DWFS%26version%3D1.0.0%26request%3DGetFeature%26typeName%3Dtematicos%3AProvincias%26maxFeatures%3D50%26outputFormat%3Dapplication%252Fjson*true*eyJwYXJhbWV0ZXJzIjpbeyJmaWxsIjp7ImNvbG9yIjoicGluayIsIm9wYWNpdHkiOjAuNX0sInN0cm9rZSI6eyJjb2xvciI6IiNGRjAwMDAiLCJ3aWR0aCI6Mn19XSwiZGVzZXJpYWxpemVkTWV0aG9kIjoiKChzZXJpYWxpemVkUGFyYW1ldGVycykgPT4gTS5zdHlsZS5TaW1wbGUuZGVzZXJpYWxpemUoc2VyaWFsaXplZFBhcmFtZXRlcnMsICdNLnN0eWxlLlBvbHlnb24nKSkifQ==">estilo serializado como parámetro de las capas vectoriales</a> . </p>
                        <p class="page" id="M.style.Point"></p>
                        <h1>&#8226; Puntos</h1>
                        <p><img src="https://raw.githubusercontent.com/wiki/sigcorporativo-ja/Mapea4/images/mind_map_point.png" /></p>
                        <p>La simbología que deseemos crear es la que establece qué parámetros son necesarios, sin que existan parámetros intrínsecamente obligatorios. Así por ejemplo, serían válidos todos los siguientes estilos: </p>
                        <pre class="hljs"><span class="hljs-comment">// Punto con relleno rojo</span>
<span class="hljs-keyword">let</span> estilo1 = <span class="hljs-keyword">new</span> M.style.Point({
   <span class="hljs-attr">fill</span>: {  
     <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
   }
});

<span class="hljs-comment">// Punto de tamaño 5 con relleno verde semitransparente y borde rojo</span>
<span class="hljs-keyword">let</span> estilo2 = <span class="hljs-keyword">new</span> M.style.Point({
   <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>, 
   <span class="hljs-attr">fill</span>: {  
     <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>,
     <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>
   },
   <span class="hljs-attr">stroke</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#FF0000'</span>
   }
});

<span class="hljs-comment">// Punto con icono y etiqueta con su nombre</span>
<span class="hljs-keyword">let</span> estilo3 = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">icon</span>: {
    <span class="hljs-attr">src</span>: <span class="hljs-string">'http://URL_ICONO/icono.png'</span>
  },
  <span class="hljs-attr">label</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-string">'{{nombre}}'</span>
  }
});
</pre>
                        <p>A continuación se describen todos los parámetros posibles, siempre teniendo en cuenta lo anteriormente comentado respecto a la obligatoriedad de los mismos:</p>
                        <pre class="hljs">M.style.Point({
   <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span>, <span class="hljs-comment">// Radio del punto. Numérico</span>
   <span class="hljs-comment">// Relleno </span>
   fill: {  
     <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,  <span class="hljs-comment">// Color de relleno. Hexadecimal, nominal </span>
     opacity: <span class="hljs-number">0.5</span>   <span class="hljs-comment">// Transparencia. 0(transparente)|1(opaco)</span>
   },
   <span class="hljs-comment">// Borde exterior</span>
   stroke: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#C8FE2E'</span>,   <span class="hljs-comment">// Color del borde. Hexadecimal, nominal</span>
     width: <span class="hljs-number">2</span>,           <span class="hljs-comment">// Grosor en pixeles</span>
     linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>], <span class="hljs-comment">// Patrón de distancias</span>
     linedashoffset: <span class="hljs-number">1</span>,  <span class="hljs-comment">// Offset de fase</span>
     linecap: <span class="hljs-string">'square'</span>,  <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
     linejoin: <span class="hljs-string">'miter'</span>,  <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
     miterlimit: <span class="hljs-number">15</span>      <span class="hljs-comment">// Tamaño máximo segmento de conexión</span>
   },
   <span class="hljs-comment">// Etiquetado</span>
   label: {
     <span class="hljs-attr">text</span>: <span class="hljs-string">'Etiqueta'</span>,                <span class="hljs-comment">// Texto a escribir</span>
     font: <span class="hljs-string">'bold 19px Comic Sans MS'</span>, <span class="hljs-comment">// Fuente y caracteristicas</span>
     color: <span class="hljs-string">'#FF0000'</span>,                <span class="hljs-comment">// Color de la fuente</span>
     rotate: <span class="hljs-literal">false</span>,                   <span class="hljs-comment">// Debe o no rotar con la pantalla</span>
     scale: <span class="hljs-number">0.9</span>,                      <span class="hljs-comment">// Factor de escala de la fuente</span>
     offset: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>],
     <span class="hljs-comment">// Halo de la fuente</span>
     stroke: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span>,     <span class="hljs-comment">// Color de relleno del halo</span>
       width: <span class="hljs-number">2</span>,            <span class="hljs-comment">// Grosor en pixeles del halo</span>
       linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>],  <span class="hljs-comment">// Patrón de distancias de la linea</span>
       linedashoffset: <span class="hljs-number">1</span>,   <span class="hljs-comment">// Offset de fase</span>
       linecap: <span class="hljs-string">'square'</span>,   <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
       linejoin: <span class="hljs-string">'miter'</span>,   <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
       miterlimit: <span class="hljs-number">15</span>       <span class="hljs-comment">// Tamaño máximo segmento de conexión</span>
     },
     <span class="hljs-attr">rotation</span>: <span class="hljs-number">0.5</span>,                  <span class="hljs-comment">// Rotacion de la etiqueta </span>
     align: M.style.align.RIGHT,     <span class="hljs-comment">// Alineacion. RIGHT|LEFT|CENTER|JUSTIFY</span>
     baseline: M.style.baseline.TOP  <span class="hljs-comment">// Altura de la etiqueta. TOP|BOTTOM|MIDDLE</span>
   },
  <span class="hljs-comment">// Icono tipo imagen</span>
  icon: {
    <span class="hljs-attr">src</span>: <span class="hljs-string">'http://url_imagen'</span>,  <span class="hljs-comment">// Url de la imagen</span>
    rotation: <span class="hljs-number">0.5</span>,             <span class="hljs-comment">// Rotacion de la imagen</span>
    scale: <span class="hljs-number">0.5</span>,                <span class="hljs-comment">// Factor de escala</span>
    opacity: <span class="hljs-number">0.8</span>,              <span class="hljs-comment">// Transparencia del icono. 0(transparente)|1(opaco)</span>
    anchor: [<span class="hljs-number">0.5</span>, <span class="hljs-number">1.9</span>],        <span class="hljs-comment">// Desplazamiento respecto al punto</span>
    anchororigin: <span class="hljs-string">'top-left'</span>,  <span class="hljs-comment">// Ubicacion inicial de la coordenada respecto al icono</span>
    anchorxunits: <span class="hljs-string">'fraction'</span>,  <span class="hljs-comment">// Unidades de desplazamiento de anchor. fraction | pixel</span>
    anchoryunits: <span class="hljs-string">'fraction'</span>,
    <span class="hljs-attr">rotate</span>: <span class="hljs-literal">false</span>,             <span class="hljs-comment">// Rotacion con dispositivo</span>
    <span class="hljs-comment">// Offset permite recortar la imagen</span>
    offsetorigin: <span class="hljs-string">'top-left'</span>,  <span class="hljs-comment">// Punto de referencia para el corte. bottom-left/right|top-left/right</span>
    offset: [<span class="hljs-number">10</span>, <span class="hljs-number">0</span>],           <span class="hljs-comment">// Pixeles a mover el punto de referencia en cada eje</span>
    size:[<span class="hljs-number">5</span>, <span class="hljs-number">15</span>],              <span class="hljs-comment">// Pixeles a recortar desde el offset en cada eje</span>
    crossorigin: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">snaptopixel</span>: <span class="hljs-literal">true</span>,         <span class="hljs-comment">// Renderizado. true(nítido)|false(desenfoque) </span>
  },
  <span class="hljs-comment">// Icono tipo FontSymbol</span>
  icon: {
    <span class="hljs-attr">form</span>: M.style.form.LOZENGE,    <span class="hljs-comment">// Forma del fontsymbol.</span>
    <span class="hljs-comment">// BAN|BLAZON|BUBBLE|CIRCLE|LOZENGE|MARKER</span>
    <span class="hljs-comment">// NONE|SHIELD|SIGN|SQUARE|TRIANGLE</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span>: "<span class="hljs-title">g</span>-<span class="hljs-title">cartografia</span>-<span class="hljs-title">alerta</span>",
    <span class="hljs-title">fontsize</span>: 0.5,
    <span class="hljs-title">radius</span>: 8,                    // <span class="hljs-title">Tama</span>ñ<span class="hljs-title">o</span>
    <span class="hljs-title">rotation</span>: 0,                  // <span class="hljs-title">Giro</span> <span class="hljs-title">del</span> <span class="hljs-title">icono</span> <span class="hljs-title">en</span> <span class="hljs-title">radianes</span>
    <span class="hljs-title">rotate</span>: <span class="hljs-title">false</span>,                // <span class="hljs-title">Activar</span> <span class="hljs-title">rotacion</span> <span class="hljs-title">con</span> <span class="hljs-title">dispositivo</span>
    <span class="hljs-title">offset</span>: [0, 0],               // <span class="hljs-title">Desplazamiento</span> <span class="hljs-title">en</span> <span class="hljs-title">pixeles</span> <span class="hljs-title">en</span> <span class="hljs-title">los</span> <span class="hljs-title">ejes</span> <span class="hljs-title">x</span>,<span class="hljs-title">y</span>
    <span class="hljs-title">color</span>: '<span class="hljs-title">blue</span>',
    <span class="hljs-title">fill</span>: '#8<span class="hljs-title">A0829</span>',              // <span class="hljs-title">Color</span> <span class="hljs-title">de</span> <span class="hljs-title">relleno</span>
    <span class="hljs-title">gradientcolor</span>: '#088<span class="hljs-title">A85</span>',     // <span class="hljs-title">Color</span> <span class="hljs-title">del</span> <span class="hljs-title">borde</span>
    <span class="hljs-title">gradient</span>: <span class="hljs-title">true</span>,               // <span class="hljs-title">Degradado</span> <span class="hljs-title">entre</span> <span class="hljs-title">color</span> <span class="hljs-title">de</span> <span class="hljs-title">borde</span> <span class="hljs-title">e</span> <span class="hljs-title">interior</span>
    <span class="hljs-title">opacity</span>: 0.5                  // <span class="hljs-title">Transparencia</span>. 0(<span class="hljs-title">transparente</span>)|1(<span class="hljs-title">opaco</span>)
   }
 })</span>;</pre>
                        <blockquote>
                            <p> Para las capas puntuales, Mapea aplica el estilo por defecto <em>M.style.Point.DEFAULT</em>. Para cambiarlo, basta con redefinir dicha constante.</p>
                        </blockquote>
                        <p class="page" id="M.style.Line"></p>
                        <h1>Líneas</h1>
                        <p><img src="https://raw.githubusercontent.com/wiki/sigcorporativo-ja/Mapea4/images/mind_map_line.png" /><br>Al igual que con el resto de simbología básica, la simbología lineal que deseemos crear es la que establece qué parámetros usar, de entre todos los disponibles. Así por ejemplo, serían válidos todos los siguientes estilos: </p>
                        <pre class="hljs"><span class="hljs-comment">// linea amarilla de grosor dos</span>
<span class="hljs-keyword">let</span> estilo1 = <span class="hljs-keyword">new</span> M.style.Line({
    <span class="hljs-attr">fill</span>: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span>,
       <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// linea roja semitransparente con borde negro y etiqueta</span>
<span class="hljs-keyword">let</span> estilo2 = <span class="hljs-keyword">new</span> M.style.Line({
    <span class="hljs-attr">fill</span>: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
       <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>,
       <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
    },
    <span class="hljs-comment">// borde exterior de la linea</span>
    <span class="hljs-string">'stroke'</span>: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>,
       <span class="hljs-attr">width</span>: <span class="hljs-number">5</span>,
    },
    <span class="hljs-comment">// etiquetado de la linea</span>
    <span class="hljs-string">'label'</span>: {
       <span class="hljs-comment">// texto o funcion de etiquetado</span>
       text: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feature</span>) </span>{
        <span class="hljs-keyword">return</span> feature.getAttribute(<span class="hljs-string">'nombre'</span>);
       },
       <span class="hljs-attr">font</span>: <span class="hljs-string">'bold italic 10px Comic Sans MS'</span>,
     }
});</pre>
                        <p>A continuación se describen todos los parámetros posibles, siempre teniendo en cuenta que solo son necesarios los que se requieran para cada estilo:</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> line = <span class="hljs-keyword">new</span> M.style.Line({
    <span class="hljs-comment">// Relleno de la linea</span>
    fill: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span>,  <span class="hljs-comment">// Color de relleno</span>
      width: <span class="hljs-number">3</span>,         <span class="hljs-comment">// Grosor de la linea </span>
      opacity: <span class="hljs-number">0.5</span>,     <span class="hljs-comment">// Transparencia. 0(transparente)|1(opaca)</span>
    },
    <span class="hljs-comment">// borde exterior de la linea</span>
    stroke: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">'#C8FE2E'</span>,   <span class="hljs-comment">// Color del borde exterior</span>
      width: <span class="hljs-number">5</span>,           <span class="hljs-comment">// Grosor del borde, superior al de fill</span>
      linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>], <span class="hljs-comment">// Patrón de distancias</span>
      linedashoffset: <span class="hljs-number">1</span>,  <span class="hljs-comment">// Offset de fase</span>
      linecap: <span class="hljs-string">'square'</span>,  <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
      linejoin: <span class="hljs-string">'miter'</span>,  <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
      miterlimit: <span class="hljs-number">15</span>      <span class="hljs-comment">// Tamaño máximo segmento de conexión</span>
   },
    <span class="hljs-comment">// etiquetado de la linea</span>
    label: {
      <span class="hljs-attr">text</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">feature</span>) </span>{         <span class="hljs-comment">// Texto o funcion de etiquetado</span>
       <span class="hljs-keyword">return</span> feature.getAttribute(<span class="hljs-string">'nombre'</span>);
      },                                
      <span class="hljs-attr">font</span>: <span class="hljs-string">'bold 10px Comic Sans MS'</span>,  <span class="hljs-comment">// Fuente de etiquetado</span>
      rotate: <span class="hljs-literal">false</span>,                    <span class="hljs-comment">// Fotacion con dispositivo </span>
      scale: <span class="hljs-number">0.9</span>,                       <span class="hljs-comment">// Escalado a aplicar</span>
      offset: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>],                 <span class="hljs-comment">// Desplazamiento de etiquetado en pixeles</span>
      color: <span class="hljs-string">'#2EFEC8'</span>,                 <span class="hljs-comment">// Color de la etiqueta</span>
      <span class="hljs-comment">// Halo de la etiqueta</span>
      stroke: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'#C8FE2E'</span>,    <span class="hljs-comment">// Color del halo</span>
       width: <span class="hljs-number">3</span>,            <span class="hljs-comment">// Grosor del halo</span>
       linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>],  <span class="hljs-comment">// Patrón de distancias</span>
       linedashoffset: <span class="hljs-number">1</span>,   <span class="hljs-comment">// Offset de fase</span>
       linecap: <span class="hljs-string">'square'</span>,   <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
       linejoin: <span class="hljs-string">'miter'</span>,   <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
       miterlimit: <span class="hljs-number">15</span>       <span class="hljs-comment">// Tamaño máximo segmento de conexión   </span>
     },
     <span class="hljs-attr">rotate</span>: <span class="hljs-literal">false</span>,                  <span class="hljs-comment">// Rotacion con dispositivo</span>
     rotation: <span class="hljs-number">0.5</span>,                  <span class="hljs-comment">// Ángulo de rotación</span>
     align: M.style.align.LEFT,      <span class="hljs-comment">// Alineación horizontal. CENTER|LEFT|RIGHT</span>
     baseline: M.style.baseline.TOP, <span class="hljs-comment">// Alineación vertical. TOP|BOTTOM|MIDDLE</span>
     textoverflow: <span class="hljs-string">'hidden'</span>,
     <span class="hljs-attr">minwidth</span>: <span class="hljs-number">60</span>,
     <span class="hljs-comment">// IMPORTANTE: puede afectar seriamente al rendimiento</span>
     path: <span class="hljs-literal">true</span>                     <span class="hljs-comment">// Seguimiento de la geometría</span>
   }   
 });</pre>
                        <blockquote>
                            <p> Para las capas lineales, Mapea aplica el estilo por defecto <em>M.style.Line.DEFAULT</em>. Para cambiarlo, basta con redefinir dicha constante y asignarle el estilo deseado. </p>
                        </blockquote>
                        <p class="page" id="M.style.Polygon"></p>
                        <h1>Polígonos</h1>
                        <p><img src="https://raw.githubusercontent.com/wiki/sigcorporativo-ja/Mapea4/images/mind_map_polygon.png" /><br>Un estilo poligonal puede ser tan simple o complejo como queramos. En base a la simbología que queramos definir, habrá que usar unos u otros parámetros de entre todos los existentes. Ejemplos: </p>
                        <pre class="hljs"><span class="hljs-comment">// Polígono verde</span>
<span class="hljs-keyword">let</span> estilo1 = <span class="hljs-keyword">new</span> M.style.Polygon({
   <span class="hljs-attr">fill</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>
   }
});

<span class="hljs-comment">// Polígono rosa semitransparente con borde rojo de grosor dos</span>
<span class="hljs-keyword">let</span> estilo2 = <span class="hljs-keyword">new</span> M.style.Polygon({
   <span class="hljs-attr">fill</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'pink'</span>,
     <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
   },
   <span class="hljs-attr">stroke</span>: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#FF0000'</span>,
     <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
   }
});</pre>
                        <p>A continuación se presenta una lista de todos los parámetros posibles:</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> stylePol = <span class="hljs-keyword">new</span> M.style.Polygon({
   <span class="hljs-comment">//Relleno del polígono</span>
   fill: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#6A0888'</span>,  <span class="hljs-comment">// Color de relleno</span>
     opacity: <span class="hljs-number">0.5</span>,      <span class="hljs-comment">// Opacidad del relleno</span>
     <span class="hljs-comment">// Patrón de relleno</span>
     pattern: {
       <span class="hljs-attr">name</span>: M.style.pattern.SQUARE,  <span class="hljs-comment">// Nombre del patron</span>
       size: <span class="hljs-number">5</span>,                       <span class="hljs-comment">// Tamaño del patrón</span>
       scale: <span class="hljs-number">1.3</span>,                    <span class="hljs-comment">// Escala del patrón</span>
       spacing: <span class="hljs-number">80</span>,     
       <span class="hljs-attr">rotation</span>: <span class="hljs-number">20</span>                   <span class="hljs-comment">// Rotación del patrón</span>
       <span class="hljs-comment">// SOLO ICONO:</span>
       <span class="hljs-comment">// Si name = ICON</span>
            <span class="hljs-class"><span class="hljs-keyword">class</span>: '<span class="hljs-title">g</span>-<span class="hljs-title">cartografia</span>-<span class="hljs-title">save</span>', 
       // <span class="hljs-title">si</span> <span class="hljs-title">name</span> </span>= IMAGE
            src: <span class="hljs-string">'http://www.juntadeandalucia.es/prueba/icon.png'</span>,
            <span class="hljs-attr">offset</span>: [<span class="hljs-number">21</span>, <span class="hljs-number">21</span>],       
            <span class="hljs-attr">fill</span>: {
             <span class="hljs-attr">color</span>: <span class="hljs-string">'#fff'</span>,
             <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>
            }
     }
   },
   <span class="hljs-comment">//borde del polígono</span>
   stroke: {
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#ff5588'</span>,    <span class="hljs-comment">// Color de la lína</span>
     width: <span class="hljs-number">4</span>,            <span class="hljs-comment">// Ancho de la línea</span>
     linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>],  <span class="hljs-comment">// Patrón de distancias</span>
     linedashoffset: <span class="hljs-number">1</span>,   <span class="hljs-comment">// Offset de fase</span>
     linecap: <span class="hljs-string">'square'</span>,   <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
     linejoin: <span class="hljs-string">'miter'</span>,   <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
     miterlimit: <span class="hljs-number">15</span>       <span class="hljs-comment">// Tamaño máximo segmento de conexión</span>
   },
   <span class="hljs-comment">//etiqueta del polígono</span>
   label: {
     <span class="hljs-attr">text</span>: <span class="hljs-string">'{{distrito}}'</span>,           <span class="hljs-comment">// Texto etiqueta. fijo|función|atributo</span>
     font: <span class="hljs-string">'bold 16px Courier New'</span>,  <span class="hljs-comment">// Fuente de la etiqueta</span>
     scale: <span class="hljs-number">0.9</span>,                     <span class="hljs-comment">// Escala de la etiqueta</span>
     offset: [<span class="hljs-number">10</span>, <span class="hljs-number">0</span>],                <span class="hljs-comment">// Desplazamiento en píxeles</span>
     color: <span class="hljs-string">'#000'</span>,                  <span class="hljs-comment">// Color del texto</span>
     <span class="hljs-comment">// Halo del texto</span>
     stroke: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'#FFF'</span>,       <span class="hljs-comment">// Color del halo</span>
       width: <span class="hljs-number">5</span>,            <span class="hljs-comment">// Grosor del halo</span>
       linedash: [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">20</span>],  <span class="hljs-comment">// Patrón de distancias</span>
       linedashoffset: <span class="hljs-number">1</span>,   <span class="hljs-comment">// Offset de fase</span>
       linecap: <span class="hljs-string">'square'</span>,   <span class="hljs-comment">// Estilo de final de linea. round|square|butt</span>
       linejoin: <span class="hljs-string">'miter'</span>,   <span class="hljs-comment">// Estilo de conexión de segmentos. miter|round|bevel</span>
       miterlimit: <span class="hljs-number">15</span>       <span class="hljs-comment">// Tamaño máximo segmento de conexión</span>
     },
     <span class="hljs-attr">rotate</span>: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">// Rotación con dispositivo</span>
     rotation: <span class="hljs-number">0.3</span>,                 <span class="hljs-comment">// Rotación de la etiqueta</span>
     align: M.style.align.RIGHT,    <span class="hljs-comment">// Alineación horizontal. CENTER|LEFT|RIGHT</span>
     baseline: M.style.baseline.TOP <span class="hljs-comment">// Alineación vertical. TOP|BOTTOM|MIDDLE        </span>
   }
});</pre>
                        <blockquote>
                            <p> Para las capas poligonales, Mapea aplica el estilo por defecto <em>M.style.Polygon.DEFAULT</em>. Para cambiarlo, basta con redefinir dicha constante. </p>
                        </blockquote>
                        <p class="page" id="Coropletas"></p>
                        <h1>&#8226; Coropletas</h1>
                        <p>Un mapa de coropletas es un mapa en el que las regiones toman un estilo (color) en base al valor, dentro de una escala de rangos, del dato contenido en uno de sus atributos.</p>
                        <p>Por tanto, para construir dicho mapa, es necesario especificar al menos los siguientes parámetros:</p>
                        <ul>
                            <li>Atributo que contiene el dato</li>
                            <li>Rangos definidos</li>
                            <li>Estilo para cada uno de los rangos</li>
                        </ul>
                        <p>Puesto que definir cada uno de los rangos, y establecer un estilo para cada uno de ellos es una tarea pesada, se facilita dicha labor pudiendo establecer un número de rangos y un algoritmo/función para calcular sus límites, así como estilos por defecto o simplemente establecer color inicial y color final.</p>
                        <p>El uso más común sería:</p>
                        <pre class="hljs"><span class="hljs-keyword">let</span> choropleth = <span class="hljs-keyword">new</span> M.style.Choropleth(valueField, 
                                        [firstColor, lastColor], 
                                        quantification); </pre>
                        <p>Dónde:</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Parámetro</th>
                                    <th>Descripción </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>valueField</strong></td>
                                    <td>{string} - atributo que contiene el dato </td>
                                </tr>
                                <tr>
                                    <td><strong>firsColor</strong></td>
                                    <td>{string} - color del rango inferior (opcional)</td>
                                </tr>
                                <tr>
                                    <td><strong>lastColor</strong></td>
                                    <td>{string} - color del rango superior (opcional)</td>
                                </tr>
                                <tr>
                                    <td><strong>quantification</strong></td>
                                    <td>{M.style.quantification \</td>
                                    <td>function()} - algoritmo de cuantificación y número de rangos. Puede ser una función personalizada o utilizar lo ya definidos <code>M.style.quantification.JENKS(rangos)</code> y <code>M.style.quantification.QUANTILE(rangos)</code> (opcional)</td>
                                </tr>
                            </tbody>
                        </table>
                        <blockquote>
                        </blockquote>
                        <p>Un ejemplo completo de un mapa de coropletas, construido con Mapea, sería tan sencillo como:</p>
                        <pre class="hljs"><span class="hljs-comment">//creación del mapa</span>
<span class="hljs-keyword">let</span> mapajs = M.map({
  <span class="hljs-string">'container'</span>: <span class="hljs-string">'map'</span>,
  <span class="hljs-string">"controls"</span>: [<span class="hljs-string">"layerswitcher"</span>]
});

<span class="hljs-comment">//creación de la capa</span>
<span class="hljs-keyword">let</span> lyProv = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/tematicos/wfs?"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Provincias"</span>,
  <span class="hljs-attr">legend</span>: <span class="hljs-string">"Provincias - COROPLETAS"</span>,
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'POLYGON'</span>,
});

<span class="hljs-comment">//se crea el estilo y se aplica a la capa</span>
<span class="hljs-keyword">let</span> choropleth = <span class="hljs-keyword">new</span> M.style.Choropleth(
                     <span class="hljs-string">'u_cod_prov'</span>, 
                     [<span class="hljs-string">'#000000'</span>, <span class="hljs-string">'#FFFFFF'</span>], 
                     M.style.quantification.JENKS(<span class="hljs-number">4</span>));

lyProv.setStyle(choropleth);

<span class="hljs-comment">//se añade la capa al mapa</span>
mapajs.addLayers(lyProv);</pre>
                        <ul>
                            <li>Mapea permite simplificar aún más la generación de la coropleta, obviando los parámetros opcionales. De esta forma, se establecerá un escala de 5 rangos, de rojo claro a rojo oscuro, calculados mediante JENKS:</li>
                        </ul>
                        <pre class="hljs"><span class="hljs-keyword">let</span> choropleth = <span class="hljs-keyword">new</span> M.style.Choropleth(valueField); </pre>
                        <ul>
                            <li>En caso de que queramos pasar directamente los rangos de clasificación, la función que tenemos que definir es tan simple como la siguiente:
                                <pre class="hljs"><span class="hljs-keyword">var</span> rangos_usuario = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-keyword">let</span> choropleth = <span class="hljs-keyword">new</span> M.style.Choropleth(<span class="hljs-string">"u_cod_prov"</span>, [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>], () =&gt; rangos_usuario);
                    </ul>
                    <p class="page" id="Proporcional"></p>
                    <h1>Proporcional</h1>
                    <p>La simbología proporcional suele utilizarse para mostrar un atributo de los elementos de una capa con un símbolo de tamaño proporcional al valor del mismo en el contexto global del capa.</p>
                    <p>Por tanto, para construir un mapa con simbología proporcional, necesitaremos lo siguiente:</p>
                    <ul>
                        <li>Atributo que contiene el dato</li>
                        <li>Tamaño menor</li>
                        <li>Tamaño mayor</li>
                        <li>Estilo del símbolo</li>
                    </ul>
                    <p>Mapea ofrece una manera simple de establecer la simbología proporcional, haciendo uso de <a href="#M.style.Point">M.style.Point</a>:</p>
                    <pre class="hljs"><span class="hljs-keyword">let</span> styleProp = <span class="hljs-keyword">new</span> M.style.Proportional(valueField, 
                                         sizeMin, 
                                         sizeMax, 
                                         stylePoint);</pre>
                                <p>Donde:</p>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Parámetro</th>
                                            <th>Descripción </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>valueField</strong></td>
                                            <td>{string} - atributo que contiene el dato </td>
                                        </tr>
                                        <tr>
                                            <td><strong>sizeMin</strong></td>
                                            <td>{number} - tamaño mínimo del símbolo</td>
                                        </tr>
                                        <tr>
                                            <td><strong>sizeMax</strong></td>
                                            <td>{number} - tamaño máximo del símbolo</td>
                                        </tr>
                                        <tr>
                                            <td><strong>stylePoint</strong></td>
                                            <td>{M.style.Point} - objeto <em>M.style.Point</em> que define el estilo</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <blockquote>
                                    <p> Puesto que se hace uso de <em><a href="#M.style.Point">M.style.Point</a></em> se podrá definir cualquier opción que acepte dicho estilo, como por ejemplo un icono o un símbolo vectorial. Para más información consultar la documentación asociada</p>
                                </blockquote>
                                <pre class="hljs"><span class="hljs-keyword">let</span> mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
  <span class="hljs-attr">controls</span>: [<span class="hljs-string">'layerswitcher'</span>, <span class="hljs-string">'overviewmap'</span>],
});

<span class="hljs-keyword">let</span> layer = <span class="hljs-keyword">new</span> M.layer.WFS({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Municipios Indicadores"</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/wfs?"</span>,
  <span class="hljs-attr">namespace</span>: <span class="hljs-string">"tematicos"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"ind_mun_simp"</span>,  
  <span class="hljs-attr">geometry</span>: <span class="hljs-string">'POLYGON'</span>,
});

mapajs.addLayers(layer);

<span class="hljs-comment">//definimos un estilo proporcional </span>
<span class="hljs-keyword">let</span> styleProp = <span class="hljs-keyword">new</span> M.style.Proportional(<span class="hljs-string">'tot_ibi'</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>, 
   <span class="hljs-keyword">new</span> M.style.Point({ <span class="hljs-comment">//estilo del punto</span>
     fill: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>
     },
     <span class="hljs-attr">stroke</span>: {
       <span class="hljs-attr">color</span>: <span class="hljs-string">'#FFFFFF'</span>,
       <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
     }
   })
);

<span class="hljs-comment">//lo establecemos a la capa</span>
layer.setStyle(styleProp);</pre>
                                <blockquote>
                                    <p> En el caso de utilizar un estilo en base a una imagen, hay que tener en cuenta que se aplicarán tamaños proporcionales en vez del real de la imagen, ya que es imposible a priori conocerlo. Dicha proporción está establecida por defecto a 20, pero puede ser modificada: _M.style.Proportional.SCALE_PROPORTION = 20_</p>
                                </blockquote>
                                <p>También es posible no definir un estilo, en cuyo caso se representará el símbolo proporcional con el estilo por defecto:</p>
                                <pre class="hljs"><span class="hljs-keyword">let</span> styleProp = <span class="hljs-keyword">new</span> M.style.Proportional(<span class="hljs-string">'tot_ibi'</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>);</pre>
                                <p>Igualmente, <strong>se puede definir una función personalizada</strong> para su uso como generadora de los niveles proporcionales, a través del método <em>.setProportionalFunction</em>, o añadiéndola como parámetro al constructor del estilo proporcional después del parámetro de estilo.</p>
                                <p>La función a usar para el cálculo del radio proporcional asociado a un valor de entrada sigue la interfaz:</p>
                                <ul>
                                    <li>parámetros de entrada: value, minValue, maxValue, minRadius, maxRadius.</li>
                                    <li>parámetro de salida: valor del radio proporcional calculado. </li>
                                </ul>
                                <pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">miFuncionProporcional</span>(<span class="hljs-params">value, minValue, maxValue, minRadius, maxRadius</span>)</span>{
  <span class="hljs-comment">// Hace el cálculo del radio asociado al value recibido...</span>
  <span class="hljs-keyword">return</span>...;
}

<span class="hljs-keyword">let</span> sizeMin = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> sizeMax = <span class="hljs-number">15</span>;

<span class="hljs-keyword">let</span> estiloPunto = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">fill</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span>
  },
  <span class="hljs-attr">stroke</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'white'</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>
  }
});
<span class="hljs-keyword">let</span> proportionalStyle = <span class="hljs-keyword">new</span> M.style.Proportional(<span class="hljs-string">'tot_ibi'</span>, sizeMin, sizeMax, estiloPunto,miFuncionProporcional);</pre>

                                <p class="page" id="Categorias"></p>
                                <h1>Categorías</h1>
                                <p>Un capa categorizada es una capa cuya simbología se establece asociando un estilo a cada elemento o feature en base
                                    al valor de un atributo del mismo.</p>
                                <p>Por tanto, para definir ese tipo de simbología, es necesario especificar al menos el <strong>Atributo</strong> del
                                    feature por el cual se va a realizar la categorización. Y de manera opcional, la relación de
                                    <strong>Valores/Estilos</strong> para la representación de los diferentes valores del atributo.</p>
                                <p>Así, para categorizar por ejemplo una capa poligonal de municipios de Andalucía, de modo que a cada elemento se le
                                    diera un color en función de la provincia a la que pertenece, que viene indicado en uno de sus atributos:</p>
                                <pre class="hljs"><span class="hljs-comment">// Definimos los estilos de cada categoría. Como queremos diferenciar entre</span>
<span class="hljs-comment">// provincias, crearemos un color para cada una</span>
<span class="hljs-keyword">let</span> verde = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>}});
<span class="hljs-keyword">let</span> amarillo = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'pink'</span>}});
<span class="hljs-keyword">let</span> rojo = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>}});
<span class="hljs-keyword">let</span> azul = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'grey'</span>}});
<span class="hljs-keyword">let</span> naranja = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'orange'</span>}});
<span class="hljs-keyword">let</span> marron = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'brown'</span>}});
<span class="hljs-keyword">let</span> magenta = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'#e814d9'</span>}});
<span class="hljs-keyword">let</span> morado = <span class="hljs-keyword">new</span> M.style.Polygon({<span class="hljs-attr">fill</span>: {<span class="hljs-attr">color</span>: <span class="hljs-string">'#b213dd'</span>}});

<span class="hljs-comment">// Creamos la simbologia. El atributo "provincia" contiene el nombre</span>
<span class="hljs-comment">// de la provincia a la que pertenece cada feature</span>
<span class="hljs-keyword">let</span> categoryStyle = <span class="hljs-keyword">new</span> M.style.Category(<span class="hljs-string">"provincia"</span>, {
  <span class="hljs-string">"Almería"</span>: marron,
  <span class="hljs-string">"Cádiz"</span>: amarillo,
  <span class="hljs-string">"Córdoba"</span>: magenta,
  <span class="hljs-string">"Granada"</span>: verde,
  <span class="hljs-string">"Jaén"</span>: naranja,
  <span class="hljs-string">"Málaga"</span>: azul,
  <span class="hljs-string">"Sevilla"</span>: rojo,
  <span class="hljs-string">"Huelva"</span>: morado
});

layerMunicipios.setStyle(categoryStyle);</pre>
                                <p>Donde M.style.Category recibe:</p>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Parámetro</th>
                                            <th>Descripción </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>attributeName</strong></td>
                                            <td>{string} - atributo que contiene el campo por el que categorizar </td>
                                        </tr>
                                        <tr>
                                            <td><strong>categoryStyles</strong></td>
                                            <td>{object} - <em>opcional</em> - con las relaciones valor-estilo. Si no se especifica, se generarán
                                                estilos aleatorios para cada valor del atributo. </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <blockquote>
                                    <p> Los estilos deben corresponder al tipo de geometría de la capa </p>
                                </blockquote>
                                <p>No es necesario especificar estilo para todos los diferentes valores que pueda adoptar el atributo
                                    &#39;attributeName&#39;: </p>
                                <ul>
                                    <li>Si el valor del atributo de un feature no aparece en la lista de categoryStyles, ese feature se pintará con la
                                        simbología por defecto que tenga la capa. </li>
                                    <li>El valor <strong>&quot;other&quot;</strong> en la lista de categoryStyles recogerá a todos los features cuyo
                                        atributo &#39;attributeName&#39; tenga un valor que no se corresponda con ningún otro de la lista. </li>
                                </ul>
                                <p><strong>¿Y si quiero aplicar un estilo diferente y aleatorio a cada feature en función de un atributo, sin importarme
                                        qué estilo?</strong> Especifica únicamente el &#39;attributeName&#39; en el constructor del estilo, sin indicar
                                </p>
                                <h3 id="acceso-y-modificaci-n-de-las-propiedades-del-estilo">Acceso y modificación de las propiedades del estilo</h3>
                                <p>Se puede acceder a las propidades de un estilo Category ya existente, y modificar aquellos aspectos de la misma que
                                    se desee: </p>
                                <pre class="hljs"><span class="hljs-comment">// La capa ya tiene el estilo asignado</span>
<span class="hljs-keyword">let</span> estiloCategory = capa.getStyle();

<span class="hljs-comment">// Obtenemos las categorías existentes, y el atributo de categorización</span>
<span class="hljs-comment">// Podrían modificarse con los métodos 'set' equivalentes</span>
<span class="hljs-keyword">let</span> categorí<span class="hljs-keyword">as</span> = estiloCategory.getCategories();
<span class="hljs-keyword">let</span> atributo = estiloCategory.getAttributeName();

<span class="hljs-comment">// Cambiamos únicamente el estilo asociado a la categoría de "Sevilla"</span>
estiloCategory.setStyleForCategory(<span class="hljs-string">"Sevilla"</span>,amarillo);</pre>
                                <p class="page" id="Heatmap"></p>
                                <h1>Mapas de Calor</h1>
                                <p>Los <strong>mapas de calor</strong> o <strong>heatmaps</strong> son mapas que muestran <em>la intensidad relativa de los elementos de una capa de puntos</em>. El valor que dará <strong>peso</strong> a la intensidad viene definido por un atributo de dichos elementos, y el color o la representación de esa escala de intensidad vendrá dada por una rampa de colores o <strong>gradiente</strong> determinada. </p>
                                <p><img src="https://raw.githubusercontent.com/wiki/sigcorporativo-ja/Mapea4/images/heatmap.png" /></p>
                                <pre class="hljs"> <span class="hljs-keyword">let</span> style = <span class="hljs-keyword">new</span> M.style.Heatmap(peso, {options});</pre>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Parámetro</th>
                                            <th>Descripción </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>peso</strong></td>
                                            <td>{string} - atributo o función que establece el peso en la intensidad</td>
                                        </tr>
                                        <tr>
                                            <td><strong>options</strong></td>
                                            <td>{object} - valores <strong>opcionales</strong> del mapa de calor :<br> <strong>gradient</strong>: Array\&lt;string> - los colores que definen el gradiente de intensidad <br> <strong>blur</strong>: {number} - tamaño de la borrosidad en pixeles <br> <strong>radius</strong>: {number} - radio de influencia del punto en pixeles </td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>Ejemplo: </p>
                                <pre class="hljs"> <span class="hljs-keyword">let</span> style = <span class="hljs-keyword">new</span> M.style.Heatmap(<span class="hljs-string">'temperatura'</span>, {
      <span class="hljs-attr">blur</span>: <span class="hljs-number">15</span>,
      <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">gradient</span>: [<span class="hljs-string">'blue'</span>, <span class="hljs-string">'cyan'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'yellow'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'red'</span>],
    });</pre>
                                <p>Los valores por defecto para los parámetros opcionales están establecidos en las siguientes constantes: </p>
                                <ul>
                                    <li>M.style.Heatmap.DEFAULT_OPTIONS.radius = 10</li>
                                    <li>M.style.Heatmap.DEFAULT_OPTIONS.blur = 15</li>
                                    <li>M.style.Heatmap.DEFAULT_OPTIONS.gradient = [&quot;#00f&quot;, &quot;#0ff&quot;, &quot;#0f0&quot;, &quot;#ff0&quot;, &quot;#f00&quot;]</li>
                                </ul>
                                <p class="page" id="Cluster"></p>
                                <h1>&#8226; Cluster</h1>
                                <p>Cuando tenemos muchos elementos en un mapa, si el zoom es demasiado alejado, no conseguiremos distinguir unos elementos de otros. Para solucionar esto, una de las técnicas más utilizadas es la generación de <em>clusters</em> que agrupan los elementos dependiendo del nivel de zoom, desplegándose a medida que vamos acercando el mismo. </p>
                                <p><img src="https://raw.githubusercontent.com/wiki/sigcorporativo-ja/Mapea4/images/wiki_cluster1.png" /></p>
                                <p>En Mapea, se ha hecho una implementación completa de los <em>clusters</em> a través del API de estilos y, siendo muy simple la generación de los <em>clusters</em> por defecto:</p>
                                <pre class="hljs"><span class="hljs-keyword">var</span> mapajs = M.map({
    <span class="hljs-string">'container'</span>: <span class="hljs-string">'map'</span>,
    <span class="hljs-string">"controls"</span>: [<span class="hljs-string">"layerswitcher"</span>]
});

<span class="hljs-keyword">var</span> campamentos = <span class="hljs-keyword">new</span> M.layer.WFS({
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Campamentos"</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/wfs"</span>,
    <span class="hljs-attr">namespace</span>: <span class="hljs-string">"sepim"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"campamentos"</span>,
    <span class="hljs-attr">geometry</span>: <span class="hljs-string">'POINT'</span>,
    <span class="hljs-attr">extract</span>: <span class="hljs-literal">true</span>
});

mapajs.addLayers(campamentos);
<span class="hljs-comment">//se aplica un cluster por defecto</span>
campamentos.setStyle(<span class="hljs-keyword">new</span> M.style.Cluster());</pre>
                                <blockquote>
                                    <p>:warning: <a> Actualmente, solo las capas con geometría de tipo POINT pueden ser clusterizadas. </a> </p>
                                </blockquote>
                                <p>No obstante, también es posible su completa personalización, definiendo tanto los posibles rangos como su estilo concreto, así como parámetros generales de animación, muestra de número de elementos, etc.</p>
                                <pre class="hljs"><span class="hljs-keyword">let</span> clusterOptions = {
    <span class="hljs-attr">ranges</span>: [{
            <span class="hljs-attr">min</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">max</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">style</span>: <span class="hljs-keyword">new</span> M.style.Point({}),
        }, {
            <span class="hljs-attr">min</span>: <span class="hljs-number">4</span>,
            <span class="hljs-attr">max</span>: <span class="hljs-number">8</span>,
            <span class="hljs-attr">style</span>: <span class="hljs-keyword">new</span> M.style.Point({}),

        }
        ...
    ],
    <span class="hljs-attr">animated</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">hoverInteraction</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">displayAmount</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">selectedInteraction</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">distance</span>: <span class="hljs-number">80</span>,
    <span class="hljs-attr">label</span>: {          
     <span class="hljs-attr">font</span>: <span class="hljs-string">'bold 19px Comic Sans MS'</span>, 
     <span class="hljs-attr">color</span>: <span class="hljs-string">'#FFFFFF'</span>
    }
};
<span class="hljs-comment">//generamos un cluster personalizado</span>
<span class="hljs-keyword">let</span> styleCluster = M.style.Cluster(clusterOptions);      </pre>
                                <p>Dónde:</p>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Parámetro</th>
                                            <th>Descripción </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>ranges</strong></td>
                                            <td>{Array\&lt;Object>} - array de objetos con el valor mínimo, el máximo y un <em>M.style.Point</em></td>
                                        </tr>
                                        <tr>
                                            <td><strong>animated</strong></td>
                                            <td>{boolean} - booleano que indica si se quiere animación o no al desplegar el cluster</td>
                                        </tr>
                                        <tr>
                                            <td><strong>hoverInteraction</strong></td>
                                            <td>{boolean} - booleano que indica si se quiere mostrar el polígono que engloba los elementos al situarse sobre el cluster</td>
                                        </tr>
                                        <tr>
                                            <td><strong>displayAmount</strong></td>
                                            <td>{boolean} - booleano que indica si se muestra el número de elementos que componen el cluster</td>
                                        </tr>
                                        <tr>
                                            <td><strong>maxFeaturesToSelect</strong></td>
                                            <td>{number} - Número máximo de elementos agrupados a partir de los cuales, al hacer click, se hará zoom en lugar de desplegar el cluster</td>
                                        </tr>
                                        <tr>
                                            <td><strong>distance</strong></td>
                                            <td>{number} - distancia (en píxeles) de agrupación de elementos</td>
                                        </tr>
                                        <tr>
                                            <td><strong>label</strong></td>
                                            <td>{&lt;Object>} - Estilo opcional de la etiqueta de número de elementos de todos los rangos, si se muestra</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <p>El estilo cluster, al no ser más que una forma de visualización, puede utilizarse en conjunción con otros estilos, por ejemplo con elementos categorizados, como puede verse en este
                                    <h3 id="vendor-params">Vendor params</h3>
                                    <p>Este conjunto de opciones está ligado a la implementación, por lo que se han separado de la configuración base. Actualmente solo existe la implementación de OpenLayers, por lo que los parámetros posibles serán:</p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Parámetro</th>
                                                <th>Descripción </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><strong>distanceSelectFeatures</strong></td>
                                                <td>{number} - distancia (en píxeles) entre los elementos desplegados de un cluster</td>
                                            </tr>
                                            <tr>
                                                <td><strong>convexHullStyle</strong></td>
                                                <td>{Object} - estilo del polígono que engloba los elementos (si <em>hoverInteraction</em> es <em>true</em>)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <pre class="hljs"><span class="hljs-keyword">let</span> vendorParameters = {
    <span class="hljs-attr">distanceSelectFeatures</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">convexHullStyle</span>: {
        <span class="hljs-attr">fill</span>: {
            <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>,
            <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>
        },
        <span class="hljs-attr">stroke</span>: {
            <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>,
            <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>
        }
    }
}
<span class="hljs-comment">//generamos un cluster personalizado al que, además, le indicamos </span>
<span class="hljs-comment">//configuraciones de la implemetnación</span>
<span class="hljs-keyword">let</span> clusterStyle = <span class="hljs-keyword">new</span> M.style.Cluster(clusterOptions, vendorParameters);</pre>
                                    <h3 id="eventos">Eventos</h3>
                                    <p>A la hora de interaccionar con elementos de una capa que ha sido <em>clusterizada</em>, nos encontramos con el problema de poder identificar si el elemento seleccionado es un cluster o no lo es; para ello, en Mapea se ha tipado el cluster como <em>M.ClusteredFeature</em> pudiendo distinguir en cualquier evento si es o no un cluster:</p>
                                    <pre class="hljs">campamentos.on(M.evt.SELECT_FEATURES, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">features, evt</span>) </span>{
      <span class="hljs-comment">//se puede comprobar si el elemento seleccionado es un cluster o no</span>
      <span class="hljs-keyword">if</span> (features[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> M.ClusteredFeature) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Es un cluster'</span>);
      }
});</pre>
                                    <p class="page" id="Composite"></p>
                                    <h1>Composición</h1>
                                    <p>Es posible que una misma capa acepte más de un tipo de simbología a la vez. En esos casos hablamos de <strong>composiciones simbológicas</strong>, y algunos ejemplos de dichas composiciones podrían ser: </p>
                                    <ul>
                                        <li>Una capa puntual con simbología básica definida para ella, que además está clusterizada. </li>
                                        <li>Una capa categorizada por un atributo, con simbología proporcional en base a otro. </li>
                                        <li>Una capa con simbología estadística de tartas, a la que se le aplica simbología proporcional para darle a cada tarta un tamaño diferente en base a un atributo del elemento.</li>
                                    </ul>
                                    <p>Sin embargo, no todas las combinaciones de estilos son posibles. Así por ejemplo, no tendría sentido aplicar en una misma capa una simbología por Coropleta y otra por Categorización, ya que ambas se pisarían. </p>
                                    <p>Estas composiciones simbológicas están modeladas en Mapea bajo la clase <strong>M.style.Composite</strong>, de la que heredan todas las simbologías sobre las que pueden añadirse simbologías adicionales: </p>
                                    <ul>
                                        <li>M.style.Proportional</li>
                                        <li>M.style.Choropleth</li>
                                        <li>M.style.Category</li>
                                        <li>M.style.Cluster</li>
                                    </ul>
                                    <p>Dicha clase posee métodos específicos, heredados por tanto para los estilos anteriores, para la gestión de estilos adicionales: </p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Método</th>
                                                <th>Descripción </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><strong>add</strong>(M.Style \</td>
                                                <td>Array&lt;M.Style&gt;): M.style.Composite</td>
                                                <td>Agrega uno o varios estilos adicionales al estilo</td>
                                            </tr>
                                            <tr>
                                                <td><strong>remove</strong>(M.Style \</td>
                                                <td>Array&lt;M.Style&gt;): M.style.Composite</td>
                                                <td>Elimina uno o varios estilos que estén agregados</td>
                                            </tr>
                                            <tr>
                                                <td><strong>getStyles</strong>(): Array&lt;M.Style&gt;</td>
                                                <td>Devuelve los estilos agregados a un estilo de tipo Composite</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Veamos a continuación la implementación de uno de los ejemplos planteados inicialmente: </p>
                                    <pre class="hljs"><span class="hljs-keyword">let</span> map = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>
});

<span class="hljs-comment">// Capa puntual de Campamentos</span>
<span class="hljs-keyword">var</span> campamentos = <span class="hljs-keyword">new</span> M.layer.WFS({
<span class="hljs-attr">url</span>: <span class="hljs-string">"http://geostematicos-sigc.juntadeandalucia.es/geoserver/sepim/ows?"</span>,
<span class="hljs-attr">name</span>: <span class="hljs-string">"campamentos"</span>,
<span class="hljs-attr">legend</span>: <span class="hljs-string">"Campamentos"</span>,
<span class="hljs-attr">geometry</span>: <span class="hljs-string">'MPOINT'</span>
});

map.addLayers(campamentos);

<span class="hljs-comment">// Estilo basico: puntos amarillos con borde rojo</span>
<span class="hljs-keyword">let</span> estilo_base = <span class="hljs-keyword">new</span> M.style.Point({
  <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">fill</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'yellow'</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>
  },
  <span class="hljs-attr">stroke</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'#FF0000'</span>
  }
});

<span class="hljs-comment">// Estilo cluster por defecto</span>
<span class="hljs-keyword">let</span> estilo_cluster = <span class="hljs-keyword">new</span> M.style.Cluster();

<span class="hljs-comment">// Cluster permite Composite, asi que se le puede agregar el estilo base</span>
<span class="hljs-keyword">let</span> composite = estilo_cluster.add(estilo_base);

<span class="hljs-comment">// Y asignamos a la capa la composicion creada</span>
campamentos.setStyle(composite);</pre>
                                    <p class="page" id="Controles"></p>
                                    <h1>Controles básicos</h1>
                                    <p>Mapea dispone de una serie de <strong>controles básicos</strong>, que se especifican mediante el parámetro
                                        &#39;<em>controls</em>&#39; en el constructor del mapa, o llamando al método <em>.addControls</em> del mismo. En
                                        ambos casos pueden especificarse como cadenas o como objetos: </p>
                                    <pre class="hljs">mapajs = M.map({
     <span class="hljs-attr">container</span>:<span class="hljs-string">"map"</span>,
     <span class="hljs-attr">controls</span>:[<span class="hljs-string">'scale'</span>,<span class="hljs-string">'location'</span>,<span class="hljs-string">'layerswitcher'</span>,<span class="hljs-string">'mouse'</span>]
});</pre>
                                    <pre class="hljs"><span class="hljs-comment">// Añadir controles</span>
mapajs.addControls([<span class="hljs-string">'scale'</span>,<span class="hljs-string">'location'</span>,<span class="hljs-string">'layerswitcher'</span>]);

mapajs.addControls([
    <span class="hljs-keyword">new</span> M.control.Mouse(),
    <span class="hljs-keyword">new</span> M.control.OverviewMap()]);

<span class="hljs-comment">// Obtener array de controles del mapa</span>
<span class="hljs-keyword">var</span> controles = mapajs.getControls();
<span class="hljs-comment">// Filtrar controles por nombre</span>
<span class="hljs-keyword">var</span> controlTOC = mapajs.getControls({<span class="hljs-attr">name</span>:<span class="hljs-string">'layerswitcher'</span>})[<span class="hljs-number">0</span>];</pre>
                                    <p>Estos son los controles básicos que incluye Mapea:</p>
                                    <ul>
                                        <li><strong>Panzoombar</strong>: Añade una barra de desplazamiento para acercarse/alejarse del mapa.</li>
                                        <li><strong>LayerSwitcher</strong>: Incluye un árbol de contenidos (TOC) replegable al mapa. En ese árbol se
                                            mostrarán las capas según el nombre público que se les haya dado en su construcción. Para las capas WMS,
                                            mostrará además la leyenda que la operación <em>GetLegendGraphic</em>. </li>
                                    </ul>
                                    <blockquote>
                                        <p> <a> En los <a href="#WMC">WMC</a>, la presencia o no de
                                                una capa en el TOC viene establecida por el tag <em><strong>displayInLayerSwitcher</strong></em>, así como
                                                su leyenda por <em><strong>LegendURL</strong></em>.</a></p>
                                    </blockquote>
                                    <ul>
                                        <li><strong>OverviewMap</strong>: añade un mapa de ubicación, donde se representa la capa base a una escala menor.
                                        </li>
                                        <li><strong>Scale</strong>, <strong>ScaleLine</strong>: añade escalas numérica y gráfica respectivamente. </li>
                                        <li><strong>Mouse</strong>: muestra las coordenadas de la posición donde se encuentre el puntero del ratón. </li>
                                    </ul>
                                    <blockquote>
                                        <p> <a> Las coordenadas no aparecen en dispositivo móviles, ya que se manejan con eventos táctiles, no con
                                                ratón.</a> </p>
                                    </blockquote>
                                    <ul>
                                        <li><strong>Location</strong>: Añade un botón de centrado en la posición del usuario. Se le puede indicar si se
                                            desea posicionamiento continuo (<em>tracking</em>, por defecto a <em>true</em>) y alta precisión
                                            (<em>highAccuracy</em>, por defecto a false)</li>
                                        <li><strong>GetFeatureInfo</strong>: Añade la herramienta de consulta de información sobre capas WMS a través de su
                                            servicio getFeatureInfo. Por defecto, espera Html como formato de respuesta. Otros formatos soportados son
                                            &#39;<em>gml</em>&#39; y &#39;<em>plain</em>&#39;. Admite también un buffer en pixeles opcional:</li>
                                    </ul>
                                    <pre class="hljs">mapajs.addControls(<span class="hljs-keyword">new</span> M.control.GetFeatureInfo(
 <span class="hljs-string">'gml'</span>, 
 {<span class="hljs-attr">buffer</span>: <span class="hljs-number">1000</span>}));</pre>
                                    <p>Los controles también pueden activarse o desactivarse por código:</p>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> ctrlLocation = mapajs.getControls({<span class="hljs-attr">name</span>:<span class="hljs-string">'location'</span>})[<span class="hljs-number">0</span>];
ctrlLocation.activate(); <span class="hljs-comment">//para activarlo</span>
ctrlLocation.deactivate(); <span class="hljs-comment">//para desactivarlo</span></pre>
                                    <p class="page" id="Opciones"></p>
                                    <h1><strong>&gt; Opciones</strong></h1>
                                    <p><strong>Opciones de personalización</strong></p>
                                    <p>Mapea4 implementa por defecto una serie de propiedades que permiten personalizar el mapa a visualizar. Estas opciones son:</p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Parámetro</th>
                                                <th>Descripción </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><strong>zoom</strong></td>
                                                <td>nivel de zoom del mapa </td>
                                            </tr>
                                            <tr>
                                                <td><strong>bbox</strong></td>
                                                <td>encuadre de visualización del mapa </td>
                                            </tr>
                                            <tr>
                                                <td><strong>maxExtent</strong></td>
                                                <td>máxima extensión permitida; a diferencia del <em>bbox</em>, no se dibujará el mapa fuera de los límites establecidos</td>
                                            </tr>
                                            <tr>
                                                <td><strong>projection</strong></td>
                                                <td>proyección de visualización del mapa</td>
                                            </tr>
                                            <tr>
                                                <td><strong>center</strong></td>
                                                <td>punto central del mapa </td>
                                            </tr>
                                            <tr>
                                                <td><strong>label</strong></td>
                                                <td>popup con el texto indicado en una coordenada especificada o, en su defecto, en el centro (<em>center</em>) establecido del mapa</td>
                                            </tr>
                                            <tr>
                                                <td><strong>resolutions</strong></td>
                                                <td>array con las resoluciones asociadas a cada nivel de zoom del mapa</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Cada uno de estos parámetros <strong>puede especificarse directamente en el constructor o bien a través de su método <em>setter</em> correspondiente</strong>, al igual que puede obtenerse su valor actual con su método <em>getter</em></p>
                                    <h3 id="en-tiempo-de-construcci-n">En tiempo de construcción</h3>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
  <span class="hljs-attr">controls</span>: [<span class="hljs-string">"mouse"</span>, <span class="hljs-string">"layerswitcher"</span>],
  <span class="hljs-attr">center</span>: {
    <span class="hljs-attr">x</span>: <span class="hljs-number">311000</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-number">4040000</span>,
    <span class="hljs-attr">draw</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">projection</span>: <span class="hljs-string">"EPSG:25830*m"</span>,
  <span class="hljs-attr">zoom</span>: <span class="hljs-number">5</span>
});</pre>
                                    <h3 id="zoom">zoom</h3>
                                    <pre class="hljs">mapajs.setZoom(<span class="hljs-number">5</span>);</pre>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> zoom = mapajs.getZoom();</pre>
                                    <h3 id="bbox">bbox</h3>
                                    <pre class="hljs">mapajs.setBbox([<span class="hljs-number">323020</span>,<span class="hljs-number">4126873</span>,<span class="hljs-number">374759</span>,<span class="hljs-number">4152013</span>]);</pre>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> bbox = mapajs.getBbox();</pre>
                                    <h3 id="maxextent">maxExtent</h3>
                                    <pre class="hljs">mapajs.setMaxExtent ([<span class="hljs-number">323020</span>,<span class="hljs-number">4126873</span>,<span class="hljs-number">374759</span>,<span class="hljs-number">4152013</span>]);</pre>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> maxExtent = mapajs.getMaxExtent();</pre>
                                    <h3 id="projection">projection</h3>
                                    <pre class="hljs">mapajs.setProjection (<span class="hljs-string">"EPSG:4326*d"</span>);</pre>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> projection = mapajs.getProjection();</pre>
                                    <p>Hay que tener en cuenta que si se cambia el sistema de referencia del mapa, las coordenadas que usemos a partir de ese momento deben ser las del nuevo sistema. </p>
                                    <h3 id="center">center</h3>
                                    <pre class="hljs">mapajs.setCenter({<span class="hljs-attr">x</span>:<span class="hljs-number">211000</span>,
                  <span class="hljs-attr">y</span>:<span class="hljs-number">4040000</span>,
                  <span class="hljs-attr">draw</span>: <span class="hljs-literal">true</span>});
</pre>
                                    <blockquote>
                                        <p> <a> El parámetro <em>draw</em> indica si queremos añadir una chincheta en el punto central establecido</a></p>
                                    </blockquote>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> center mapajs.getCenter();
</pre>
                                    <h3 id="label">label</h3>
                                    <pre class="hljs">mapajs.addLabel(<span class="hljs-string">"texto &lt;b&gt;con html&lt;/b&gt;"</span>,[<span class="hljs-number">211000</span>, <span class="hljs-number">4040000</span>]);

<span class="hljs-comment">//sin especificar coordenada, se añade en el centro establecido</span>
mapajs.addLabel(<span class="hljs-string">"texto &lt;b&gt;con html&lt;/b&gt;"</span>); 

<span class="hljs-comment">//para eliminarla</span>
mapajs.removeLabel();</pre>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> label = mapajs.getLabel();</pre>
                                    <h3 id="resolutions">resolutions</h3>
                                    <p>Las resoluciones del mapa establecen las escalas a las que se visualizan las capas en cada nivel de zoom. Si fijamos manualmente las resoluciones, hay que tener en cuenta dos factores: </p>
                                    <ul>
                                        <li>Estaremos indirectamente estableciendo el número de niveles de zoom.</li>
                                        <li>Si usamos capas cacheadas compatibles con resoluciones específicas, pueden no mostrarse si no casan con las que establezcamos </li>
                                    </ul>
                                    <p>El siguiente ejemplo establece resoluciones explícitas para el mapa:</p>
                                    <pre class="hljs"><span class="hljs-comment">// Dos resoluciones = dos niveles de zoom</span>
mapajs.setResolutions([<span class="hljs-number">490.4640841686878</span>, <span class="hljs-number">296.4735539465016</span>]);  

<span class="hljs-comment">// Podemos consultar las resoluciones del mapa</span>
<span class="hljs-built_in">console</span>.log(mapajs.getResolutions());

<span class="hljs-comment">// También podemos definir las resoluciones en el constructor</span>
mapajs = M.map({
     <span class="hljs-attr">container</span>: <span class="hljs-string">'map'</span>,
     <span class="hljs-attr">resolutions</span>: [<span class="hljs-number">490.4640841686878</span>, <span class="hljs-number">296.4735539465016</span>, <span class="hljs-number">179.21101876124024</span>],
     <span class="hljs-attr">projection</span> : <span class="hljs-string">'EPSG:25830*m'</span>
});</pre>
                                    <p class="page" id="Paneles"></p>
                                    <h1><strong>&gt; Paneles</strong></h1>
                                    <p>Mapea proporciona una serie de paneles que facilitan la organización de plugins y controles sobre el mapa. Para crear uno de estos paneles se proporciona el objeto del tipo <em>M.ui.Panel</em>:</p>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> panelExtra = <span class="hljs-keyword">new</span> M.ui.Panel(<span class="hljs-string">'toolsExtra'</span>, {
  <span class="hljs-string">"collapsible"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-string">"className"</span>: <span class="hljs-string">'m-tools'</span>,
  <span class="hljs-string">"collapsedButtonClass"</span>: <span class="hljs-string">'g-cartografia-herramienta'</span>,
  <span class="hljs-string">"position"</span>: M.ui.position.TL
});
panelExtra.addControls([<span class="hljs-keyword">new</span> M.control.Location()]);
mapajs.addPanels([panelExtra]);</pre>
                                    <ul>
                                        <li><strong>collapsible:</strong> indica si se podrá contraer (true) o no (false).</li>
                                        <li>
                                            <p><strong>className:</strong> clase CSS que se usará para los estilos del panel.<br>Es posible especificar varias clases de manera que se puedan extender las existentes con las personalizaciones que se deseen, bastaría con definir los estilos deseados en nuestro <em>css</em> e importarlo después del de Mapea: </p>
                                            <pre class="hljs">  <span class="hljs-string">"className"</span>: <span class="hljs-string">'m-tools m-tools-extra'</span></pre>
                                            <pre class="hljs">  <span class="hljs-selector-class">.m-tools-extra</span> &gt; <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.m-panel-btn</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#f00819</span>;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;
  }</pre>
                                        </li>
                                        <li><strong>collapsedButtonClass:</strong> clase CSS que definirá el icono del panel contraído. No es obligatorio y si no se indica, por defecto mostrará una flecha en la dirección de despligue.</li>
                                        <li>
                                            <p><strong>position:</strong> establece la posición del panel y puede tomar los siguientes valores:</p>
                                            <p> Valor | Descripción
                                                ---|---
                                                M.ui.position.TL | Arriba a la izquierda
                                                M.ui.position.TR | Arriba a la derecha
                                                M.ui.position.BR | Abajo a la derecha
                                                M.ui.position.BL | Abajo a la izquierda</p>
                                        </li>
                                    </ul>
                                    <p><strong>Gestión de paneles</strong><br>En cualquier momento pueden recuperarse los paneles existentes en el mapa, filtrando por el nombre si así se desea: </p>
                                    <pre class="hljs">    <span class="hljs-keyword">var</span> panel = mapajs.getPanels(<span class="hljs-string">'miPanel'</span>)[<span class="hljs-number">0</span>];</pre>
                                    <p>Además de en el constructor, se puede manipular el estilo del panel accediendo directamente su template: </p>
                                    <pre class="hljs">    panel.getTemplatePanel().style.backgroundColor = <span class="hljs-string">"red"</span>;</pre>
                                    <p>Los paneles pueden abrirse/cerrarse mediante instrucciones a través de sus métodos <strong><em>open()</em></strong> y <strong><em>collapse()</em></strong> respectivamente. </p>
                                    <p>Los paneles son contendores directos de <a href="#Controles">controles</a>, ya sean básicos o de plugins, y pueden obtenerse así: </p>
                                    <pre class="hljs">    <span class="hljs-keyword">var</span> controles = panel.getControls();</pre>
                                    <p class="page" id="Plugins"></p>
                                    <h1><strong>Plugins</strong></h1>
                                    <p>Los <strong>plugins</strong> son organizaciones funcionales de uno o más controles que ofrecen utilidades específicas que, a diferencia de los <a href="#Controles">controles básicos</a>, suelen usarse sólo en escenarios concretos, por lo que se separan del <em>core</em> o núcleo principal de Mapea para no penalizar con su descarga a quien no los necesite. Algunos ejemplos son el plugin de impresión, búsquedas en lenguaje natural, o edición wfst.</p>
                                    <p>Por esa razón, cada plugin tiene sus propios ficheros de recursos, que deben importarse junto a los del core de Mapea, tal como se indica en la sección de <a href="#Primeros-pasos">primeros pasos de esta wiki</a>.</p>
                                    <p>El conjunto de plugins incluidos en el core de Mapea es el siguiente:</p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Plugin</th>
                                                <th>Descripción</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><a href="https://github.com/sigcorporativo-ja/Mapea4/tree/master/mapea-js/src/plugins/attributetable">attributetable</a></td>
                                                <td>Muestra los elementos de las capas vectoriales en una tabla</td>
                                            </tr>
                                            <tr>
                                                <td><a href="https://github.com/sigcorporativo-ja/Mapea4/tree/master/mapea-js/src/plugins/autocomplete">autocomplete</a></td>
                                                <td>Autocompletado en base a un servicio REST</td>
                                            </tr>

                                            <tr>
                                                <td><a href="https://github.com/sigcorporativo-ja/Mapea4/tree/master/mapea-js/src/plugins/measurebar">measurebar</a></td>
                                                <td>Herramienta de medición de áreas y distancias </td>
                                            </tr>
                                            <tr>
                                                <td><a href="https://github.com/sigcorporativo-ja/Mapea4/tree/master/mapea-js/src/plugins/printer">printer</a></td>
                                                <td>Impresión en alta resolución del mapa</td>
                                            </tr>
                                            <tr>
                                                <td><a href="https://github.com/sigcorporativo-ja/Mapea4/tree/master/mapea-js/src/plugins/wfstcontrols">wfstcontrols</a></td>
                                                <td>Herramientas de edición WFST</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>En la carpeta principal de cada uno existe un fichero README.md que lo documenta: <em>descripción</em>, <em>ficheros de recursos</em> y <em>ejemplos</em>. </p>
                                    <p>Existen plugins adicionales externos al core de Mapea, desarrollados tanto por el propio proyecto SIGCorporativo como por terceros. La distribución y características de estos variará según el desarrollador</p>
                                    <p><strong>Estructura interna</strong></p>
                                    <p>Existen unas normas y pautas establecidas para el desarrollo de plugins, que garantizan homogeneidad en su estructura interna, y facilitan el desarrollo de nuevos componentes. Estas normas y pautas están recogidas con detalle en la <strong><a href="https://github.com/sigcorporativo-ja/Mapea4-dev-webpack/wiki"></a>guía de desarrollo de plugins</a></strong>. </p>
                                    <p>El mapa gestiona los plugins a través de los siguientes métodos: </p>
                                    <pre class="hljs"><span class="hljs-comment">// Añadir plugin al mapa</span>
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> M.plugin.NombrePlugin();
mapajs.addPlugin(p);

<span class="hljs-comment">// Obtener plugins del mapa</span>
<span class="hljs-keyword">var</span> arrayPlugins = mapajs.getPlugins();

<span class="hljs-comment">// Eliminar plugin del mapa</span>
mapajs.removePlugins(p);</pre>
                                    <p class="page" id="Proxys"></p>
                                    <h1><strong>Proxys</strong></h1>
                                    <p>La <a href="https://en.wikipedia.org/wiki/Same-origin_policy"><strong>política del mismo origen</strong></a> establece que, por motivos de seguridad, un script de una página web no puede acceder a contenido de dominios web diferentes de aquel en el que residen, salvo algunas excepciones, como contenido de tipo imagen. Es decir, no se permite <strong>cross domain</strong>.</p>
                                    <p>La lógica del visualizador está implementada en javascript, por lo que está supeditada a dicha política del mismo origen. Eso significa que peticiones <em>getMap</em> o <em>getLegendGraphic</em> del estándar WMS pueden realizarse sin problemas ya que están solicitando imágenes, pero no ocurre lo mismo con peticiones como <em>getCapabilities</em>, <em>getFeatures</em>, <em>getFeatureInfo</em>, o cualquiera que devuelva contenido de otro tipo (GML/XML en estos casos).</p>
                                    <p>Existen en la actualidad diversos enfoques que permiten a una aplicación realizar esas peticiones, y en Mapea se llevan a cabo haciendo uso de <strong>proxys</strong>.</p>
                                    <p>Un <strong>proxy</strong> es una lógica o servicio que se encarga de realizar las peticiones de recursos que le solicita un tercero, en este caso el visualizador, ya que no está supeditado a la política del mismo origen generalmente al no estar implementado con scripts. Por lo tanto, el visualizador solicita el recurso a un proxy que esté en su mismo dominio, éste lo obtiene, y se lo devuelve al visualizador. En Mapea existen dos proxys diferentes: JSONP y POST.</p>
                                    <p><strong>Proxy JSONP</strong></p>
                                    <p>Este proxy devuelve el recurso solicitado en formato <a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>. Esto permite ejecutarlo directamente desde un script, en su atributo &quot;<em>src</em>&quot;, mediante la función de callback definida en el cliente, sin que afecte así la política del mismo origen. Es por eso que <em>este proxy no necesita estar desplegado en el mismo dominio que la aplicación web que lo llama</em>. Cualquier aplicación puede usar por tanto el de Mapea4: </p>
                                    <p><a href="https://cnigvisores_pub.desarrollo.guadaltel.es/mapea/api/proxy?url=http%3A%2F%2Fwww.ign.es%2Fwmts%2Fign-base%3Frequest%3DGetCapabilities%26service%3DWMTS&amp;callback=mifuncion">Respuesta</a></p>
                                    <p>El programador <em>no necesita hacer uso explícito de este proxy</em>, el api de Mapea4 se hace cargo de llamarlo cuando sea necesario.</p>
                                    <p><strong>Proxy POST</strong> </p>
                                    <p>Para algunas comunicaciones donde se adjunta un alto volumen de información, como por ejemplo en las peticiones WFST, no es viable el uso del proxy JSONP, debido a las limitaciones que establecen las peticiones GET. </p>
                                    <p>Para esos casos ha de usarse el proxy <strong>POST</strong>. Debe estar desplegado en el mismo dominio que la aplicación, para que haya una comunicación entre ambos sin cross domain, y hay que configurar Mapea para que lo use.</p>
                                    <p><strong>Visibilidad</strong> </p>
                                    <p>Como el acceso final al recurso que pide el visualizador lo realiza el proxy, <strong>éste debe tener visibilidad de dicho recurso</strong>. Es decir, si se solicita por ejemplo un fichero wmc, dicho fichero deberá estar en una url accesible por el proxy. Esto hay que tenerlo en cuenta especialmente cuando se trabaja en entornos de Prueba y de Desarrollo, donde por lo general los recursos que se usan no son públicos. En esos casos suelen usarse proxys locales durante la etapa de desarrollo, configurando Mapea para que use esos proxys.</p>
                                    <p><strong>Configuración de los proxys</strong> </p>
                                    <p>La configuración de los proxys se lleva a cabo en el fichero <em>configuration.js</em> de Mapea. Para cambiar las urls de los mismos y usar otros proxys, después de haber importado dicho fichero, y antes de comenzar con la creación de los mapas, hay que indicar las nuevas urls mediante las siguientes instrucciones:</p>
                                    <pre class="hljs">M.config(<span class="hljs-string">'PROXY_POST_URL'</span>, <span class="hljs-string">'$URL_PROXY_POST'</span>);
M.config(<span class="hljs-string">'PROXY_URL'</span>, <span class="hljs-string">'$URL_PROXY_JSONP'</span>);</pre>
                                    <p>También es posible desactivar el uso de proxys:</p>
                                    <pre class="hljs">M.proxy(<span class="hljs-literal">false</span>);</pre>
                                    <p class="page" id="Eventos"></p>
                                    <h1><strong>Eventos</strong></h1>
                                    <p>Los <strong>eventos</strong> son disparadores que permiten al programador conocer cuándo ha ocurrido un suceso determinado, de manera que pueda actuar en consecuencia. Estos son los eventos que maneja Mapea: </p>
                                    <p><strong>Asociados al mapa y a las capas</strong></p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Evento</th>
                                                <th>Descripción</th>
                                                <th>Evento</th>
                                                <th>Descripción</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>M.evt.ADDED_LAYER</td>
                                                <td>Se ha añadido una capa</td>
                                                <td>M.evt.ADDED_WFS</td>
                                                <td>Se ha añadido una capa WFS </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.ADDED_WMC</td>
                                                <td>Se ha añadido un wmc</td>
                                                <td>M.evt.ADDED_WMT</td>
                                                <td>Se ha añadido una capa WMTS </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.ADDED_KML</td>
                                                <td>Se ha añadido una capa KML</td>
                                                <td>M.evt.LOAD</td>
                                                <td>Sobre capa vectorial: Se han cargado los features de la capa. <br> Sobre WMC: Se ha activado el WMC. </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.ADDED_WMS</td>
                                                <td>Se ha añadido una capa WMS</td>
                                                <td>M.evt.COMPLETED</td>
                                                <td>Se ha completado la definición interna del mapa. Requiere capa base. </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.CHANGE</td>
                                                <td>Ha cambiado la proyección del mapa</td>
                                                <td>M.evt.CHANGE_WMC</td>
                                                <td>Ha cambiado el wmc activo. </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.CLICK</td>
                                                <td>Se ha hecho click en el mapa (captura coordenadas)</td>
                                                <td>M.evt.CHANGE_STYLE</td>
                                                <td>Sobre capa vectorial: Ha cambiado el estilo de la capa. <br> Sobre feature: Ha cambiado el estilo del feature.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <blockquote>
                                        <p> <a> Para asociar un evento, se usa el método <em><strong>.on(evento,accion)</strong></em>, y para desasociarlo, se usa <em><strong>.un(evento,accion)</strong></em></a></p>
                                    </blockquote>
                                    <p>Ejemplo </p>
                                    <pre class="hljs"><span class="hljs-comment">// Declaramos directamente las acciones que realizar en el evento</span>
mapajs.on(M.evt.ADDED_LAYER, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Evento M.evt.ADDED_LAYER: se ha añadido una capa al mapa'</span>);
});

<span class="hljs-comment">// O mediante una funcion definida</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mostrarMensajeEvento</span>(<span class="hljs-params"></span>) </span>{
    M.dialog.info(<span class="hljs-string">'el evento ha ocurrido'</span>);
}
mapajs.on(M.evt.ADDED_WFS, mostrarMensajeEvento);

<span class="hljs-comment">// El evento de carga de WFS es util cuando queremos procesar los features</span>
wfslayer.on(M.evt.LOAD, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">features</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Evento M.evt.LOAD: se ha cargado la capa WFS en el mapa con los elementos:"</span>, features);
});</pre>
                                    <p><strong>Asociados a los paneles</strong></p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Evento</th>
                                                <th>Descripción </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>M.evt.ADDED_TO_MAP</td>
                                                <td>El panel se ha añadido al mapa </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.SHOW</td>
                                                <td>El panel se ha abierto </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.HIDE</td>
                                                <td>El panel se ha ocultado </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p><strong>Asociados a los controles</strong> </p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Evento</th>
                                                <th>Descripción</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>M.evt.ADDED_TO_PANEL</td>
                                                <td>El control se ha añadido al panel</td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.ACTIVATED</td>
                                                <td>El control se ha activado </td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.DEACTIVATED</td>
                                                <td>El control se ha desactivado</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Ejemplo</p>
                                    <pre class="hljs">newControl.on(M.evt.ACTIVATED,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Control Activado'</span>);});</pre>
                                    <p><strong>Asociados a la interacción con features</strong><br>Estos eventos devuelven siempre un Array con los features objeto del mismo, ya que es posible, según
                                        la ubicación de los features y el nivel de zoom, que la selección o el desplazamiento se realice en múltiples
                                        features simultáneamente. </p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Evento</th>
                                                <th>Descripción</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>M.evt.SELECT_FEATURES</td>
                                                <td>Se ha seleccionado un feature</td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.UNSELECT_FEATURES</td>
                                                <td>Un feature ha perdido la selección</td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.HOVER_FEATURES</td>
                                                <td>El cursor pasa por encima de un feature</td>
                                            </tr>
                                            <tr>
                                                <td>M.evt.LEAVE_FEATURES</td>
                                                <td>El cursor abandona un feature</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>Ejemplo</p>
                                    <pre class="hljs"><span class="hljs-keyword">var</span> capaKML = <span class="hljs-keyword">new</span> M.layer.KML(
<span class="hljs-string">"KML*Arboleda*http://mapea4-sigc.juntadeandalucia.es/files/kml/*arbda_sing_se.kml*true"</span>);
<span class="hljs-comment">// Los features sobre los que se pinche se devuelven en un Array</span>
capaKML.on(M.evt.SELECT_FEATURES, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">features</span>) </span>{ 
alert(<span class="hljs-string">"Se han seleccionado los features: "</span>, features); });</pre>
                                    <p><strong>Otros</strong> </p>
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Evento</th>
                                                <th>Descripción</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>M.evt.DESTROY</td>
                                                <td>Se ha lanzado el método Destroy del elemento </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p><strong>FeatureHandler</strong> </p>
                                    <p>El objeto mapa posee un gestor de eventos llamado <strong>FeatureHandler</strong> desde el que se puede activar y desactivar la selección de features específicos, así como añadir o eliminar una capa vectorial de la gestión de eventos vectoriales: </p>
                                    <pre class="hljs"><span class="hljs-comment">// Array de features a seleccionar, capa que los contiene y evt opcional</span>
mapajs.getFeatureHandler().selectFeatures([feature],layer,{});
<span class="hljs-comment">// Array de features a deseleccionar, capa que los contiene y evt opcional</span>
mapajs.getFeatureHandler().unselectFeatures([feature],layer,{});
<span class="hljs-comment">// Eliminar una capa del gestor implica no poder usar los metodos</span>
<span class="hljs-comment">// anteriores sobre sus features</span>
mapajs.getFeatureHandler().removeLayer(layer);</pre>
                                    <p class="page" id="Utilidades"></p>
                                    <h1><strong>Utilidades</strong></h1>
                                    <p><strong>Diálogos</strong><br>Permite crear diálogos modales de tres tipos: informativos, de error o de éxito de operación: </p>
                                    <pre class="hljs">M.dialog.info(<span class="hljs-string">'Mensaje informativo'</span>); <span class="hljs-comment">// color azul</span>
M.dialog.error(<span class="hljs-string">'Mensaje de error'</span>); <span class="hljs-comment">// color rojo</span>
M.dialog.success(<span class="hljs-string">'Mensaje de éxito'</span>); <span class="hljs-comment">// color verde</span></pre>
                                    <p>Cada tipo de diálogo tiene asociado un color diferente, y se cierran cuando el usuario pincha el botón de aceptar. Además, devuelven un <strong>promise</strong> para poder manipularlo, como por ejemplo controlar el momento en que el usuario lo pinche, si así se desea: </p>
                                    <pre class="hljs">M.dialog.info(<span class="hljs-string">'Mensaje informativo'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    $(<span class="hljs-string">".m-dialog button"</span>).first().on(<span class="hljs-string">"click"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      alert(<span class="hljs-string">"botón de diálogo pinchado"</span>);
  });</pre>
                                    <hr>
                                    <p><strong>Popups</strong><br>El mapa dispone de un objeto Popup que puede gestionarse de la siguiente manera: </p>
                                    <pre class="hljs"><span class="hljs-comment">// Acceso</span>
<span class="hljs-keyword">var</span> popup = mapajs.getPopup();
<span class="hljs-comment">// Eliminación</span>
mapajs.removePopup();</pre>
                                    <p>Para construirlo, necesitamos una pestaña con el contenido, y unas coordenadas para añadirlo al mapa: </p>
                                    <pre class="hljs"><span class="hljs-comment">// Creamos un objeto tab </span>
  <span class="hljs-keyword">var</span> featureTabOpts = {
    <span class="hljs-string">'icon'</span>: <span class="hljs-string">'g-cartografia-pin'</span>,
    <span class="hljs-string">'title'</span>: <span class="hljs-string">'Título de la pestaña'</span>,
    <span class="hljs-string">'content'</span>: <span class="hljs-string">'Código html que se quiere mostrar en la pestaña'</span>
  };
  <span class="hljs-comment">// Creamos el Popup y le añadimos la pestaña</span>
  popup = <span class="hljs-keyword">new</span> M.Popup();
  popup.addTab(featureTabOpts);
  <span class="hljs-comment">// Finalmente se añade al mapa, especificando las Coordenadas</span>
  mapajs.addPopup(popup, [<span class="hljs-number">240829</span>,<span class="hljs-number">4143088</span>]);
});</pre>
                                    <hr>
                                    <p><strong>Remote</strong></p>
                                    <p>Mapea incluye un mecanismo para realizar peticiones AJAX, haciendo uso de proxy si este está configurado, evitando de esta forma tener que escribir todo el código para hacer la petición o tener que hacer uso de más librerías que facilitan esta tarea.</p>
                                    <pre class="hljs"><span class="hljs-comment">//Creamos el mapa</span>
<span class="hljs-keyword">var</span> mapajs = M.map({
  <span class="hljs-attr">container</span>: <span class="hljs-string">"map"</span>,
  <span class="hljs-attr">wmcfiles</span>: [<span class="hljs-string">"cdau"</span>]
});

mapajs.getMapImpl().on(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{

<span class="hljs-comment">//Hacemos una peticón get con M.remote</span>
  M.remote.get(<span class="hljs-string">"http://ovc.catastro.meh.es/ovcservweb/OVCSWLocalizacionRC/OVCCoordenadas.asmx/Consulta_RCCOOR"</span>,
{<span class="hljs-string">'SRS'</span>:mapajs.getProjection().code,
<span class="hljs-string">'Coordenada_X'</span>:e.coordinate[<span class="hljs-number">0</span>],
<span class="hljs-string">'Coordenada_Y'</span>:e.coordinate[<span class="hljs-number">1</span>]}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{
      alert(res.text);
  });
});</pre>
                                    <p class="page" id="Acceso-libreria-base"></p>
                                    <h1><strong>Acceso librerías base</strong></h1>
                                    <p>Mapea es una capa en forma de API que se coloca sobre una librería de mapas base, como pueden ser Open Layers o Leaflet, con el fin, entre otros, de independizar el uso directo de las mismas. Esto facilita por ejemplo la migración o actualización de las librerías de mapas subyacientes de una manera transparente al usuario, que si usa únicamente el api de Mapea, ve como actualizar su código a esas nuevas versiones se convierte en una tarea trivial, beneficiándose de las mejoras que ello conlleva. </p>
                                    <p>Para ello, Mapea ofrece en su API las operaciones de construcción y manipulación de mapas y orígenes de datos más comunes en los visualizadores web. Sin embargo, para que esto no suponga una limitación, el programador siempre podrá acceder a los objetos mapa y layer de la librería que use, y manipularlos directamente. </p>
                                    <p>Esta práctica <strong>no es recomendable</strong> porque estará generando una dependencia directa de nuestro código con la librería base, pero en caso de ser necesario, puede hacerse tal como muestra el siguiente ejemplo: </p>
                                    <pre class="hljs"><span class="hljs-comment">// Construimos un mapa de Mapea</span>
mapajs = M.map({
     <span class="hljs-attr">container</span>:<span class="hljs-string">"map"</span>,
     <span class="hljs-attr">controls</span>:[<span class="hljs-string">'scale'</span>,<span class="hljs-string">'location'</span>,<span class="hljs-string">'layerswitcher'</span>,<span class="hljs-string">'mouse'</span>]
});

<span class="hljs-comment">// Accedemos al OL</span>
<span class="hljs-keyword">var</span> mapaOL = mapajs.getMapImpl();

<span class="hljs-comment">// Puede hacerse lo mismo con los objetos de tipo Layer</span>
<span class="hljs-comment">// En este caso, estamos usando la implementación de OL de Mapea</span>
<span class="hljs-keyword">var</span> layerOL = layerMapea.getImpl().getOL3Layer();</pre>
                                    <p>En el desarrollo de una página web que accede y manipula directamente los objetos de la librería de mapas base, se recomienda que el código que lo hace se encuentre claramente independizado del resto, aplicando un enfoque <strong>fachada/implementación</strong>, de manera que sea fácil identificarlo en el caso de que se tenga que tratar. Es por ejemplo lo que se hace en los plugins de Mapea. </p>
                                    <h2 id="versionado"><strong>versionado</strong></h2>
                                    <p class="page" id="Mapea-iframe"></p>
                                    <h1><strong>Mapea iframe</strong></h1>
                                    <p>Al igual que se hacía con Mapea3, Mapea4 puede ser integrado en paǵinas web mediante el uso de iframes.
                                        A través del API REST se puede incluir un visualizador interactivo en cualquier página web sin necesidad de disponer de conocimientos específicos en programación ni en el ámbito de los SIG. Para ello únicamente es necesario que el usuario configure el mapa a visualizar a través de una URL:</p>
                                    <p><a href="http://cnigvisores_pub.desarrollo.guadaltel.es/mapea/?controls=mouse,layerswitcher,overviewmap,scaleline,location&amp;layers=WMS*Redes*http://www.ideandalucia.es/wms/mta400v_2008?*Redes_energeticas*true&amp;getfeatureinfo=html">http://cnigvisores_pub.desarrollo.guadaltel.es/mapea/?controls=mouse,layerswitcher,overviewmap,scaleline,location&amp;layers=WMS*Redes*http://www.ideandalucia.es/wms/mta400v_2008?*Redes_energeticas*true&amp;getfeatureinfo=html</a></p>
                                    <p>Esto puede integrarse directamente en un iframe, como se hacía anteriormente:</p>
                                    <pre class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"350px"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500px"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://cnigvisores_pub.desarrollo.guadaltel.es/mapea/?controls=mouse,layerswitcher,overviewmap,scaleline,location&amp;layers=WMS*Redes*http://www.ideandalucia.es/wms/mta400v_2008?*Redes_energeticas*true&amp;getfeatureinfo=html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></pre>
                                    <blockquote>
                                        <p> <a> En la mayoría de los mapas, puede utilizarse cualquier tamaño de iframe, pero para la correcta visualización y funcionamiento del mismo cuando hay bastantes controles, el tamaño mínimo de este iframe debe de ser width=&quot;600&quot; height=&quot;400&quot; </a></p>
                                    </blockquote>
                                    <p>Por tanto, mediante parámetros en la url, podremos configurar un mapa incrustable mediante un iframe. Los parámetros posibles a configurar son: </p>
                                    <table>
                                        <tbody>
                                            <tr>
                                                <th scope="col"><b>Parámetro</b></th>
                                                <th colspan="2" scope="col"><b>Descripción</b></th>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>wmcfile</b></td>
                                                <td colspan="2">indica el/los ficheros WMC a cargar</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>url</u>: url del WMC<br>- <u>nombre</u>: nombre que aparecerá en el selector<br>ó<br>-
                                                    <u>nombrePredefinido</u>: nombre de uno de los contextos predefinidos disponibles</td>
                                            </tr>
                                            <tr>
                                                <td colspan="2"><u>Ejemplo:</u> <a href='http://mapea4-sigc.juntadeandalucia.es/?wmcfile=http://www.callejerodeandalucia.es/wmc/context_cdau_callejero.xml*mapa,cdau_satelite'>http://mapea4-sigc.juntadeandalucia.es/?wmcfile=http://www.callejerodeandalucia.es/wmc/context_cdau_callejero.xml<em>mapa,cdau_satelite</a></td>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>layers</b></td>
                                                <td colspan="2">indica el/las capas a cargar</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>tipoCapa</u>: tipo capa OGC<br>- <u>nombreLeyenda</u>: nombre que aparecerá en la leyenda<br>-
                                                    <u>urlServicio</u>: url al servicio OGC<br>-
                                                    <u>nombreCapa</u>: nombre de la capa OGC<br>-
                                                    <u>transparent</u>: &#39;false&#39; si es una capa base, &#39;true&#39; en caso contrario<br>-
                                                    <u>tiled</u>: &#39;true&#39; si queremos dividir la capa en tiles, &#39;false&#39; en caso contrario </td>
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>zoom</b></td>
                                                <td colspan="2">nivel de zoom aplicado</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>nivelZoom</u>: número entero que indica el nivel de zoom a aplicar
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>center</b></td>
                                                <td colspan="2">coordenadas de centrado del mapa. </td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>coordX</u>: coordenada X<br>- <u>coordY</u>: coordY<br>-
                                                    <u>dibujar chincheta</u>: &#39;false&#39; para solo centrar y &#39;true&#39; para dibujar una chincheta</td>
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>label</b></td>
                                                <td colspan="2">cadena de texto que será visualizada como texto html en un popup en el centro del mapa o en las coordenadas indicadas mediante center</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>texto</u>: texto a mostrar. soporta código html
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>bbox</b></td>
                                                <td colspan="2">encuadre de visualización del mapa</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>minX</u>: coordenada menor eje X<br>- <u>minY</u>: coordenada menor eje Y<br>- <u>maxX</u>: coordenada mayor eje X<br>- <u>maxY</u>: coordenada mayor eje Y
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>maxextent</b></td>
                                                <td colspan="2">máxima extensión permitida; a diferencia del bbox, no se dibujará el mapa fuera de los límites establecidos</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>minX</u>: coordenada menor eje X<br>- <u>minY</u>: coordenada menor eje Y<br>- <u>maxX</u>: coordenada mayor eje X<br>- <u>maxY</u>: coordenada mayor eje Y
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>controls</b></td>
                                                <td colspan="2">controles a incluir en el mapa</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>Pueden incluiser los siguientes controles, separados por coma:<br>
                                                    - <u>scale</u>: escala del mapa<br>
                                                    - <u>scaleLine</u>: línea de escala<br>
                                                    - <u>panzoom</u>: control de zoom<br>
                                                    - <u>panzoombar</u>: control de zoom con barra de nivel<br>
                                                    - <u>layerswitcher</u>: control de gestión de capas<br>
                                                    - <u>mouse</u>: coordenadas del ratón<br>
                                                    - <u>overviewmap</u>: mapa miniatura<br>
                                                    - <u>location</u>: representa la posición del usuario<br>
                                                    Más información en <a href='#Controles'>Controles básicos</a>
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>getfeatureinfo</b></td>
                                                <td colspan="2">añade la herramienta de consulta</td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>Soporta tres formatos, teniendo en cuenta que el servidor debe soportar el indicado:<br>
                                                    - <u>plain</u>: texto plano (por defecto si no se indica ninguno)<br>
                                                    - <u>gml</u>: respuesta en formato GML<br>
                                                    - <u>html</u>: respuesta en HTML<br>
                                            </tr>
                                            <tr>
                                            </tr>
                                            <tr>
                                                <td rowspan="3"><b>projection</b></td>
                                                <td colspan="2">permite configurar el sistema de referencia en el cual se visualiza el mapa. </td>
                                            </tr>
                                            <tr>
                                                <td>Parámetros</td>
                                                <td>- <u>EPSG</u>: código EPSG a utilizar<br>
                                                    - <u>unidades</u>: &#39;m&#39; para metros y &#39;d&#39; para grados
                                            </tr>
                                        </tbody>
                                    </table>

                                    <p>Cabe destacar que el uso de iframes conlleva limitaciones en el acceso al DOM del mismo, así como de políticas de origen. </p>
                                    <p class="page" id="Solucion-de-problemas"></p>
                                    <h1><strong>Solución de problemas</strong></h1>
                                    <p>Cuando se presenta un problema o la aplicación no funciona como debiera, lo primero que debe hacer el desarrollador es activar las herramientas de depuración de las que disponga el navegador que esté usando, tales como las <a href="https://developers.google.com/web/tools/chrome-devtools/">Chrome DevTools</a>, o el complemento <a href="http://getfirebug.com/">Firebug</a> para Firefox. Con dichas herramientas se pueden visualizar mensajes de error, advertencias, peticiones de red, y muchas más información que ayudará a diagnosticar la causa del problema.</p>
                                    <p>Presentamos a continuación una lista con algunos de estos problemas que puede encontrar el desarrollador, junto a las posibles soluciones:</p>
                                    <ul>
                                        <li>
                                            <p>Problema: El mapa se queda en blanco. La consola de error muestra el mensaje &#39;<em>Promise is not defined</em> &#39;.<br>Solución: El navegador <a href="https://kangax.github.io/compat-table/es6/">no es compatible</a> con la versión de javascript <a href="https://en.wikipedia.org/wiki/ECMAScript">ES2015</a>, se necesita importar la librería: </p>
                                            <pre class="hljs"> &lt;script type=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"https://URL_MAPEA_CNIG.es/vendor/browser-polyfill.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></pre>
                                        </li>
                                        <li>
                                            <p>Problema: al usar mapea junto con JQuery Mobile, se cambian los estilos de algunos controles.<br>Solución: modificar la plantilla html del control y añadirle la etiqueta <em>data-role=&quot;none&quot;</em>, quedando así:</p>
                                            <pre class="hljs"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"m-wmcselector-select"</span> <span class="hljs-attr">data-role</span>=<span class="hljs-string">"none"</span>&gt;</span></pre>
                                        </li>
                                    </ul>

            </div> <!-- /div.col-md-9 -->
        </div> <!-- /div.row -->
    </div> <!-- /div.container -->
</body>
<script>
    $('body').scrollspy({
        target: '#scroll-spy',
        offset: 40
    })
</script>

</html>