<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="mapea" content="yes">
    <meta name="title" content="Visualizador cálculo de distancias de 1km" />
    <meta name="description" content="Visualizador publicado por el IGN que muestra el área en un radio de 1km a partir de la ubicación de un dispositivo móvil o de una dirección postal">
    <meta property="og:image" content="https://www.ign.es/resources/viewer/images/IGN1KmCuad.jpg">
    <meta property="og:image:width" content="173">
    <meta property="og:image:height" content="173">
    <meta name="lang" content="es" />
    <meta name="author" content="Instituto Geográfico Nacional" />
    <meta name="keywords" content="IGN, CNIG, covid19, menores, niños, paseos, localización, kilómetro" />
    <meta name="date" scheme="W3CDTF" content="2020-04-25T09:00:00+02:00" />
    <meta name="organization" content="Instituto Geográfico Nacional" />
    <meta property="article:section" content="eps" />
    <meta property="article:tag" content="covid19" />
    <meta property="article:tag" content="menores" />
    <title>IGN Distancias 1km</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-164574488-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-164574488-1');
    </script>

    <link type="text/css" rel="stylesheet" href="https://componentes.ign.es/api-core/assets/css/apiign-1.0.0.ol.min.css">
    <link type="text/css" rel="stylesheet" href="https://componentes.ign.es/api-core/plugins/ignsearch/ignsearch.ol.min.css">
    <link type="text/css" rel="stylesheet" href="https://componentes.ign.es/api-core/plugins/backimglayer/backimglayer.ol.min.css">
    <link type="text/css" rel="stylesheet" href="https://componentes.ign.es/api-core/plugins/overviewmap/overviewmap.ol.min.css" rel="stylesheet" />
    <link type="text/css" rel="stylesheet" href="https://componentes.ign.es/api-core/plugins/measurebar/measurebar.ol.min.css" rel="stylesheet" />


    <style type="text/css">
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: auto;
        }

        #m-ignsearch-results {
            position: initial !important;
        }
    </style>
</head>

<body>
    <div id="mapjs" class="m-container"></div>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/vendor/browser-polyfill.js"></script>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/js/apiign-1.0.0.ol.min.js"></script>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/js/configuration-1.0.0.js"></script>
    <script type="text/javascript" src="https://www.ign.es/resources/viewer/js/ignsearch.ol.min_cache_geocoder.js"></script>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/plugins/backimglayer/backimglayer.ol.min.js"></script>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/plugins/overviewmap/overviewmap.ol.min.js"></script>
    <script type="text/javascript" src="https://componentes.ign.es/api-core/plugins/measurebar/measurebar.ol.min.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-163701543-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-163701543-1');
    </script>


    <script type="text/javascript">
        const map = M.map({
            container: 'mapjs',
            controls: ['location', 'scale', 'rotate'],
            zoom: 5,
            maxZoom: 20,
            minZoom: 4,
            center: [-467062.8225, 4683459.6216],
        });
    </script>

    <script type="text/javascript">
        const capa1 = new M.layer.WMTS({
            url: 'https://www.ign.es/wmts/pnoa-ma?',
            name: 'OI.OrthoimageCoverage',
            legend: 'Imagen (PNOA)',
            matrixSet: 'GoogleMapsCompatible',
            transparent: true,
            displayInLayerSwitcher: false,
            queryable: false,
            visible: true,
            format: 'image/jpeg',
        });

        find = (arr, func) => {
            const length = arr.length >>> 0;
            let value;

            for (let i = 0; i < length; i++) {
                value = arr[i];
                if (func(value, i, arr)) {
                    return value;
                }
            }
            return null;
        }

        findIndex = (arr, func) => {
            let index;
            const found = !arr.every(function(el, idx) {
                index = idx;
                return !func(el, idx, arr);
            });
            return found ? index : -1;
        }

        includes = (arr, obj) => {
            return arr.indexOf(obj) >= 0;
        }

        capa1.getImpl().getCapabilitiesOptions_ = function() {
            alert("a");
            if (M.utils.isNullOrEmpty(this.capabilitiesOptionsPromise)) {
                this.capabilitiesOptionsPromise = this.getCapabilities().then((capabilities) => {
                    const layerName = this.name;
                    let matrixSet = this.matrixSet;
                    if (M.utils.isNullOrEmpty(matrixSet)) {

                        matrixSet = this.map.getProjection().code;
                    }
                    const extent = this.facadeLayer_.getMaxExtent();
                    const capabilitiesOpts = optionsFromCapabilitiesWMTS(capabilities, {
                        layer: layerName,
                        matrixSet,
                        extent,
                    });
                    capabilitiesOpts.tileGrid.extent = extent;
                    return capabilitiesOpts;
                });
            }
            return this.capabilitiesOptionsPromise;
        }


        optionsFromCapabilitiesWMTS = (wmtsCap, config) => {
            alert("B");
            const layers = wmtsCap['Contents']['Layer'];
            const l = find(layers, function(elt, index, array) {
                return elt['Identifier'] == config['layer'];
            });
            if (l === null) {
                return null;
            }
            const tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
            let idx;
            if (l['TileMatrixSetLink'].length > 1) {
                if ('projection' in config) {
                    idx = findIndex(l['TileMatrixSetLink'],
                        function(elt, index, array) {
                            const tileMatrixSet = find(tileMatrixSets, function(el) {
                                return el['Identifier'] == elt['TileMatrixSet'];
                            });
                            const supportedCRS = tileMatrixSet['SupportedCRS'];
                            const proj1 = ol.proj.get(supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) ||
                                ol.proj.getProjection(supportedCRS);
                            const proj2 = ol.proj.get(config['projection']);
                            if (proj1 && proj2) {
                                return equivalent(proj1, proj2);
                            } else {
                                return supportedCRS == config['projection'];
                            }
                        });
                } else {
                    idx = findIndex(l['TileMatrixSetLink'],
                        function(elt, index, array) {
                            return elt['TileMatrixSet'] == config['matrixSet'];
                        });
                }
            } else {
                idx = 0;
            }
            if (idx < 0) {
                idx = 0;
            }
            const matrixSet = (l['TileMatrixSetLink'][idx]['TileMatrixSet']);
            const matrixLimits = (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);
            let format = (l['Format'][0]);
            if ('format' in config) {
                format = config['format'];
            }
            idx = findIndex(l['Style'], function(elt, index, array) {
                if ('style' in config) {
                    return elt['Title'] == config['style'];
                } else {
                    return elt['isDefault'];
                }
            });
            if (idx < 0) {
                idx = 0;
            }
            const style = (l['Style'][idx]['Identifier']);
            const dimensions = {};
            if ('Dimension' in l) {
                l['Dimension'].forEach(function(elt, index, array) {
                    const key = elt['Identifier'];
                    let value = elt['Default'];
                    if (value === undefined) {
                        value = elt['Value'][0];
                    }
                    dimensions[key] = value;
                });
            }
            const matrixSets = wmtsCap['Contents']['TileMatrixSet'];
            const matrixSetObj = find(matrixSets, function(elt, index, array) {
                return elt['Identifier'] == matrixSet;
            });
            let projection;
            const code = matrixSetObj['SupportedCRS'];
            if (code) {
                projection = ol.proj.get(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || ol.proj.get(code);
            }
            if ('projection' in config) {
                const projConfig = ol.proj.get(config['projection']);
                if (projConfig) {
                    if (!projection || equivalent(projConfig, projection)) {
                        projection = projConfig;
                    }
                }
            }
            const wgs84BoundingBox = l['WGS84BoundingBox'];
            let extent, wrapX;
            if (config.extent) {
                extent = config.extent;
            } else if (wgs84BoundingBox !== undefined) {
                const wgs84ProjectionExtent = ol.proj.get('EPSG:4326').getExtent();
                wrapX = (wgs84BoundingBox[0] == wgs84ProjectionExtent[0] && wgs84BoundingBox[2] == wgs84ProjectionExtent[2]);
                extent = transformExtent(wgs84BoundingBox, 'EPSG:4326', projection);
                const projectionExtent = projection.getExtent();
                if (projectionExtent) {
                    if (!containsExtent(projectionExtent, extent)) {
                        extent = undefined;
                    }
                }
            }
            const tileGrid = ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
            const urls = [];
            let requestEncoding = config['requestEncoding'];
            requestEncoding = requestEncoding !== undefined ? requestEncoding : '';
            if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
                const gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];
                for (let i = 0, ii = gets.length; i < ii; ++i) {
                    if (gets[i]['Constraint']) {
                        const constraint = find(gets[i]['Constraint'], function(element) {
                            return element['name'] == 'GetEncoding';
                        });
                        const encodings = constraint['AllowedValues']['Value'];
                        if (requestEncoding === '') {
                            requestEncoding = encodings[0];
                        }
                        if (requestEncoding === 'KVP') {
                            if (includes(encodings, 'KVP')) {
                                urls.push((gets[i]['href']).replace("http", "https"));
                            }
                        } else {
                            break;
                        }
                    } else if (gets[i]['href']) {
                        requestEncoding = 'KVP';
                        urls.push((gets[i]['href']).replace("http", "https"));
                    }
                }
            }
            if (urls.length === 0) {
                requestEncoding = 'REST';
                l['ResourceURL'].forEach(function(element) {
                    if (element['resourceType'] === 'tile') {
                        format = element['format'];
                        urls.push((element['template']));
                    }
                });
            }
            return {
                urls: urls,
                layer: config['layer'],
                matrixSet: matrixSet,
                format: format,
                projection: projection,
                requestEncoding: requestEncoding,
                tileGrid: tileGrid,
                style: style,
                dimensions: dimensions,
                wrapX: wrapX,
                crossOrigin: config['crossOrigin']
            };
        }

        map.addLayers(capa1)
    </script>
</body>

</html>