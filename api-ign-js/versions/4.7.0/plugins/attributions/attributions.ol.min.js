!function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=4)}([function(t){t.exports=JSON.parse('{"exception":{"impl":"The implementation used cannot create Attributions controls.","mode":"Options mode is bad setted. Tip: {mode: 1 | 2 | 3}.","type":"Missing \'type\' options. When \'url\' option is setted the plugin needs \'type\' option. Values = geojson | kml | topojson.","layer_name":"Missing \'layerName\' options. When \'url\' option is setted the plugin needs \'layerName\' option."},"attribution":"attribution","tooltip":"Acknowledgments"}')},function(t){t.exports=JSON.parse('{"exception":{"impl":"La implementación no puede crear controles de Attribution.","mode":"La opción \'mode\' no ha sido establecida correctamente. Consejo: {mode: 1 | 2 | 3}.","type":"La opción \'type\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'type\'. Valores = geojson | kml | topojson.","layer_name":"La opción \'layerName\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'layerName\'."},"attribution":"atribución","tooltip":"Reconocimientos"}')},function(t,e){t.exports='<div id="m-attributions-container" class="m-control m-container m-attributions">\n    <button id=\'close-button\' class="{{icon}}"></button>\n</div>'},function(t,e,n){},function(t,e,n){"use strict";n.r(e);n(3);function i(t){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function s(t,e){for(var n=0;n<e.length;n++){var s=e[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,(r=s.key,o=void 0,o=function(t,e){if("object"!==i(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var s=n.call(t,e||"default");if("object"!==i(s))return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(r,"string"),"symbol"===i(o)?o:String(o)),s)}var r,o}function r(t,e){return(r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function o(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=a(t);if(e){var s=a(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return l(this,n)}}function l(t,e){if(e&&("object"===i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function a(t){return(a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var c=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&r(t,e)}(a,M.Object);var e,n,i,l=o(a);function a(t){var e;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),(e=l.call(this)).map_=t,e}return e=a,(n=[{key:"registerEvent",value:function(t,e){this.map_.getMapImpl().on(t,e)}}])&&s(e.prototype,n),i&&s(e,i),Object.defineProperty(e,"prototype",{writable:!1}),a}();function h(t){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function g(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==h(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==h(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===h(r)?r:String(r)),i)}var s,r}function f(){return(f="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var i=d(t,e);if(i){var s=Object.getOwnPropertyDescriptor(i,e);return s.get?s.get.call(arguments.length<3?t:n):s.value}}).apply(this,arguments)}function d(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=m(t)););return t}function p(t,e){return(p=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function _(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=m(t);if(e){var s=m(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return y(this,n)}}function y(t,e){if(e&&("object"===h(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function m(t){return(m=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var E=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&p(t,e)}(r,M.impl.Control);var e,n,i,s=_(r);function r(){return u(this,r),s.apply(this,arguments)}return e=r,(n=[{key:"addTo",value:function(t,e){var n=this;t.getMapImpl().getInteractions().forEach((function(t){t instanceof ol.interaction.DoubleClickZoom&&(n.dblClickInteraction_=t)})),f(m(r.prototype),"addTo",this).call(this,t,e)}},{key:"destroy",value:function(){this.facadeMap_.getMapImpl().removeControl(this),this.facadeMap_=null}}])&&g(e.prototype,n),i&&g(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}(),I=n(2),x=n.n(I),N=n(0),T=n(1),R={en:N,es:T},O=function(){var t="es";return"function"==typeof M.language.getLang&&(t=M.language.getLang()),t},w=function(t){return"es"===t||"en"===t?R[t]:M.language.getTranslation(t).attributions},L=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O(),n=w(e),i="";return M.utils.isNullOrEmpty(n)?console.warn("The translation '".concat(e,"' has not been defined.")):i=t.split(".").reduce((function(t,e){return t[e]}),n),i};function b(t){return(b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function v(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==b(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==b(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===b(r)?r:String(r)),i)}var s,r}function C(t,e){return(C=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function S(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=A(t);if(e){var s=A(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return P(this,n)}}function P(t,e){if(e&&("object"===b(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function A(t){return(A=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var D=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&C(t,e)}(r,M.Control);var e,n,i,s=S(r);function r(t,e){var n;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,r),M.utils.isUndefined(E)&&M.exception(L("exception.impl"));var i=new E;return(n=s.call(this,i,"Attributions")).position=t,n.closePanel=e,n}return e=r,(n=[{key:"createView",value:function(t){var e=this;return this.map=t,new Promise((function(t,n){var i=M.template.compileSync(x.a,{vars:{icon:"BR"===e.position||"TR"===e.position?"g-cartografia-flecha-derecha":"g-cartografia-flecha-izquierda"}});i.querySelector("#close-button").addEventListener("click",(function(){return e.closePanel()})),e.html_=i,t(i)}))}},{key:"equals",value:function(t){return t instanceof r}},{key:"destroy",value:function(){this.getImpl().destroy()}}])&&v(e.prototype,n),i&&v(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}(),F=function(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1};class Y{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class G extends Error{constructor(t){super(t),this.name=Object.keys({Exception:G})[0]}toString(){return this.message}}class q extends G{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:q})[0]}}class B{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function U(){}function X(){}function z(){}U.NaN=NaN,U.isNaN=t=>Number.isNaN(t),U.isInfinite=t=>!Number.isFinite(t),U.MAX_VALUE=Number.MAX_VALUE,U.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,U.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);U.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],s=0|e[1];return 2146435072==(2146435072&s)&&0!=(1048575&s)&&0!==i&&(i=0,s=2146959360),new B(s,i)},U.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,i=function(){for(let i=53;i>0;i--){const s=n(2,i)-1;if(e(t(s))+1===i)return s}return 0}();U.doubleToLongBits=function(s){let r,o,l,a,c,h,u,g,f;if(s<0||1/s===Number.NEGATIVE_INFINITY?(h=1<<31,s=-s):h=0,0===s)return f=0,g=h,new B(g,f);if(s===1/0)return f=0,g=2146435072|h,new B(g,f);if(s!=s)return f=0,g=2146959360,new B(g,f);if(a=0,f=0,r=e(s),r>1)if(r<=i)a=e(t(r)),a<=20?(f=0,g=r<<20-a&1048575):(l=a-20,o=n(2,l),f=r%o<<32-l,g=r/o&1048575);else for(l=r,f=0;o=l/2,l=e(o),0!==l;)a++,f>>>=1,f|=(1&g)<<31,g>>>=1,o!==l&&(g|=524288);if(u=a+1023,c=0===r,r=s-r,a<52&&0!==r)for(l=0;;){if(o=2*r,o>=1?(r=o-1,c?(u--,c=!1):(l<<=1,l|=1,a++)):(r=o,c?0==--u&&(a++,c=!1):(l<<=1,a++)),20===a)g|=l,l=0;else if(52===a){f|=l;break}if(1===o){a<20?g|=l<<20-a:a<52&&(f|=l<<52-a);break}}return g|=u<<20,g|=h,new B(g,f)},U.longBitsToDouble=function(t){let e,i,s,r;const o=t.high,l=t.low,a=o&1<<31?-1:1;for(s=((2146435072&o)>>20)-1023,r=0,i=1<<19,e=1;e<=20;e++)o&i&&(r+=n(2,-e)),i>>>=1;for(i=1<<31,e=21;e<=52;e++)l&i&&(r+=n(2,-e)),i>>>=1;if(-1023===s){if(0===r)return 0*a;s=-1022}else{if(1024===s)return 0===r?a/0:NaN;r+=1}return a*r*n(2,s)}}();class k extends G{constructor(t){super(t),this.name=Object.keys({RuntimeException:k})[0]}}class j extends k{constructor(){super(),j.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)k.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];k.constructor_.call(this,t)}}}class V{static isTrue(){if(1===arguments.length){const t=arguments[0];V.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new j:new j(t)}}static shouldNeverReachHere(){if(0===arguments.length)V.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new j("Should never reach here"+(null!==t?": "+t:""))}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];V.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new j("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}function Z(){}function W(){}const H=new ArrayBuffer(8),K=new Float64Array(H),J=new Int32Array(H);class Q{constructor(){Q.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)Q.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];Q.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Q.constructor_.call(this,t,e,Q.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return K[0]=t,J[0]^J[1]}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],e=arguments[1];return!!Y.equalsWithTolerance(this.x,t.x,e)&&!!Y.equalsWithTolerance(this.y,t.y,e)}}setM(t){throw new q("Invalid ordinate index: "+Q.M)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||U.isNaN(this.getZ())&&U.isNaN(t.getZ()))}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}copy(){return new Q(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,i=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+i*i)}getY(){return this.y}getM(){return U.NaN}setOrdinate(t,e){switch(t){case Q.X:this.x=e;break;case Q.Y:this.y=e;break;case Q.Z:this.setZ(e);break;default:throw new q("Invalid ordinate index: "+t)}}getZ(){return this.z}getOrdinate(t){switch(t){case Q.X:return this.x;case Q.Y:return this.y;case Q.Z:return this.getZ()}throw new q("Invalid ordinate index: "+t)}equals(t){return t instanceof Q&&this.equals2D(t)}equalInZ(t,e){return Y.equalsWithTolerance(this.getZ(),t.getZ(),e)}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return V.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+Q.hashCode(this.x),t=37*t+Q.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[X,Z,z]}}class ${constructor(){$.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)$.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new q("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:U.isNaN(t)?U.isNaN(e)?0:-1:U.isNaN(e)?1:0}compare(t,e){const n=$.compare(t.x,e.x);if(0!==n)return n;const i=$.compare(t.y,e.y);if(0!==i)return i;if(this._dimensionsToTest<=2)return 0;return $.compare(t.getZ(),e.getZ())}get interfaces_(){return[W]}}Q.DimensionalComparator=$,Q.NULL_ORDINATE=U.NaN,Q.X=0,Q.Y=1,Q.Z=2,Q.M=3;class tt{filter(t){}}class et extends G{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:et})[0]}}class nt{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class it extends G{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:it})[0]}}class st extends nt{get(){}set(){}isEmpty(){}}class rt extends G{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:rt})[0]}}class ot extends st{constructor(t){super(),this.array=[],t instanceof nt&&this.addAll(t)}get interfaces_(){return[st,nt]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new lt(this)}get(t){if(t<0||t>=this.size())throw new it;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort((e,n)=>t.compare(e,n)):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class lt{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new rt;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class at extends ot{constructor(){super(),at.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&F(arguments[0],nt)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}toCoordinateArray(){if(0===arguments.length)return this.toArray(at.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(at.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof Q&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof Q){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=1;n>i&&(s=-1);for(let r=n;r!==i;r+=s)this.add(t[r],e);return!0}}}at.coordArrayType=new Array(0).fill(null);class ct extends Q{constructor(){super(),ct.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)Q.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof ct){const t=arguments[0];Q.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof Q){const t=arguments[0];Q.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Q.constructor_.call(this,t,e,Q.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case ct.X:this.x=e;break;case ct.Y:this.y=e;break;default:throw new q("Invalid ordinate index: "+t)}}setZ(t){throw new q("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new ct(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}getZ(){return Q.NULL_ORDINATE}getOrdinate(t){switch(t){case ct.X:return this.x;case ct.Y:return this.y}throw new q("Invalid ordinate index: "+t)}}ct.X=0,ct.Y=1,ct.Z=-1,ct.M=-1;class ht extends Q{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)Q.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof ht){const t=arguments[0];Q.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof Q){const t=arguments[0];Q.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Q.constructor_.call(this,t,e,Q.NULL_ORDINATE),this._m=n}}setM(t){this._m=t}setZ(t){throw new q("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new ht(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case ht.X:this.x=e;break;case ht.Y:this.y=e;break;case ht.M:this._m=e;break;default:throw new q("Invalid ordinate index: "+t)}}getZ(){return Q.NULL_ORDINATE}getOrdinate(t){switch(t){case ht.X:return this.x;case ht.Y:return this.y;case ht.M:return this._m}throw new q("Invalid ordinate index: "+t)}}ht.X=0,ht.Y=1,ht.Z=-1,ht.M=2;class ut extends Q{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)Q.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof ut){const t=arguments[0];Q.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof Q){const t=arguments[0];Q.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Q.constructor_.call(this,t,e,n),this._m=i}}setM(t){this._m=t}getOrdinate(t){switch(t){case Q.X:return this.x;case Q.Y:return this.y;case Q.Z:return this.getZ();case Q.M:return this.getM()}throw new q("Invalid ordinate index: "+t)}copy(){return new ut(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case Q.X:this.x=e;break;case Q.Y:this.y=e;break;case Q.Z:this.z=e;break;case Q.M:this._m=e;break;default:throw new q("Invalid ordinate index: "+t)}}}class gt{static measures(t){return t instanceof ct?0:t instanceof ht||t instanceof ut?1:0}static create(){if(1===arguments.length){const t=arguments[0];return gt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new ct:3===t&&0===e?new Q:3===t&&1===e?new ht:4===t&&1===e?new ut:new Q}}static dimension(t){return t instanceof ct?2:t instanceof ht?3:t instanceof ut?4:3}}class ft{static log10(t){const e=Math.log(t);return U.isInfinite(e)||U.isNaN(e)?e:e/ft.LOG_10}static min(t,e,n,i){let s=t;return e<s&&(s=e),n<s&&(s=n),i<s&&(s=i),s}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static average(t,e){return(t+e)/2}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let i=arguments[0];return t>i&&(i=t),e>i&&(i=e),n>i&&(i=n),i}}}ft.LOG_10=Math.log(10);class dt{static arraycopy(t,e,n,i,s){let r=0;for(let o=e;o<e+s;o++)n[i+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class pt{constructor(){pt.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof Q){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof pt){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.init(t,e,n,i)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=Math.min(n.x,i.x),r=Math.max(n.x,i.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<s)&&(s=Math.min(n.y,i.y),r=Math.max(n.y,i.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<s)))}}getArea(){return this.getWidth()*this.getHeight()}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof Q){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof pt){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new pt(this)}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof pt){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof Q){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}hashCode(){let t=17;return t=37*t+Q.hashCode(this._minx),t=37*t+Q.hashCode(this._maxx),t=37*t+Q.hashCode(this._miny),t=37*t+Q.hashCode(this._maxy),t}equals(t){if(!(t instanceof pt))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new pt;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,s=this._maxy<t._maxy?this._maxy:t._maxy;return new pt(e,i,n,s)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof Q){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof pt){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof pt){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof Q){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof Q&&arguments[1]instanceof Q){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}centre(){return this.isNull()?null:new Q((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof Q){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof pt){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<i?(this._miny=n,this._maxy=i):(this._miny=i,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}get interfaces_(){return[X,z]}}class _t{static scroll(t,e){const n=_t.indexOf(e,t);if(n<0)return null;const i=new Array(t.length).fill(null);dt.arraycopy(t,n,i,0,t.length-n),dt.arraycopy(t,0,i,t.length-n,n),dt.arraycopy(i,0,t,0,t.length)}static removeRepeatedPoints(t){if(!_t.hasRepeatedPoints(t))return t;return new at(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++){const n=t[i];t[i]=t[e-i],t[e-i]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let i=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[i++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4];for(let r=0;r<s;r++)n[i+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const i=t[n],s=e[t.length-n-1];if(0!==i.compareTo(s))return!1}return!0}static envelope(t){const e=new pt;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static extract(t,e,n){e=ft.clamp(e,0,t.length);let i=(n=ft.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);const s=new Array(i).fill(null);if(0===i)return s;let r=0;for(let i=e;i<=n;i++)s[r++]=t[i];return s}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(_t.indexOf(i,e)<0)return i}return null}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(0!==n.compare(t[i],e[i]))return!1;return!0}}static intersection(t,e){const n=new at;for(let i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,gt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static toCoordinateArray(t){return t.toArray(_t.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,gt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}}_t.ForwardComparator=class{compare(t,e){const n=t,i=e;return _t.compare(n,i)}get interfaces_(){return[W]}},_t.BidirectionalComparator=class{compare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=_t.compare(n,i);return _t.isEqualReversed(n,i)?0:s}OLDcompare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=_t.increasingDirection(n),r=_t.increasingDirection(i);let o=s>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(i[l]);if(0!==t)return t;o+=s,l+=r}return 0}get interfaces_(){return[W]}},_t.coordArrayType=new Array(0).fill(null);class yt{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class mt{static toDimensionSymbol(t){switch(t){case mt.FALSE:return mt.SYM_FALSE;case mt.TRUE:return mt.SYM_TRUE;case mt.DONTCARE:return mt.SYM_DONTCARE;case mt.P:return mt.SYM_P;case mt.L:return mt.SYM_L;case mt.A:return mt.SYM_A}throw new q("Unknown dimension value: "+t)}static toDimensionValue(t){switch(yt.toUpperCase(t)){case mt.SYM_FALSE:return mt.FALSE;case mt.SYM_TRUE:return mt.TRUE;case mt.SYM_DONTCARE:return mt.DONTCARE;case mt.SYM_P:return mt.P;case mt.SYM_L:return mt.L;case mt.SYM_A:return mt.A}throw new q("Unknown dimension symbol: "+t)}}mt.P=0,mt.L=1,mt.A=2,mt.FALSE=-1,mt.TRUE=-2,mt.DONTCARE=-3,mt.SYM_FALSE="F",mt.SYM_TRUE="T",mt.SYM_DONTCARE="*",mt.SYM_P="0",mt.SYM_L="1",mt.SYM_A="2";class Et{constructor(){Et.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===Et.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(Et.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===Et.TYPECODE_GEOMETRYCOLLECTION)throw new q("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new pt(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),i=e.iterator();for(;n.hasNext()&&i.hasNext();){const t=n.next(),e=i.next(),s=t.compareTo(e);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[Z,X,z]}getClass(){return Et}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}Et.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},Et.TYPECODE_POINT=0,Et.TYPECODE_MULTIPOINT=1,Et.TYPECODE_LINESTRING=2,Et.TYPECODE_LINEARRING=3,Et.TYPECODE_MULTILINESTRING=4,Et.TYPECODE_POLYGON=5,Et.TYPECODE_MULTIPOLYGON=6,Et.TYPECODE_GEOMETRYCOLLECTION=7,Et.TYPENAME_POINT="Point",Et.TYPENAME_MULTIPOINT="MultiPoint",Et.TYPENAME_LINESTRING="LineString",Et.TYPENAME_LINEARRING="LinearRing",Et.TYPENAME_MULTILINESTRING="MultiLineString",Et.TYPENAME_POLYGON="Polygon",Et.TYPENAME_MULTIPOLYGON="MultiPolygon",Et.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",Et.geometryChangedFilter={get interfaces_(){return[tt]},filter(t){t.geometryChangedAction()}};class It{filter(t){}}class xt{}class Nt{getCoordinate(){if(1===arguments.length){}else if(2===arguments.length){}}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return U.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):U.NaN}size(){}getOrdinate(t,e){}get interfaces_(){return[Z]}}Nt.X=0,Nt.Y=1,Nt.Z=2,Nt.M=3;class Tt{static scroll(){if(2===arguments.length){if(F(arguments[0],Nt)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Tt.scroll(t,e,Tt.isRing(t))}else if(F(arguments[0],Nt)&&arguments[1]instanceof Q){const t=arguments[0],e=arguments[1],n=Tt.indexOf(e,t);if(n<=0)return null;Tt.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const i=t.copy(),s=n?t.size()-1:t.size();for(let n=0;n<s;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,i.getOrdinate((e+n)%s,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(s,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const i=Math.min(t.getDimension(),e.getDimension());for(let s=0;s<n;s++)for(let n=0;n<i;n++){const i=t.getOrdinate(s,n),r=e.getOrdinate(s,n);if(t.getOrdinate(s,n)!==e.getOrdinate(s,n)&&(!U.isNaN(i)||!U.isNaN(r)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return Tt.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,i=null;for(let s=arguments[1];s<=e;s++){const e=t.getCoordinate(s);(null===i||i.compareTo(e)>0)&&(i=e,n=s)}return n}}static extend(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();if(Tt.copy(e,0,i,0,s),s>0)for(let t=s;t<n;t++)Tt.copy(e,s-1,i,t,1);return i}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++)Tt.swap(t,i,e-i)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return Tt.createClosedRing(t,e,4);return e.getOrdinate(0,Nt.X)===e.getOrdinate(n-1,Nt.X)&&e.getOrdinate(0,Nt.Y)===e.getOrdinate(n-1,Nt.Y)?e:Tt.createClosedRing(t,e,n+1)}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const i=t.getCoordinate(n);(null===e||e.compareTo(i)>0)&&(e=i)}return e}static copyCoord(t,e,n,i){const s=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<s;r++)n.setOrdinate(i,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,Nt.X)===t.getOrdinate(e-1,Nt.X)&&t.getOrdinate(0,Nt.Y)===t.getOrdinate(e-1,Nt.Y))}static swap(t,e,n){if(e===n)return null;for(let i=0;i<t.getDimension();i++){const s=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,s)}}static copy(t,e,n,i,s){for(let r=0;r<s;r++)Tt.copyCoord(t,e+r,n,i+r)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,Nt.X)&&t.y===e.getOrdinate(n,Nt.Y))return n;return-1}static createClosedRing(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();Tt.copy(e,0,i,0,s);for(let t=s;t<n;t++)Tt.copy(e,0,i,t,1);return i}}class Rt{filter(t){}}class Ot{filter(t,e){}isGeometryChanged(){}isDone(){}}class wt extends Et{constructor(){super(),wt.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];Et.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new pt:this._points.expandEnvelope(new pt)}isRing(){return this.isClosed()&&_t.isRing(this.getCoordinates())}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new wt(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return Tt.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return Et.TYPECODE_LINESTRING}getDimension(){return 1}getBoundary(){throw new et}isEquivalentClass(t){return t instanceof wt}getCoordinateSequence(){return this._points}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Tt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?mt.FALSE:0}getLength(){return class{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const i=new Q;t.getCoordinate(0,i);let s=i.x,r=i.y;for(let o=1;o<e;o++){t.getCoordinate(o,i);const e=i.x,l=i.y,a=e-s,c=l-r;n+=Math.sqrt(a*a+c*c),s=e,r=l}return n}}.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(F(arguments[0],It)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(F(arguments[0],Ot)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],Rt)){arguments[0].filter(this)}else if(F(arguments[0],tt)){arguments[0].filter(this)}}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return Et.TYPENAME_LINESTRING}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new q("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}get interfaces_(){return[xt]}}class Lt extends wt{constructor(){super(),Lt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];wt.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new Lt(this._points.copy(),this._factory)}getBoundaryDimension(){return mt.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return Tt.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return Et.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new q("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Lt.MINIMUM_VALID_SIZE)throw new q("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return Et.TYPENAME_LINEARRING}}Lt.MINIMUM_VALID_SIZE=4;class bt{create(){if(1===arguments.length){if(arguments[0]instanceof Array){}else if(F(arguments[0],Nt)){}}else if(2===arguments.length){}else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class vt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];Ct.constructor_.call(this,t,_t.dimension(t),_t.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new Q}else if(F(arguments[0],Nt)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Ct.constructor_.call(this,t,e,_t.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=gt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return gt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new Ct(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new vt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getM(t){return this.hasM()?this._coordinates[t].getM():U.NaN}setOrdinate(t,e,n){switch(e){case Nt.X:this._coordinates[t].x=n;break;case Nt.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():U.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case Nt.X:return this._coordinates[t].x;case Nt.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}get interfaces_(){return[Nt,z]}}class St{static instance(){return St.instanceObject}readResolve(){return St.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new Ct(arguments[0])}if(F(arguments[0],Nt)){return new Ct(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new Ct(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new Ct(arguments[0],e+t,t)}}}get interfaces_(){return[bt,z]}}St.instanceObject=new St;class Pt extends nt{contains(){}}class Mt extends Pt{}class At extends Mt{constructor(t){super(),this.array=[],t instanceof nt&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new et}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new Dt(this.array)}}class Dt{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new rt;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new et}}class Ft{static sort(){const t=arguments[0];if(1===arguments.length)t.sort((t,e)=>t.compareTo(e));else if(2===arguments.length)t.sort((t,e)=>arguments[1].compare(t,e));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort((t,e)=>arguments[3].compare(t,e));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new ot;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class Yt extends Et{constructor(){super(),Yt.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(Et.constructor_.call(this,e),null===t&&(t=[]),Et.hasNullElements(t))throw new q("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new pt;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const i=this._geometries[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Yt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this._geometries.length,e=new ot(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return Et.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=mt.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getNumGeometries(){return this._geometries.length}getBoundary(){return Et.checkNotGeometryCollection(this),V.shouldNeverReachHere(),null}getGeometryType(){return Et.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();Ft.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=mt.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new At(Ft.asList(this._geometries)),n=new At(Ft.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),i=e.getNumGeometries();let s=0;for(;s<n&&s<i;){const n=this.getGeometryN(s),i=e.getGeometryN(s),r=n.compareToSameClass(i,t);if(0!==r)return r;s++}return s<n?1:s<i?-1:0}}apply(){if(F(arguments[0],It)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(F(arguments[0],Ot)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],Rt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(F(arguments[0],tt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}}class Gt{}class qt extends Yt{constructor(){super(),qt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Yt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new qt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return Et.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new ot;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return Et.TYPENAME_MULTIPOLYGON}get interfaces_(){return[Gt]}}class Bt{get(){}put(){}size(){}values(){}entrySet(){}}class Ut extends Pt{constructor(t){super(),this.map=new Map,t instanceof nt&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new et}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new Xt(this.map)}[Symbol.iterator](){return this.map}}class Xt{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new rt;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new et}}class zt extends Bt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new ot,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new Ut;return this.map.entries().forEach(e=>t.add(e)),t}size(){return this.map.size()}}class kt{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new kt(t)}}class jt{constructor(){jt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=jt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Vt){const t=arguments[0];this._modelType=t,t===jt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=jt.FIXED,this.setScale(t)}else if(arguments[0]instanceof jt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof jt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return kt.compare(n,i)}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===jt.FLOATING?t="Floating":this._modelType===jt.FLOATING_SINGLE?t="Floating-Single":this._modelType===jt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(U.isNaN(t))return t;if(this._modelType===jt.FLOATING_SINGLE){return t}return this._modelType===jt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof Q){const t=arguments[0];if(this._modelType===jt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===jt.FLOATING?t=16:this._modelType===jt.FLOATING_SINGLE?t=6:this._modelType===jt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getScale(){return this._scale}isFloating(){return this._modelType===jt.FLOATING||this._modelType===jt.FLOATING_SINGLE}get interfaces_(){return[z,X]}}class Vt{constructor(){Vt.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,Vt.nameToTypeMap.put(t,this)}readResolve(){return Vt.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[z]}}Vt.nameToTypeMap=new zt,jt.Type=Vt,jt.FIXED=new Vt("FIXED"),jt.FLOATING=new Vt("FLOATING"),jt.FLOATING_SINGLE=new Vt("FLOATING SINGLE"),jt.maximumPreciseValue=9007199254740992;class Zt extends Yt{constructor(){super(),Zt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Yt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Zt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?mt.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return Et.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new et}getGeometryType(){return Et.TYPENAME_MULTILINESTRING}get interfaces_(){return[xt]}}class Wt{}class Ht extends G{constructor(t){super(t),this.name=Object.keys({IllegalStateException:Ht})[0]}}class Kt extends Et{constructor(){super(),Kt.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];Et.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new pt;const t=new pt;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new Kt(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return Et.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new Ht("getX called on empty Point");return this.getCoordinate().x}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return Et.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new Ht("getY called on empty Point");return this.getCoordinate().y}isSimple(){return!0}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return mt.FALSE}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(F(arguments[0],It)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(F(arguments[0],Ot)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],Rt)){arguments[0].filter(this)}else if(F(arguments[0],tt)){arguments[0].filter(this)}}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),V.isTrue(t.size()<=1),this._coordinates=t}get interfaces_(){return[Wt]}}class Jt{static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let i=1;i<t.length-1;i++){const s=t[i].x-n,r=t[i+1].y;e+=s*(t[i-1].y-r)}return e/2}if(F(arguments[0],Nt)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new Q,i=new Q,s=new Q;t.getCoordinate(0,i),t.getCoordinate(1,s);const r=i.x;s.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=i.y,i.x=s.x,i.y=s.y,t.getCoordinate(l+1,s),s.x-=r,o+=i.x*(n.y-s.y);return o/2}}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(Jt.ofRingSigned(t))}if(F(arguments[0],Nt)){const t=arguments[0];return Math.abs(Jt.ofRingSigned(t))}}}class Qt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class $t{constructor(){$t.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof $t){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];$t.constructor_.call(this,$t.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];return $t.determinant($t.valueOf(t),$t.valueOf(e),$t.valueOf(n),$t.valueOf(i))}if(arguments[3]instanceof $t&&arguments[2]instanceof $t&&arguments[0]instanceof $t&&arguments[1]instanceof $t){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return $t.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return $t.parse(t)}if("number"==typeof arguments[0]){return new $t(arguments[0])}}static sqrt(t){return $t.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;yt.isWhitespace(t.charAt(e));)e++;let i=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(i=!0))}const s=new $t;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,yt.isDigit(n)){const t=n-"0";s.selfMultiply($t.TEN),s.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=kt.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=s;a||(o=r);const h=r-o-l;if(0===h)c=s;else if(h>0){const t=$t.TEN.pow(h);c=s.divide(t)}else if(h<0){const t=$t.TEN.pow(-h);c=s.multiply(t)}return i?c.negate():c}static createNaN(){return new $t(U.NaN,U.NaN)}static copy(t){return new $t(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i}static stringOfChar(t,e){const n=new Qt;for(let i=0;i<e;i++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),i=$t.magnitude(n._hi);const s=$t.TEN.pow(i);n=n.divide(s),n.gt($t.TEN)?(n=n.divide($t.TEN),i+=1):n.lt($t.ONE)&&(n=n.multiply($t.TEN),i-=1);const r=i+1,o=new Qt,l=$t.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const i=Math.trunc(n._hi);if(i<0)break;let s=!1,a=0;i>9?(s=!0,a="9"):a="0"+i,o.append(a),n=n.subtract($t.valueOf(i)).multiply($t.TEN),s&&n.selfAdd($t.TEN);let c=!0;const h=$t.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=i,o.toString()}sqr(){return this.multiply(this)}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}setValue(){if(arguments[0]instanceof $t){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}multiply(){if(arguments[0]instanceof $t){const t=arguments[0];return t.isNaN()?$t.createNaN():$t.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return U.isNaN(t)?$t.createNaN():$t.copy(this).selfMultiply(t,0)}}isNaN(){return U.isNaN(this._hi)}reciprocal(){let t=null,e=null,n=null,i=null,s=null,r=null,o=null,l=null;s=1/this._hi,r=$t.SPLIT*s,t=r-s,l=$t.SPLIT*this._hi,t=r-t,e=s-t,n=l-this._hi,o=s*this._hi,n=l-n,i=this._hi-n,l=t*n-o+t*i+e*n+e*i,r=(1-o-l-s*this._lo)/this._hi;const a=s+r;return new $t(a,s-a+r)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof $t){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof $t){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof $t){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof $t){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=$t.SPLIT*o,n=l-o,c=$t.SPLIT*t,n=l-n,i=o-n,s=c-t,a=o*t,s=c-s,r=t-s,c=n*s-a+n*r+i*s+i*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof $t){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=$t.SPLIT*r,e=o-r,a=$t.SPLIT*t._hi,e=o-e,n=r-e,i=a-t._hi,l=r*t._hi,i=a-i,s=t._hi-i,a=e*i-l+e*s+n*i+n*s,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new $t(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return U.isNaN(t)?$t.createNaN():$t.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return $t.valueOf(1);let e=new $t(this),n=$t.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return $t.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new $t(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return $t.valueOf(0);if(this.isNegative())return $t.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=$t.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof $t){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null;return i=this._hi+t,r=i-this._hi,s=i-r,s=t-r+(this._hi-s),o=s+this._lo,e=i+o,n=o+(i-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,s=this._lo+e,a=o-this._hi,c=s-this._lo,l=o-a,r=s-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+s,n=o+a,i=a+(o-n),a=r+i;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof $t){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null;o=$t.SPLIT*this._hi,n=o-this._hi,l=$t.SPLIT*t,n=o-n,i=this._hi-n,s=l-t,o=this._hi*t,s=l-s,r=t-s,l=n*s-o+n*r+i*s+i*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return $t.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new $t(t,e)}negate(){return this.isNaN()?this:new $t(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}intValue(){return Math.trunc(this._hi)}toString(){const t=$t.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1;let s=n;if("."===n.charAt(0))s="0"+n;else if(i<0)s="0."+$t.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){const t=i-n.length;s=n+$t.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+s:s}toSciNotation(){if(this.isZero())return $t.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=$t.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new Ht("Found leading zero: "+n);let s="";n.length>1&&(s=n.substring(1));const r=n.charAt(0)+"."+s;return this.isNegative()?"-"+r+i:r+i}abs(){return this.isNaN()?$t.NaN:this.isNegative()?this.negate():new $t(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof $t){const t=arguments[0];return $t.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return $t.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof $t){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?$t.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[z,X,Z]}}$t.PI=new $t(3.141592653589793,12246467991473532e-32),$t.TWO_PI=new $t(6.283185307179586,24492935982947064e-32),$t.PI_2=new $t(1.5707963267948966,6123233995736766e-32),$t.E=new $t(2.718281828459045,14456468917292502e-32),$t.NaN=new $t(U.NaN,U.NaN),$t.EPS=123259516440783e-46,$t.SPLIT=134217729,$t.MAX_PRINT_DIGITS=32,$t.TEN=$t.valueOf(10),$t.ONE=$t.valueOf(1),$t.SCI_NOT_EXPONENT_CHAR="E",$t.SCI_NOT_ZERO="0.0E0";class te{static orientationIndex(t,e,n){const i=te.orientationIndexFilter(t,e,n);if(i<=1)return i;const s=$t.valueOf(e.x).selfAdd(-t.x),r=$t.valueOf(e.y).selfAdd(-t.y),o=$t.valueOf(n.x).selfAdd(-e.x),l=$t.valueOf(n.y).selfAdd(-e.y);return s.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof $t&&arguments[2]instanceof $t&&arguments[0]instanceof $t&&arguments[1]instanceof $t){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=$t.valueOf(t),r=$t.valueOf(e),o=$t.valueOf(n),l=$t.valueOf(i);return s.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,i){const s=new $t(t.y).selfSubtract(e.y),r=new $t(e.x).selfSubtract(t.x),o=new $t(t.x).selfMultiply(e.y).selfSubtract(new $t(e.x).selfMultiply(t.y)),l=new $t(n.y).selfSubtract(i.y),a=new $t(i.x).selfSubtract(n.x),c=new $t(n.x).selfMultiply(i.y).selfSubtract(new $t(i.x).selfMultiply(n.y)),h=r.multiply(c).selfSubtract(a.multiply(o)),u=l.multiply(o).selfSubtract(s.multiply(c)),g=s.multiply(a).selfSubtract(l.multiply(r)),f=h.selfDivide(g).doubleValue(),d=u.selfDivide(g).doubleValue();return U.isNaN(f)||U.isInfinite(f)||U.isNaN(d)||U.isInfinite(d)?null:new Q(f,d)}static orientationIndexFilter(t,e,n){let i=null;const s=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=s-r;if(s>0){if(r<=0)return te.signum(o);i=s+r}else{if(!(s<0))return te.signum(o);if(r>=0)return te.signum(o);i=-s-r}const l=te.DP_SAFE_EPSILON*i;return o>=l||-o>=l?te.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}te.DP_SAFE_EPSILON=1e-15;class ee{static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new q("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let s=i;do{s-=1,s<0&&(s=e)}while(t[s].equals2D(n)&&s!==i);let r=i;do{r=(r+1)%e}while(t[r].equals2D(n)&&r!==i);const o=t[s],l=t[r];if(o.equals2D(n)||l.equals2D(n)||o.equals2D(l))return!1;const a=ee.index(o,n,l);let c=null;return c=0===a?o.x>l.x:a>0,c}if(F(arguments[0],Nt)){const t=arguments[0],e=t.size()-1;if(e<3)throw new q("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let s=null,r=i;do{r-=1,r<0&&(r=e),s=t.getCoordinate(r)}while(s.equals2D(n)&&r!==i);let o=null,l=i;do{l=(l+1)%e,o=t.getCoordinate(l)}while(o.equals2D(n)&&l!==i);if(s.equals2D(n)||o.equals2D(n)||s.equals2D(o))return!1;const a=ee.index(s,n,o);let c=null;return c=0===a?s.x>o.x:a>0,c}}static index(t,e,n){return te.orientationIndex(t,e,n)}}ee.CLOCKWISE=-1,ee.RIGHT=ee.CLOCKWISE,ee.COUNTERCLOCKWISE=1,ee.LEFT=ee.COUNTERCLOCKWISE,ee.COLLINEAR=0,ee.STRAIGHT=ee.COLLINEAR;class ne extends Et{constructor(){super(),ne.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(Et.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),Et.hasNullElements(e))throw new q("holes must not contain null elements");if(t.isEmpty()&&Et.hasNonEmptyElements(e))throw new q("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let i=0;i<n.length;i++)e++,t[e]=n[i];for(let n=0;n<this._holes.length;n++){const i=this._holes[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;t+=Jt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=Jt.ofRing(this._holes[e].getCoordinateSequence());return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,i=this._shell,s=n._shell;if(!i.equalsExact(s,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return Et.TYPECODE_POLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return Et.TYPENAME_POLYGON}getExteriorRing(){return this._shell}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new ne(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;const s=t.getY(n);if(s!==e.getMinY()&&s!==e.getMaxY())return!1}let n=t.getX(0),i=t.getY(0);for(let e=1;e<=4;e++){const s=t.getX(e),r=t.getY(e);if(s!==n===(r!==i))return!1;n=s,i=r}return!0}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);Ft.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),i=Tt.minCoordinateIndex(n,0,n.size()-2);Tt.scroll(n,i,!0),ee.isCCW(n)===e&&Tt.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,i=e._shell,s=n.compareToSameClass(i,t);if(0!==s)return s;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),i=e.getInteriorRingN(l),s=n.compareToSameClass(i,t);if(0!==s)return s;l++}return l<r?1:l<o?-1:0}}apply(){if(F(arguments[0],It)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(F(arguments[0],Ot)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(F(arguments[0],Rt)){arguments[0].filter(this)}else if(F(arguments[0],tt)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[Gt]}}class ie extends Yt{constructor(){super(),ie.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Yt.constructor_.call(this,t,e)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof Et){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getTypeCode(){return Et.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return Et.TYPENAME_MULTIPOINT}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ie(t,this._factory)}isValid(){return!0}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return mt.FALSE}get interfaces_(){return[Wt]}}class se{constructor(){se.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)se.constructor_.call(this,new jt,0);else if(1===arguments.length){if(F(arguments[0],bt)){const t=arguments[0];se.constructor_.call(this,new jt,0,t)}else if(arguments[0]instanceof jt){const t=arguments[0];se.constructor_.call(this,t,0,se.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];se.constructor_.call(this,t,e,se.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return St.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new q("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new Q(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new Q(t.getMinX(),t.getMinY()),new Q(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new Q(t.getMinX(),t.getMinY()),new Q(t.getMinX(),t.getMaxY()),new Q(t.getMaxX(),t.getMaxY()),new Q(t.getMaxX(),t.getMinY()),new Q(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(F(arguments[0],Nt)){return new wt(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new Zt(null,this);if(1===arguments.length){return new Zt(arguments[0],this)}}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(F(arguments[0],Nt)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Lt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new ne(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new Yt(null,this);if(1===arguments.length){return new Yt(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(F(arguments[0],Nt)){return new Lt(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new qt(null,this);if(1===arguments.length){return new qt(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ie(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ie(arguments[0],this)}if(F(arguments[0],Nt)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const i=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());Tt.copy(t,n,i,0,1),e[n]=this.createPoint(i)}return this.createMultiPoint(e)}}}buildGeometry(t){let e=null,n=!1,i=!1;for(let s=t.iterator();s.hasNext();){const t=s.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof Yt&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(se.toGeometryArray(t));const s=t.iterator().next();if(t.size()>1){if(s instanceof ne)return this.createMultiPolygon(se.toPolygonArray(t));if(s instanceof wt)return this.createMultiLineString(se.toLineStringArray(t));if(s instanceof Kt)return this.createMultiPoint(se.toPointArray(t));V.shouldNeverReachHere("Unhandled geometry type: "+s.getGeometryType())}return s}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Q){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(F(arguments[0],Nt)){return new Kt(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}get interfaces_(){return[z]}}const re=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class oe{constructor(t){this.geometryFactory=t||new se}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!le[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==re.indexOf(n)?le[n].call(this,e.coordinates):"GeometryCollection"===n?le[n].call(this,e.geometries):le[n].call(this,e)}write(t){const e=t.getGeometryType();if(!ae[e])throw new Error("Geometry is not supported");return ae[e].call(this,t)}}const le={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!le[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=le.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(new Q(...i))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new Q(t[0],t[1]),new Q(t[2],t[1]),new Q(t[2],t[3]),new Q(t[0],t[3]),new Q(t[0],t[1])])},Point:function(t){const e=new Q(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(le.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=le.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(le.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=le.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),i=[];for(let e=1;e<t.length;++e){const n=t[e],s=le.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(s);i.push(r)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(le.Polygon.call(this,i))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},ae={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:ae.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.Point.call(this,i);e.push(s.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const i=n[t];e.push(ae.coordinate.call(this,i))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.LineString.call(this,i);e.push(s.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=ae.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const i=t._holes[n],s=ae.LineString.call(this,i);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=ae.Polygon.call(this,i);e.push(s.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=i.getGeometryType();e.push(ae[s].call(this,i))}return{type:"GeometryCollection",geometries:e}}};class ce{constructor(t){this.parser=new oe(t||new se)}read(t){return this.parser.read(t)}}const he="XY",ue="XYZ",ge="XYM",fe="XYZM",de={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},pe=1,_e=2,ye=3,me=4,Ee=5,Ie=6,xe={};for(const t in de)xe[t]=de[t].toUpperCase();class Ne{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,i=t;if("("==t)n=_e;else if(","==t)n=Ee;else if(")"==t)n=ye;else if(this.isNumeric_(t)||"-"==t)n=me,i=this.readNumber_();else if(this.isAlpha_(t))n=pe,i=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=Ie}return{position:e,value:i,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,i=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(i=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!i&&("e"==t||"E"==t)||i&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Te{constructor(t,e){this.lexer_=t,this.token_,this.layout_=he,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=he;const e=this.token_;if(this.isTokenType(pe)){const n=e.value;"Z"===n?t=ue:"M"===n?t=ge:"ZM"===n&&(t=fe),t!==he&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(_e)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Ee));if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(_e)){const t=this.parsePoint_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(_e)){const t=this.parsePointList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(_e)){const t=this.parseLineStringTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(_e)){let t;if(t=this.token_.type==_e?this.parsePointTextList_():this.parsePointList_(),this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(_e)){const t=this.parseLineStringTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(_e)){const t=this.parsePolygonTextList_();if(this.match(ye))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(me))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Ee);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Ee);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Ee);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Ee);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(pe)&&"EMPTY"==this.token_.value;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>t?new Q(...t):new Q,n=n=>{const i=n.map(n=>t.createLinearRing(n.map(e)));return i.length>1?t.createPolygon(i[0],i.slice(1)):1===i.length?t.createPolygon(i[0]):t.createPolygon()},i=this.token_;if(this.match(pe)){const s=i.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==s){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(s){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new Q(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const i=n.map(e).map(e=>t.createPoint(e));return t.createMultiPoint(i)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map(n=>t.createLineString(n.map(e)));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const i=e.map(n);return t.createMultiPolygon(i)}default:throw new Error("Invalid geometry type: "+s)}}throw new Error(this.formatErrorMessage_())}}function Re(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function Oe(t){const e=t.getCoordinates().map(t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e}),n=[];for(let t=0,i=e.length;t<i;++t)n.push(e[t].join(" "));return n.join(", ")}function we(t){const e=[];e.push("("+Oe(t.getExteriorRing())+")");for(let n=0,i=t.getNumInteriorRing();n<i;++n)e.push("("+Oe(t.getInteriorRingN(n))+")");return e.join(", ")}const Le={Point:Re,LineString:Oe,LinearRing:Oe,Polygon:we,MultiPoint:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+Re(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+Oe(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+we(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push(be(t.getGeometryN(n)));return e.join(", ")}};function be(t){let e=t.getGeometryType();const n=Le[e];e=e.toUpperCase();const i=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);if(i.length>0&&(e+=" "+i),t.isEmpty())return e+" EMPTY";return e+" ("+n(t)+")"}class ve{constructor(t){this.geometryFactory=t||new se,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Ne(t);return new Te(e,this.geometryFactory).parse()}write(t){return be(t)}}class Ce{constructor(t){this.parser=new ve(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Se{static toLocationSymbol(t){switch(t){case Se.EXTERIOR:return"e";case Se.BOUNDARY:return"b";case Se.INTERIOR:return"i";case Se.NONE:return"-"}throw new q("Unknown location value: "+t)}}Se.INTERIOR=0,Se.BOUNDARY=1,Se.EXTERIOR=2,Se.NONE=-1;class Pe{constructor(){Pe.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(mt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Pe.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Pe){const t=arguments[0];Pe.constructor_.call(this),this._matrix[Se.INTERIOR][Se.INTERIOR]=t._matrix[Se.INTERIOR][Se.INTERIOR],this._matrix[Se.INTERIOR][Se.BOUNDARY]=t._matrix[Se.INTERIOR][Se.BOUNDARY],this._matrix[Se.INTERIOR][Se.EXTERIOR]=t._matrix[Se.INTERIOR][Se.EXTERIOR],this._matrix[Se.BOUNDARY][Se.INTERIOR]=t._matrix[Se.BOUNDARY][Se.INTERIOR],this._matrix[Se.BOUNDARY][Se.BOUNDARY]=t._matrix[Se.BOUNDARY][Se.BOUNDARY],this._matrix[Se.BOUNDARY][Se.EXTERIOR]=t._matrix[Se.BOUNDARY][Se.EXTERIOR],this._matrix[Se.EXTERIOR][Se.INTERIOR]=t._matrix[Se.EXTERIOR][Se.INTERIOR],this._matrix[Se.EXTERIOR][Se.BOUNDARY]=t._matrix[Se.EXTERIOR][Se.BOUNDARY],this._matrix[Se.EXTERIOR][Se.EXTERIOR]=t._matrix[Se.EXTERIOR][Se.EXTERIOR]}}static isTrue(t){return t>=0||t===mt.TRUE}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===mt.SYM_DONTCARE||(e===mt.SYM_TRUE&&(t>=0||t===mt.TRUE)||(e===mt.SYM_FALSE&&t===mt.FALSE||(e===mt.SYM_P&&t===mt.P||(e===mt.SYM_L&&t===mt.L||e===mt.SYM_A&&t===mt.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Pe(arguments[0]).matches(t)}}isIntersects(){return!this.isDisjoint()}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this._matrix[n][i]=mt.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&this._matrix[Se.EXTERIOR][Se.INTERIOR]===mt.FALSE&&this._matrix[Se.EXTERIOR][Se.BOUNDARY]===mt.FALSE}isWithin(){return Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&this._matrix[Se.INTERIOR][Se.EXTERIOR]===mt.FALSE&&this._matrix[Se.BOUNDARY][Se.EXTERIOR]===mt.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===mt.A&&e===mt.A||t===mt.L&&e===mt.L||t===mt.L&&e===mt.A||t===mt.P&&e===mt.A||t===mt.P&&e===mt.L)&&(this._matrix[Se.INTERIOR][Se.INTERIOR]===mt.FALSE&&(Pe.isTrue(this._matrix[Se.INTERIOR][Se.BOUNDARY])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.INTERIOR])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.BOUNDARY])))}isOverlaps(t,e){return t===mt.P&&e===mt.P||t===mt.A&&e===mt.A?Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&Pe.isTrue(this._matrix[Se.INTERIOR][Se.EXTERIOR])&&Pe.isTrue(this._matrix[Se.EXTERIOR][Se.INTERIOR]):t===mt.L&&e===mt.L&&(1===this._matrix[Se.INTERIOR][Se.INTERIOR]&&Pe.isTrue(this._matrix[Se.INTERIOR][Se.EXTERIOR])&&Pe.isTrue(this._matrix[Se.EXTERIOR][Se.INTERIOR]))}isEquals(t,e){return t===e&&(Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&this._matrix[Se.INTERIOR][Se.EXTERIOR]===mt.FALSE&&this._matrix[Se.BOUNDARY][Se.EXTERIOR]===mt.FALSE&&this._matrix[Se.EXTERIOR][Se.INTERIOR]===mt.FALSE&&this._matrix[Se.EXTERIOR][Se.BOUNDARY]===mt.FALSE)}matches(t){if(9!==t.length)throw new q("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Pe.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Se.INTERIOR][Se.INTERIOR]===mt.FALSE&&this._matrix[Se.INTERIOR][Se.BOUNDARY]===mt.FALSE&&this._matrix[Se.BOUNDARY][Se.INTERIOR]===mt.FALSE&&this._matrix[Se.BOUNDARY][Se.BOUNDARY]===mt.FALSE}isCrosses(t,e){return t===mt.P&&e===mt.L||t===mt.P&&e===mt.A||t===mt.L&&e===mt.A?Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&Pe.isTrue(this._matrix[Se.INTERIOR][Se.EXTERIOR]):t===mt.L&&e===mt.P||t===mt.A&&e===mt.P||t===mt.A&&e===mt.L?Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])&&Pe.isTrue(this._matrix[Se.EXTERIOR][Se.INTERIOR]):t===mt.L&&e===mt.L&&0===this._matrix[Se.INTERIOR][Se.INTERIOR]}isCovers(){return(Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])||Pe.isTrue(this._matrix[Se.INTERIOR][Se.BOUNDARY])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.INTERIOR])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.BOUNDARY]))&&this._matrix[Se.EXTERIOR][Se.INTERIOR]===mt.FALSE&&this._matrix[Se.EXTERIOR][Se.BOUNDARY]===mt.FALSE}isCoveredBy(){return(Pe.isTrue(this._matrix[Se.INTERIOR][Se.INTERIOR])||Pe.isTrue(this._matrix[Se.INTERIOR][Se.BOUNDARY])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.INTERIOR])||Pe.isTrue(this._matrix[Se.BOUNDARY][Se.BOUNDARY]))&&this._matrix[Se.INTERIOR][Se.EXTERIOR]===mt.FALSE&&this._matrix[Se.BOUNDARY][Se.EXTERIOR]===mt.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,mt.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}toString(){const t=new vt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,mt.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}get interfaces_(){return[Z]}}class Me{static isNorthern(t){return t===Me.NE||t===Me.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Me.SE?t===Me.SE||t===Me.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new q("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Me.NE:Me.SE:e>=0?Me.NW:Me.SW}if(arguments[0]instanceof Q&&arguments[1]instanceof Q){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new q("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Me.NE:Me.SE:e.y>=t.y?Me.NW:Me.SW}}}Me.NE=0,Me.NW=1,Me.SW=2,Me.SE=3;class Ae{constructor(){Ae.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Ae.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Ae.constructor_.call(this,t),this.init(e,n),this._label=i}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:ee.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),i=n.lastIndexOf("."),s=n.substring(i+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}getLabel(){return this._label}getEdge(){return this._edge}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Me.quadrant(this._dx,this._dy),V.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getCoordinate(){return this._p0}setNode(t){this._node=t}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getQuadrant(){return this._quadrant}getNode(){return this._node}get interfaces_(){return[X]}}class De{static opposite(t){return t===De.LEFT?De.RIGHT:t===De.RIGHT?De.LEFT:t}}De.ON=0,De.LEFT=1,De.RIGHT=2;class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[De.ON]=t}else if(arguments[0]instanceof Fe){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[De.ON]=t,this.location[De.LEFT]=e,this.location[De.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Se.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Se.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[De.ON]=this.location[De.ON],t[De.LEFT]=Se.NONE,t[De.RIGHT]=Se.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Se.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[De.LEFT];this.location[De.LEFT]=this.location[De.RIGHT],this.location[De.RIGHT]=t}get(t){return t<this.location.length?this.location[t]:Se.NONE}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}toString(){const t=new Qt;return this.location.length>1&&t.append(Se.toLocationSymbol(this.location[De.LEFT])),t.append(Se.toLocationSymbol(this.location[De.ON])),this.location.length>1&&t.append(Se.toLocationSymbol(this.location[De.RIGHT])),t.toString()}setLocations(t,e,n){this.location[De.ON]=t,this.location[De.LEFT]=e,this.location[De.RIGHT]=n}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Se.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(De.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Se.NONE)}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Fe(t),this.elt[1]=new Fe(t)}else if(arguments[0]instanceof Ye){const t=arguments[0];this.elt[0]=new Fe(t.elt[0]),this.elt[1]=new Fe(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new Fe(Se.NONE),this.elt[1]=new Fe(Se.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new Fe(t,e,n),this.elt[1]=new Fe(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.elt[0]=new Fe(Se.NONE,Se.NONE,Se.NONE),this.elt[1]=new Fe(Se.NONE,Se.NONE,Se.NONE),this.elt[t].setLocations(e,n,i)}}static toLineLabel(t){const e=new Ye(Se.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Fe(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(De.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new Qt;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(De.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Fe(this.elt[t].location[0]))}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}}class Ge{computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new ot;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const i=n.iterator();let s=null,r=null;if(!i.hasNext())return null;let o=i.next();do{s=r,r=o,o=null,i.hasNext()&&(o=i.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,s),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}createEdgeEndForNext(t,e,n,i){const s=n.segmentIndex+1;if(s>=t.getNumPoints()&&null===i)return null;let r=t.getCoordinate(s);null!==i&&i.segmentIndex===n.segmentIndex&&(r=i.coord);const o=new Ae(t,n.coord,r,new Ye(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,i){let s=n.segmentIndex;if(0===n.dist){if(0===s)return null;s--}let r=t.getCoordinate(s);null!==i&&i.segmentIndex>=s&&(r=i.coord);const o=new Ye(t.getLabel());o.flip();const l=new Ae(t,n.coord,r,o);e.add(l)}}class qe{constructor(){qe.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){V.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}isInResult(){return this._isInResult}isVisited(){return this._isVisited}}class Be extends qe{constructor(){super(),Be.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Ye(0,Se.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}computeMergedLocation(t,e){let n=Se.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const i=t.getLocation(e);n!==Se.BOUNDARY&&(n=i)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Ye(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof Be){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Ye){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Se.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Se.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Se.BOUNDARY:n=Se.INTERIOR;break;case Se.INTERIOR:default:n=Se.BOUNDARY}this._label.setLocation(t,n)}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}}class Ue extends Bt{}function Xe(t){return null==t?0:t.color}function ze(t){return null==t?null:t.parent}function ke(t,e){null!==t&&(t.color=e)}function je(t){return null==t?null:t.left}function Ve(t){return null==t?null:t.right}class Ze extends Ue{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,i,s=this.root_;do{if(n=s,i=t.compareTo(s.key),i<0)s=s.left;else{if(!(i>0)){const t=s.value;return s.value=e,t}s=s.right}}while(null!==s);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return i<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)ze(t)===je(ze(ze(t)))?(e=Ve(ze(ze(t))),1===Xe(e)?(ke(ze(t),0),ke(e,0),ke(ze(ze(t)),1),t=ze(ze(t))):(t===Ve(ze(t))&&(t=ze(t),this.rotateLeft(t)),ke(ze(t),0),ke(ze(ze(t)),1),this.rotateRight(ze(ze(t))))):(e=je(ze(ze(t))),1===Xe(e)?(ke(ze(t),0),ke(e,0),ke(ze(ze(t)),1),t=ze(ze(t))):(t===je(ze(t))&&(t=ze(t),this.rotateRight(t)),ke(ze(t),0),ke(ze(ze(t)),1),this.rotateLeft(ze(ze(t)))));this.root_.color=0}values(){const t=new ot;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Ze.successor(e));)t.add(e.value);return t}entrySet(){const t=new Ut;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Ze.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Ze,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new ot;for(let n=this.iterator();n.hasNext();){const i=n.next();i.getLabel().getLocation(t)===Se.BOUNDARY&&e.add(i)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof Q){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof Be){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}}class He extends k{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new Q(e):void 0,this.name=Object.keys({TopologyException:He})[0]}getCoordinate(){return this.pt}}class Ke{static intersection(t,e,n,i){const s=t.x<e.x?t.x:e.x,r=t.y<e.y?t.y:e.y,o=t.x>e.x?t.x:e.x,l=t.y>e.y?t.y:e.y,a=n.x<i.x?n.x:i.x,c=n.y<i.y?n.y:i.y,h=n.x>i.x?n.x:i.x,u=n.y>i.y?n.y:i.y,g=((s>a?s:a)+(o<h?o:h))/2,f=((r>c?r:c)+(l<u?l:u))/2,d=t.x-g,p=t.y-f,_=e.x-g,y=e.y-f,m=n.x-g,E=n.y-f,I=i.x-g,x=i.y-f,N=p-y,T=_-d,R=d*y-_*p,O=E-x,w=I-m,L=m*x-I*E,b=N*w-O*T,v=(T*L-w*R)/b,C=(O*R-N*L)/b;return U.isNaN(v)||U.isInfinite(v)||U.isNaN(C)||U.isInfinite(C)?null:new Q(v+g,C+f)}}class Je{static pointToSegmentString(t,e){if(0===e.length)throw new q("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let i=0;i<e.length-1;i++){const s=Je.pointToSegment(t,e[i],e[i+1]);s<n&&(n=s)}return n}static segmentToSegment(t,e,n,i){if(t.equals(e))return Je.pointToSegment(t,n,i);if(n.equals(i))return Je.pointToSegment(i,t,e);let s=!1;if(pt.intersects(t,e,n,i)){const r=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===r)s=!0;else{const o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(s=!0)}}else s=!0;return s?ft.min(Je.pointToSegment(t,n,i),Je.pointToSegment(e,n,i),Je.pointToSegment(n,t,e),Je.pointToSegment(i,t,e)):0}static pointToLinePerpendicular(t,e,n){const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(s)*Math.sqrt(i)}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/i;if(s<=0)return t.distance(e);if(s>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)}}class Qe{constructor(){Qe.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new Q,this._intPt[1]=new Q,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static nonRobustComputeEdgeDistance(t,e,n){const i=t.x-e.x,s=t.y-e.y,r=Math.sqrt(i*i+s*s);return V.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}static computeEdgeDistance(t,e,n){const i=Math.abs(n.x-e.x),s=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=i>s?i:s;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=i>s?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return V.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}computeIntersection(t,e,n,i){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=i,this._result=this.computeIntersect(t,e,n,i)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}getEdgeDistance(t,e){return Qe.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Qe.COLLINEAR_INTERSECTION}toString(){return Ce.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Ce.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new vt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Qe.NO_INTERSECTION}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Qe.DONT_INTERSECT=0,Qe.DO_INTERSECT=1,Qe.COLLINEAR=2,Qe.NO_INTERSECTION=0,Qe.POINT_INTERSECTION=1,Qe.COLLINEAR_INTERSECTION=2;class $e extends Qe{constructor(){super()}static nearestEndpoint(t,e,n,i){let s=t,r=Je.pointToSegment(t,n,i),o=Je.pointToSegment(e,n,i);return o<r&&(r=o,s=e),o=Je.pointToSegment(n,t,e),o<r&&(r=o,s=n),o=Je.pointToSegment(i,t,e),o<r&&(r=o,s=i),s}isInSegmentEnvelopes(t){const e=new pt(this._inputLines[0][0],this._inputLines[0][1]),n=new pt(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,pt.intersects(e,n,t)&&0===ee.index(e,n,t)&&0===ee.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Qe.POINT_INTERSECTION,null;this._result=Qe.NO_INTERSECTION}}intersection(t,e,n,i){let s=this.intersectionSafe(t,e,n,i);return this.isInSegmentEnvelopes(s)||(s=new Q($e.nearestEndpoint(t,e,n,i))),null!==this._precisionModel&&this._precisionModel.makePrecise(s),s}checkDD(t,e,n,i,s){const r=te.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(r);dt.out.println("DD in env = "+o+"  --------------------- "+r),s.distance(r)>1e-4&&dt.out.println("Distance = "+s.distance(r))}intersectionSafe(t,e,n,i){let s=Ke.intersection(t,e,n,i);return null===s&&(s=$e.nearestEndpoint(t,e,n,i)),s}computeCollinearIntersection(t,e,n,i){const s=pt.intersects(t,e,n),r=pt.intersects(t,e,i),o=pt.intersects(n,i,t),l=pt.intersects(n,i,e);return s&&r?(this._intPt[0]=n,this._intPt[1]=i,Qe.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Qe.COLLINEAR_INTERSECTION):s&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Qe.COLLINEAR_INTERSECTION:Qe.POINT_INTERSECTION):s&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Qe.COLLINEAR_INTERSECTION:Qe.POINT_INTERSECTION):r&&o?(this._intPt[0]=i,this._intPt[1]=t,!i.equals(t)||s||l?Qe.COLLINEAR_INTERSECTION:Qe.POINT_INTERSECTION):r&&l?(this._intPt[0]=i,this._intPt[1]=e,!i.equals(e)||s||o?Qe.COLLINEAR_INTERSECTION:Qe.POINT_INTERSECTION):Qe.NO_INTERSECTION}computeIntersect(t,e,n,i){if(this._isProper=!1,!pt.intersects(t,e,n,i))return Qe.NO_INTERSECTION;const s=ee.index(t,e,n),r=ee.index(t,e,i);if(s>0&&r>0||s<0&&r<0)return Qe.NO_INTERSECTION;const o=ee.index(n,i,t),l=ee.index(n,i,e);if(o>0&&l>0||o<0&&l<0)return Qe.NO_INTERSECTION;return 0===s&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,i):(0===s||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this._intPt[0]=e:0===s?this._intPt[0]=new Q(n):0===r?this._intPt[0]=new Q(i):0===o?this._intPt[0]=new Q(t):0===l&&(this._intPt[0]=new Q(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,i)),Qe.POINT_INTERSECTION)}}class tn{constructor(){tn.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof Q&&F(arguments[1],Nt)){const t=arguments[1],e=new tn(arguments[0]),n=new Q,i=new Q;for(let s=1;s<t.size();s++)if(t.getCoordinate(s,n),t.getCoordinate(s-1,i),e.countSegment(n,i),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof Q&&arguments[1]instanceof Array){const t=arguments[1],e=new tn(arguments[0]);for(let n=1;n<t.length;n++){const i=t[n],s=t[n-1];if(e.countSegment(i,s),e.isOnSegment())return e.getLocation()}return e.getLocation()}}getLocation(){return this._isPointOnSegment?Se.BOUNDARY:this._crossingCount%2==1?Se.INTERIOR:Se.EXTERIOR}isPointInPolygon(){return this.getLocation()!==Se.EXTERIOR}isOnSegment(){return this._isPointOnSegment}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this._p.x>=n&&this._p.x<=i&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=ee.index(t,e,this._p);if(n===ee.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===ee.LEFT&&this._crossingCount++}}}class en{static isInRing(t,e){return en.locateInRing(t,e)!==Se.EXTERIOR}static locateInRing(t,e){return tn.locatePointInRing(t,e)}static isOnLine(){if(arguments[0]instanceof Q&&F(arguments[1],Nt)){const t=arguments[0],e=arguments[1],n=new $e,i=new Q,s=new Q,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,i),e.getCoordinate(o,s),n.computeIntersection(t,i,s),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof Q&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new $e;for(let i=1;i<e.length;i++){const s=e[i-1],r=e[i];if(n.computeIntersection(t,s,r),n.hasIntersection())return!0}return!1}}}class nn{locate(t){}}class sn{hasNext(){}next(){}remove(){}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof Yt)}next(){if(this._atStart)return this._atStart=!1,rn.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new rt;const t=this._parent.getGeometryN(this._index++);return t instanceof Yt?(this._subcollectionIterator=new rn(t),this._subcollectionIterator.next()):t}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}remove(){throw new et(this.getClass().getName())}get interfaces_(){return[sn]}}class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Se.EXTERIOR;const n=e.getExteriorRing(),i=on.locatePointInRing(t,n);if(i!==Se.INTERIOR)return i;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=on.locatePointInRing(t,i);if(s===Se.BOUNDARY)return Se.BOUNDARY;if(s===Se.INTERIOR)return Se.EXTERIOR}return Se.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?en.locateInRing(t,e.getCoordinates()):Se.EXTERIOR}static isContained(t,e){return Se.EXTERIOR!==on.locate(t,e)}static locate(t,e){return e.isEmpty()?Se.EXTERIOR:e.getEnvelopeInternal().intersects(t)?on.locateInGeometry(t,e):Se.EXTERIOR}static containsPointInPolygon(t,e){return Se.EXTERIOR!==on.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof ne)return on.locatePointInPolygon(t,e);if(e instanceof Yt){const n=new rn(e);for(;n.hasNext();){const i=n.next();if(i!==e){const e=on.locateInGeometry(t,i);if(e!==Se.EXTERIOR)return e}}}return Se.EXTERIOR}locate(t){return on.locate(t,this._geom)}get interfaces_(){return[nn]}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Ze,this._edgeList=null,this._ptInAreaLocation=[Se.NONE,Se.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Se.NONE;for(let n=this.iterator();n.hasNext();){const i=n.next().getLabel();i.isArea(t)&&i.getLocation(t,De.LEFT)!==Se.NONE&&(e=i.getLocation(t,De.LEFT))}if(e===Se.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const i=e.next(),s=i.getLabel();if(s.getLocation(t,De.ON)===Se.NONE&&s.setLocation(t,De.ON,n),s.isArea(t)){const e=s.getLocation(t,De.LEFT),r=s.getLocation(t,De.RIGHT);if(r!==Se.NONE){if(r!==n)throw new He("side location conflict",i.getCoordinate());e===Se.NONE&&V.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),n=e}else V.isTrue(s.getLocation(t,De.LEFT)===Se.NONE,"found single null side"),s.setLocation(t,De.RIGHT,n),s.setLocation(t,De.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,i=e.get(n).getLabel().getLocation(t,De.LEFT);V.isTrue(i!==Se.NONE,"Found unlabelled area edge");let s=i;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();V.isTrue(n.isArea(t),"Found non-area edge");const i=n.getLocation(t,De.LEFT),r=n.getLocation(t,De.RIGHT);if(i===r)return!1;if(r!==s)return!1;s=i}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new ot(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Se.NONE&&(this._ptInAreaLocation[t]=on.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new Qt;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Se.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const i=n.next(),s=i.getLabel();for(let n=0;n<2;n++)if(s.isAnyNull(n)){let r=Se.NONE;if(e[n])r=Se.EXTERIOR;else{const e=i.getCoordinate();r=this.getLocation(n,e,t)}s.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}print(t){dt.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}}const an={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return an.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?Ft.sort(n,e):Ft.sort(n);const i=t.iterator();for(let t=0,e=n.length;t<e;t++)i.next(),i.set(n[t])},singletonList:function(t){const e=new ot;return e.add(t),e}};var cn=an;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(hn.isAdjacentSegments(e,i))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&i===n||0===i&&e===n)return!0}}return!1}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;const s=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[i],l=n.getCoordinates()[i+1];this._li.computeIntersection(s,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}}class gn{constructor(){gn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=gn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=gn.INSERT,this._label=t,this._xValue=e,this._obj=n}}getObject(){return this._obj}getDeleteEventIndex(){return this._deleteEventIndex}isDelete(){return this._eventType===gn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===gn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}get interfaces_(){return[X]}}gn.INSERT=1,gn.DELETE=2;class fn extends class{}{constructor(){super(),fn.constructor_.apply(this,arguments)}static constructor_(){this.events=new ot,this.nOverlaps=null}prepareEvents(){cn.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof hn&&F(arguments[0],st)&&F(arguments[1],st)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&F(arguments[0],st)&&arguments[1]instanceof hn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),i=n.getStartIndexes();for(let t=0;t<i.length-1;t++){const i=new un(n,t),s=new gn(e,n.getMinX(t),i);this.events.add(s),this.events.add(new gn(n.getMaxX(t),s))}}processOverlaps(t,e,n,i){const s=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(s.computeIntersections(e,i),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class dn{createNode(t){return new Be(t,null)}}class pn extends Ae{constructor(){super(),pn.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Ae.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Se.EXTERIOR&&e===Se.INTERIOR?1:t===Se.INTERIOR&&e===Se.EXTERIOR?-1:0}setVisited(t){this._isVisited=t}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new He("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,De.LEFT)===Se.INTERIOR&&this._label.getLocation(e,De.RIGHT)===Se.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[De.LEFT]+"/"+this._depth[De.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}getSym(){return this._sym}isForward(){return this._isForward}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}computeDirectedLabel(){this._label=new Ye(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Se.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Se.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let i=1;t===De.LEFT&&(i=-1);const s=De.opposite(t),r=e+n*i;this.setDepth(t,e),this.setDepth(s,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}}class _n{constructor(){_n.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new ot,this._nodes=null,this._edgeEndList=new ot,0===arguments.length)this._nodes=new We(new dn);else if(1===arguments.length){const t=arguments[0];this._nodes=new We(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}debugPrintln(t){dt.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const i=n.getLabel();return null!==i&&i.getLocation(t)===Se.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}debugPrint(t){dt.out.print(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(t.equals(s[0])&&e.equals(s[1]))return i}return null}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof Be){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof Q){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}matchInSameDirection(t,e,n,i){return!!t.equals(n)&&(ee.index(t,e,i)===ee.COLLINEAR&&Me.quadrant(t,e)===Me.quadrant(n,i))}getEdgeEnds(){return this._edgeEndList}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(this.matchInSameDirection(t,e,s[0],s[1]))return i;if(this.matchInSameDirection(t,e,s[s.length-1],s[s.length-2]))return i}return null}insertEdge(t){this._edges.add(t)}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new pn(t,!0),i=new pn(t,!1);n.setSym(i),i.setSym(n),this.add(n),this.add(i)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}}class yn{isInBoundary(t){}}class mn{isInBoundary(t){return t%2==1}get interfaces_(){return[yn]}}class En{isInBoundary(t){return t>0}get interfaces_(){return[yn]}}class In{isInBoundary(t){return t>1}get interfaces_(){return[yn]}}class xn{isInBoundary(t){return 1===t}get interfaces_(){return[yn]}}yn.Mod2BoundaryNodeRule=mn,yn.EndPointBoundaryNodeRule=En,yn.MultiValentEndPointBoundaryNodeRule=In,yn.MonoValentEndPointBoundaryNodeRule=xn,yn.MOD2_BOUNDARY_RULE=new mn,yn.ENDPOINT_BOUNDARY_RULE=new En,yn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new In,yn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new xn,yn.OGC_SFS_BOUNDARY_RULE=yn.MOD2_BOUNDARY_RULE;class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=yn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new q("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?en.locateInRing(t,e.getCoordinates()):Se.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Se.EXTERIOR}updateLocationInfo(t){t===Se.INTERIOR&&(this._isIn=!0),t===Se.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Kt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof wt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof ne)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof Zt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,i))}}else if(e instanceof qt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,i))}}else if(e instanceof Yt){const n=new rn(e);for(;n.hasNext();){const i=n.next();i!==e&&this.computeLocation(t,i)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Se.INTERIOR:Se.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Se.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?en.isOnLine(t,n)?Se.INTERIOR:Se.EXTERIOR:Se.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Se.EXTERIOR;const n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===Se.EXTERIOR)return Se.EXTERIOR;if(i===Se.BOUNDARY)return Se.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=this.locateInPolygonRing(t,i);if(s===Se.INTERIOR)return Se.EXTERIOR;if(s===Se.BOUNDARY)return Se.BOUNDARY}return Se.INTERIOR}locate(t,e){return e.isEmpty()?Se.EXTERIOR:e instanceof wt?this.locateOnLineString(t,e):e instanceof ne?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Se.BOUNDARY:this._numBoundaries>0||this._isIn?Se.INTERIOR:Se.EXTERIOR)}}class Tn{visitItem(t){}}class Rn{constructor(){Rn.constructor_.apply(this,arguments)}static constructor_(){this._min=U.POSITIVE_INFINITY,this._max=U.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Ce.toLineString(new Q(this._min,0),new Q(this._max,0))}}Rn.NodeComparator=class{compare(t,e){const n=t,i=e,s=(n._min+n._max)/2,r=(i._min+i._max)/2;return s<r?-1:s>r?1:0}get interfaces_(){return[W]}};class On extends Rn{constructor(){super(),On.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class wn extends Rn{constructor(){super(),wn.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Ln{constructor(){Ln.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new ot,this._root=null,this._level=0}buildTree(){cn.sort(this._leaves,new Rn.NodeComparator);let t=this._leaves,e=null,n=new ot;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new Ht("Index cannot be added to once it has been queried");this._leaves.add(new On(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){dt.out.println(Ce.toLineString(new Q(t._min,this._level),new Q(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const i=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(i);else{const i=new wn(t.get(n),t.get(n+1));e.add(i)}}}}class bn{constructor(){bn.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)bn.constructor_.call(this,new Q,new Q);else if(1===arguments.length){const t=arguments[0];bn.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];bn.constructor_.call(this,new Q(t,e),new Q(n,i))}}static midPoint(t,e){return new Q((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof bn){const t=arguments[0],e=ee.index(this.p0,this.p1,t.p0),n=ee.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof Q){const t=arguments[0];return ee.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return bn.midPoint(this.p0,this.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),s=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(s*s+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new Ht("Cannot compute offset from zero-length line segment");l=e*s/o,a=e*r/o}return new Q(n-a,i+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||U.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}distance(){if(arguments[0]instanceof bn){const t=arguments[0];return Je.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof Q){const t=arguments[0];return Je.pointToSegment(t,this.p0,this.p1)}}equals(t){if(!(t instanceof bn))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new $e;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof Q){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new Q(t);const e=this.projectionFactor(t),n=new Q;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof bn){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let i=this.project(t.p0);e<0&&(i=this.p0),e>1&&(i=this.p1);let s=this.project(t.p1);return n<0&&(s=this.p0),n>1&&(s=this.p1),new bn(i,s)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return Je.pointToLinePerpendicular(t,this.p0,this.p1)}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(i<=0)return U.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let i=U.MAX_VALUE,s=null;const r=this.closestPoint(t.p0);i=r.distance(t.p0),n[0]=r,n[1]=t.p0;const o=this.closestPoint(t.p1);s=o.distance(t.p1),s<i&&(i=s,n[0]=o,n[1]=t.p1);const l=t.closestPoint(this.p0);s=l.distance(this.p0),s<i&&(i=s,n[0]=this.p0,n[1]=l);const a=t.closestPoint(this.p1);return s=a.distance(this.p1),s<i&&(i=s,n[0]=this.p1,n[1]=a),n}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return Ke.intersection(this.p0,this.p1,t.p0,t.p1)}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),i=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),s=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new Q((-r*o-2*e*n*l-2*e*i)/s,(r*l-2*e*n*o-2*n*i)/s)}pointAlong(t){const e=new Q;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=U.doubleToLongBits(this.p0.x);t^=31*U.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=U.doubleToLongBits(this.p1.x);n^=31*U.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[X,z]}}class vn{constructor(){vn.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getLines(){if(1===arguments.length){const t=arguments[0];return vn.getLines(t,!1)}if(2===arguments.length){if(F(arguments[0],nt)&&F(arguments[1],nt)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();vn.getLines(n,t)}return t}if(arguments[0]instanceof Et&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new ot;return t.apply(new vn(n,e)),n}if(arguments[0]instanceof Et&&F(arguments[1],nt)){const t=arguments[0],e=arguments[1];return t instanceof wt?e.add(t):t.apply(new vn(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&F(arguments[0],nt)&&F(arguments[1],nt)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const i=n.next();vn.getLines(i,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof Et&&F(arguments[1],nt)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new vn(t,e)),t}}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(vn.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(vn.getLines(t,e))}}filter(t){if(this._isForcedToLineString&&t instanceof Lt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof wt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[tt]}}class Cn{constructor(){Cn.constructor_.apply(this,arguments)}static constructor_(){this._items=new ot}getItems(){return this._items}visitItem(t){this._items.add(t)}get interfaces_(){return[Tn]}}class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(F(t,Gt)||t instanceof Lt))throw new q("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new Mn(this._geom),this._geom=null);const e=new tn(t),n=new Pn(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[nn]}}class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[Tn]}}class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Ln;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=vn.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new bn(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),s=Math.max(n.p0.y,n.p1.y);this._index.insert(i,s,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new ot;const n=new Cn;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}Sn.SegmentVisitor=Pn,Sn.IntervalIndexedGeometry=Mn;class An{constructor(){An.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new Q(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[X]}}class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Ze,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const i=this.edge.pts[e.segmentIndex],s=e.dist>0||!e.coord.equals2D(i);s||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new Q(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return s&&(r[o]=e.coord),new Bn(r,new Ye(this.edge._label))}add(t,e,n){const i=new An(t,e,n),s=this._nodeMap.get(i);return null!==s?s:(this._nodeMap.put(i,i),i)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const i=e.next(),s=this.createSplitEdge(n,i);t.add(s),n=i}}}class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Fn.NULL_VALUE}static depthAtLocation(t){return t===Se.EXTERIOR?0:t===Se.INTERIOR?1:Fn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Fn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Fn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Fn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let i=0;this._depth[t][n]>e&&(i=1),this._depth[t][n]=i}}}getDelta(t){return this._depth[t][De.RIGHT]-this._depth[t][De.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Se.EXTERIOR:Se.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const i=t.getLocation(e,n);i!==Se.EXTERIOR&&i!==Se.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Fn.depthAtLocation(i):this._depth[e][n]+=Fn.depthAtLocation(i))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Se.INTERIOR&&this._depth[t][e]++}}}Fn.NULL_VALUE=-1;class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)Yn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),dt.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=Ft.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return dt.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class Gn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}findChainEnd(t,e){const n=Me.quadrant(t[e],t[e+1]);let i=e+1;for(;i<t.length;){if(Me.quadrant(t[i-1],t[i])!==n)break;i++}return i-1}OLDgetChainStartIndices(t){let e=0;const n=new ot;n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return Gn.toIntArray(n)}getChainStartIndices(t){let e=0;const n=new Yn(Math.trunc(t.length/2));n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return n.toArray()}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Gn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4],r=arguments[5];if(e-t==1&&s-i==1)return r.addIntersections(this.e,t,n.e,i),null;if(!this.overlaps(t,e,n,i,s))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((i+s)/2);t<o&&(i<l&&this.computeIntersectsForChain(t,o,n,i,l,r),l<s&&this.computeIntersectsForChain(t,o,n,l,s,r)),o<e&&(i<l&&this.computeIntersectsForChain(o,e,n,i,l,r),l<s&&this.computeIntersectsForChain(o,e,n,l,s,r))}}overlaps(t,e,n,i,s){return pt.intersects(this.pts[t],this.pts[e],n.pts[i],n.pts[s])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)}}class Bn extends qe{constructor(){super(),Bn.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Dn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Fn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Bn.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Pe&&arguments[0]instanceof Ye))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,De.ON),t.getLocation(1,De.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,De.LEFT),t.getLocation(1,De.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,De.RIGHT),t.getLocation(1,De.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new Bn(t,Ye.toLineLabel(this._label))}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Bn))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,i=!0,s=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--s])||(i=!1),!n&&!i)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Bn.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new qn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new pt;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,i){const s=new Q(t.getIntersection(i));let r=e,o=t.getEdgeDistance(n,i);const l=r+1;if(l<this.pts.length){const t=this.pts[l];s.equals2D(t)&&(r=l,o=0)}this.eiList.add(s,r,o)}toString(){const t=new vt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}}class Un extends _n{constructor(){super(),Un.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new zt,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new Nn,2===arguments.length){const t=arguments[0],e=arguments[1];Un.constructor_.call(this,t,e,yn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Se.BOUNDARY:Se.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let i=1,s=Se.NONE;s=n.getLocation(t,De.ON),s===Se.BOUNDARY&&i++;const r=Un.determineBoundary(this._boundaryNodeRule,i);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new hn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const i=this.createEdgeSetIntersector(),s=this._parentGeom instanceof Lt||this._parentGeom instanceof ne||this._parentGeom instanceof qt,r=t||!s;return i.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Se.EXTERIOR,Se.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Se.INTERIOR,Se.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Se.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Se.BOUNDARY)}addLineString(t){const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Bn(e,new Ye(this._argIndex,Se.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),V.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let i=t.iterator();i.hasNext();){const t=i.next();e[n++]=t.getCoordinate().copy()}return e}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,i)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof Et))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof qt&&(this._useBoundaryDeterminationRule=!1),t instanceof ne)this.addPolygon(t);else if(t instanceof wt)this.addLineString(t);else if(t instanceof Kt)this.addPoint(t);else if(t instanceof ie)this.addCollection(t);else if(t instanceof Zt)this.addCollection(t);else if(t instanceof qt)this.addCollection(t);else{if(!(t instanceof Yt))throw new et(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return F(this._parentGeom,Gt)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Sn(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof wt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const i=new hn(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,i),i}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Kt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Se.INTERIOR)}else if(arguments[0]instanceof Q){const t=arguments[0];this.insertPoint(this._argIndex,t,Se.INTERIOR)}}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Se.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const i=_t.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=i[0],null;let s=e,r=n;ee.isCCW(i)&&(s=n,r=e);const o=new Bn(i,new Ye(this._argIndex,Se.BOUNDARY,s,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,i[0],Se.BOUNDARY)}insertPoint(t,e,n){const i=this._nodes.addNode(e),s=i.getLabel();null===s?i._label=new Ye(t,n):s.setLocation(t,n)}createEdgeSetIntersector(){return new fn}}class Xn extends Ae{constructor(){super(),Xn.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new ot,1===arguments.length){const t=arguments[0];Xn.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Ae.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Ye(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,i=!1;for(let e=this.iterator();e.hasNext();){const s=e.next().getLabel().getLocation(t);s===Se.BOUNDARY&&n++,s===Se.INTERIOR&&(i=!0)}let s=Se.NONE;i&&(s=Se.INTERIOR),n>0&&(s=Un.determineBoundary(e,n)),this._label.setLocation(t,s)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const i=n.next();if(i.getLabel().isArea()){const n=i.getLabel().getLocation(t,e);if(n===Se.INTERIOR)return this._label.setLocation(t,e,Se.INTERIOR),null;n===Se.EXTERIOR&&this._label.setLocation(t,e,Se.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,De.LEFT),this.computeLabelSide(t,De.RIGHT)}updateIM(t){Bn.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Ye(Se.NONE,Se.NONE,Se.NONE):new Ye(Se.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class zn extends ln{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Xn(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class kn extends Be{constructor(){super(),kn.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Be.constructor_.call(this,t,e)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}updateIMFromEdges(t){this._edges.updateIM(t)}}class jn extends dn{constructor(){super()}createNode(t){return new kn(t,new zn)}}class Vn{constructor(){Vn.constructor_.apply(this,arguments)}static constructor_(){this._li=new $e,this._ptLocator=new Nn,this._arg=null,this._nodes=new We(new jn),this._im=null,this._isolatedEdges=new ot,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),i=this._arg[1].getGeometry().getDimension(),s=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===i?s&&e.setAtLeast("212101212"):2===n&&1===i?(s&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(s&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const i=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,Se.EXTERIOR)}computeIM(){const t=new Pe;if(t.set(Se.EXTERIOR,Se.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Ge,i=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(i);const s=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(s),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.find(n.coord);s.getLabel().isNull(t)&&(i===Se.BOUNDARY?s.setLabelBoundary(t):s.setLabel(t,Se.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.addNode(n.coord);i===Se.BOUNDARY?s.setLabelBoundary(t):s.getLabel().isNull(t)&&s.setLabel(t,Se.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();V.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Se.INTERIOR,Se.EXTERIOR,e.getDimension()),t.set(Se.BOUNDARY,Se.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Se.EXTERIOR,Se.INTERIOR,n.getDimension()),t.set(Se.EXTERIOR,Se.BOUNDARY,n.getBoundaryDimension()))}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new $e,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Un(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.constructor_.call(this,t,e,yn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Un(0,t,n),this._arg[1]=new Un(1,e,n)}}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getArgGeometry(t){return this._arg[t].getGeometry()}}class Wn{constructor(){Wn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Wn(t).contains(e)}isContainedInBoundary(t){if(t instanceof ne)return!1;if(t instanceof Kt)return this.isPointContainedInBoundary(t);if(t instanceof wt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new Q,i=new Q;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Kt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof Q){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Hn{constructor(){Hn.constructor_.apply(this,arguments)}static constructor_(){this._li=new $e,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new Q(t.getMinX(),t.getMinY()),this._diagUp1=new Q(t.getMaxX(),t.getMaxY()),this._diagDown0=new Q(t.getMinX(),t.getMaxY()),this._diagDown1=new Q(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new pt(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let i=!1;return e.y>t.y&&(i=!0),i?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Kn{constructor(){Kn.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof Yt)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Jn(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Qn(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new $n(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const i=new ti(this._rectangle);return i.applyTo(t),!!i.intersects()}}class Qn extends Kn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}intersects(){return this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}isDone(){return!0===this._intersects}}class $n extends Kn{constructor(){super(),$n.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}visit(t){if(!(t instanceof ne))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new Q;for(let i=0;i<4;i++)if(this._rectSeq.getCoordinate(i,n),e.contains(n)&&on.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}isDone(){return!0===this._containsPoint}}class ti extends Kn{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new Q,this._p1=new Q;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Hn(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=vn.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class ei extends Zn{constructor(){super(),ei.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Zn.constructor_.call(this,t,e),this._relate=new Vn(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Zn.constructor_.call(this,t,e,n),this._relate=new Vn(this._arg)}}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&ei.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new ei(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new ei(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static disjoint(t,e){return!ei.intersects(t,e)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new ei(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Jn.intersects(t,e);if(e.isRectangle())return Jn.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let i=0;i<e.getNumGeometries();i++)if(t.getGeometryN(n).intersects(e.getGeometryN(i)))return!0;return!1}return new ei(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new ei(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Wn.contains(t,e):new ei(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}function ni(t){return function(t){if(Array.isArray(t))return ii(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return ii(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return ii(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ii(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function si(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ri(t,e)}function ri(t,e){return(ri=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function oi(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=ai(t);if(e){var s=ai(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return li(this,n)}}function li(t,e){if(e&&("object"===ci(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function ai(t){return(ai=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function ci(t){return(ci="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function hi(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ui(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==ci(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==ci(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===ci(r)?r:String(r)),i)}var s,r}function gi(t,e,n){return e&&ui(t.prototype,e),n&&ui(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}var fi=function(t){si(n,t);var e=oi(n);function n(t,i){hi(this,n);return e.call(this,(function(e,n){var i=null;return M.utils.isNullOrEmpty(e)||(i=e.getGeometry()),t(i,n)}),i)}return gi(n)}(function(t){si(n,t);var e=oi(n);function n(t){var i,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return hi(this,n),(i=e.call(this)).filterFunction_=t,i.cqlFilter_="",M.utils.isNullOrEmpty(s.cqlFilter)||(i.cqlFilter_=s.cqlFilter),i}return gi(n,[{key:"setFunction",value:function(t){this.filterFunction_=t}},{key:"getFunctionFilter",value:function(){return this.filterFunction_}},{key:"execute",value:function(t){return t.filter(this.filterFunction_)}},{key:"toCQL",value:function(){return this.cqlFilter_}}]),n}(function(){function t(){hi(this,t)}return gi(t,[{key:"getFunctionFilter",value:function(){}},{key:"execute",value:function(t){}},{key:"toCQL",value:function(){}}]),t}())),di=function(t,e){var n="",i=new M.format.WKT;return e.forEach((function(e,s){0!==s&&(n+=" OR ");var r=new M.Feature("filtered_geom",{type:"Feature",geometry:e}),o=i.write(r);n+="".concat(t,"({{geometryName}}, ").concat(o,")")})),n},pi=function(t){var e=function(t){var e=t,n=[];return e instanceof M.layer.Vector?n=ni(e.getFeatures().map((function(t){return t.getGeometry()}))):(M.utils.isArray(e)||(e=[e]),n=e.map((function(t){var e;return t instanceof M.Feature?e=t.getGeometry():M.isObject(t)&&(e=t),e}))),n}(t);return new fi((function(t,n){var i=new ce,s=i.read(t);return e.some((function(t){var e=i.read(t);return ei.intersects(s,e)}))}),{cqlFilter:di("INTERSECTS",e)})};function _i(t){return(_i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function yi(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function mi(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(s=i.key,r=void 0,r=function(t,e){if("object"!==_i(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==_i(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(s,"string"),"symbol"===_i(r)?r:String(r)),i)}var s,r}function Ei(t,e){return(Ei=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Ii(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,i=Ni(t);if(e){var s=Ni(this).constructor;n=Reflect.construct(i,arguments,s)}else n=i.apply(this,arguments);return xi(this,n)}}function xi(t,e){if(e&&("object"===_i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function Ni(t){return(Ni=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Ti=1,Ri=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ei(t,e)}(r,M.Plugin);var e,n,i,s=Ii(r);function r(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return yi(this,r),t=s.call(this),e.mode!==Ti||M.utils.isNullOrEmpty(e.url)||M.utils.isNullOrEmpty(e.type)&&console.warn(L("exception.type")),e.mode!==Ti||M.utils.isNullOrEmpty(e.layerName)||M.utils.isNullOrEmpty(e.type)&&console.warn(L("exception.layerName")),t.map_=null,t.controls_=[],t.mode_=Number.parseInt(e.mode,10)||1,t.url_=e.url||"https://componentes.cnig.es/api-core/files/attributions/WMTS_PNOA_20170220/atribucionPNOA_Url.kml",t.type_=e.type||"kml",t.layerName_=e.layerName||"attributions",t.layer_=e.layer,t.scale_=Number.parseInt(e.scale,10)||1e4,t.attributionParam_=e.attributionParam||"atribucion",t.urlParam_=e.urlParam||"url",t.minWidth_=e.minWidth||"100px",t.maxWidth_=e.maxWidth||"200px",t.position_=e.position||"BL",t.defaultAttribution_=e.defaultAttribution||"Instituto Geogr&aacute;fico Nacional",t.defaultURL_=e.defaultURL||"https://www.ign.es/",t.tooltip_=e.tooltip||L("tooltip"),t.urlAttribute=e.urlAttribute||"Gobierno de España",window.addEventListener("resize",(function(e){return t.setCollapsiblePanel(e)})),t.order=e.order>=-1?e.order:null,t.options=e,t}return e=r,i=[{key:"getJSONTranslations",value:function(t){return"en"===t||"es"===t?"en"===t?N:T:M.language.getTranslation(t).attributions}}],(n=[{key:"addTo",value:function(t){var e=this;this.map_=t,this.impl_=new c(t),this.control_=new D(this.position_,this.closePanel),this.controls_.push(this.control_),this.panel_=new M.ui.Panel("Attributions",{collapsible:window.innerWidth<769,position:M.ui.position[this.position_],className:"m-panel-attributions",collapsedButtonClass:"g-cartografia-info",tooltip:this.tooltip_,order:this.order}),this.panel_.addControls(this.control_),this.map_.addPanels(this.panel_),this.initMode(),this.onMoveEnd((function(){e.changeAttributions()}))}},{key:"destroy",value:function(){this.map_.removeControls([this.control_]),this.panel_=null}},{key:"initMode",value:function(){if(this.mode_===Ti){if(!(this.layer_ instanceof M.layer.Vector)){var t={name:this.layerName_,url:this.url_};"geojson"===this.type_?this.layer_=new M.layer.GeoJSON(t,{displayInLayerSwitcher:!1}):"kml"===this.type_?this.layer_=new M.layer.KML(t,{displayInLayerSwitcher:!1}):this.type}this.map_.getLayers({name:this.layer_}).length<1&&(this.map_.addLayers(this.layer_),this.layer_.displayInLayerSwitcher=!1,this.layer_.setVisible(!1))}}},{key:"changeAttributions",value:function(){if(this.clearContent(),this.map_.getScale()<=this.scale_){this.setVisible(!0);var t=[];if(this.mode_===Ti){t=this.getMapAttributions();var e=this.map_.getZoom(),n=this.map_.getBaseLayers()[0],i=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;t=void 0!==n&&"OI.OrthoimageCoverage"===n.name||i?e<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):void 0===n||"IGNBaseTodo"!==n.name&&"EL.GridCoverageDSM"!==n.name?void 0!==n&&"LC.LandCoverSurfaces"===n.name?e<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):[{attribution:this.defaultAttribution_,url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t)}this.addContent(t)}else{var s=this.map_.getZoom(),r=this.map_.getBaseLayers()[0],o=[{attribution:this.defaultAttribution_,url:this.defaultURL_}],l=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;void 0!==r&&"OI.OrthoimageCoverage"===r.name||l?o=s<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]:void 0===r||"IGNBaseTodo"!==r.name&&"EL.GridCoverageDSM"!==r.name?void 0!==r&&"LC.LandCoverSurfaces"===r.name&&(o=s<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]):o=[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}],this.addContent(o)}}},{key:"addContent",value:function(t){var e=this,n=this.control_.getElement(),i=t.map((function(t,n,i){var s=document.createElement("a");s.target="_blank",s.href=t.url,s.setAttribute("rol","link"),s.setAttribute("tabindex",e.order),s.innerHTML=t.attribution;var r=e.map_.getScale()>e.scale_?"":", ".concat(e.urlAttribute);return s.innerHTML+=i.length-1===n?r:",",s})),s=document.createElement("div");i.forEach((function(t){s.append(t)})),n.append(s)}},{key:"clearContent",value:function(){if(!M.utils.isNullOrEmpty(this.control_)){var t=this.control_.getElement();t.querySelectorAll("div").forEach((function(e){return t.removeChild(e)}))}}},{key:"setVisible",value:function(t){this.control_.getElement().style.display=!1===t?"none":""}},{key:"getMapAttributions",value:function(){var t=this;this.updateBBoxFeature();var e=this.map_.getLayers().filter((function(t){return t.name.includes("attributions")}))[0].getFeatures();return pi(this.bboxFeature_).execute(e).map((function(e){return{attribution:e.getAttribute(t.attributionParam_)||"",url:e.getAttribute(t.urlParam_)||t.defaultURL_}})).filter((function(t,e,n){return n.map((function(t){return t.attribution})).indexOf(t.attribution)===e}))}},{key:"getLayerAttributions",value:function(){}},{key:"closePanel",value:function(){this.getPanel().collapse()}},{key:"changeContentAttribution",value:function(t){this.control_.changeContent(t)}},{key:"updateBBoxFeature",value:function(){var t=this.map_.getBbox(),e=t.x,n=t.y;this.bboxFeature_=new M.Feature("bbox_feature",{type:"Feature",properties:{},geometry:{type:"Polygon",coordinates:[[[e.min,n.min],[e.min,n.max],[e.max,n.max],[e.max,n.min],[e.min,n.min]]]}})}},{key:"setCollapsiblePanel",value:function(t){this.getPanel()&&this.getPanel().getTemplatePanel()&&(t.target.innerWidth<769?(this.getPanel().getTemplatePanel().classList.remove("no-collapsible"),this.closePanel()):(this.getPanel().getTemplatePanel().classList.add("no-collapsible"),this.getPanel().getTemplatePanel().classList.remove("collapsed")))}},{key:"onMoveEnd",value:function(t){this.impl_.registerEvent("moveend",(function(e){return t(e)}))}},{key:"getPanel",value:function(){return this.panel_}},{key:"name",get:function(){return"attributions"}},{key:"mode",get:function(){return this.mode_}},{key:"position",get:function(){return this.position_}},{key:"scale",get:function(){return this.scale_}},{key:"defaultAttribution",get:function(){return this.defaultAttribution_}},{key:"defaultURL",get:function(){return this.defaultURL_}},{key:"url",get:function(){return this.url_}},{key:"type",get:function(){return this.type_}},{key:"layerName",get:function(){return this.layerName_}},{key:"attributionParam",get:function(){return this.attributionParam_}},{key:"urlParam",get:function(){return this.urlParam_}},{key:"getAPIRest",value:function(){return"".concat(this.name,"=").concat(this.position,"*").concat(this.tooltip_,"*").concat(this.mode,"*").concat(this.scale,"*").concat(this.defaultAttribution,"*").concat(this.defaultURL,"*").concat(this.url,"*").concat(this.type,"*").concat(this.layerName,"*").concat(this.attributionParam_,"*").concat(this.urlParam,"*").concat(this.minWidth_,"*").concat(this.maxWidth_,"*").concat(this.urlAttribute)}},{key:"getAPIRestBase64",value:function(){return"".concat(this.name,"=base64=").concat(M.utils.encodeBase64(this.options))}}])&&mi(e.prototype,n),i&&mi(e,i),Object.defineProperty(e,"prototype",{writable:!1}),r}();window.M.plugin||(window.M.plugin={}),window.M.control||(window.M.control={}),window.M.impl||(window.M.impl={}),window.M.impl.control||(window.M.impl.control={}),window.M.plugin.Attributions=Ri,window.M.control.AttributionsControl=D,window.M.impl.control.AttributionsControl=E}]);
//# sourceMappingURL=attributions.ol.min.js.map