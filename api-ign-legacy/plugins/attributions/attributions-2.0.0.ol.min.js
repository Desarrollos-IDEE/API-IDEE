(()=>{var t={945:t=>{t.exports='<div id="m-attributions-container" class="m-control m-container m-attributions">\n    <button id=\'close-button\' class="{{icon}}"></button>\n</div>'}},e={};function n(i){var s=e[i];if(void 0!==s)return s.exports;var r=e[i]={exports:{}};return t[i](r,r.exports,n),r.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{"use strict";function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(e)}function e(t,e){for(var n=0;n<e.length;n++){var s=e[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,i(s.key),s)}}function i(e){var n=function(e,n){if("object"!=t(e)||!e)return e;var i=e[Symbol.toPrimitive];if(void 0!==i){var s=i.call(e,"string");if("object"!=t(s))return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==t(n)?n:n+""}function s(e,n,i){return n=o(n),function(e,n){if(n&&("object"==t(n)||"function"==typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e)}(e,r()?Reflect.construct(n,i||[],o(e).constructor):n.apply(e,i))}function r(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(r=function(){return!!t})()}function o(t){return o=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},o(t)}function l(t,e){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},l(t,e)}const a=function(t){function n(t){var e;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),(e=s(this,n)).map_=t,e}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&l(t,e)}(n,M.Object),i=n,(r=[{key:"registerEvent",value:function(t,e){this.map_.getMapImpl().on(t,e)}}])&&e(i.prototype,r),Object.defineProperty(i,"prototype",{writable:!1}),i;var i,r}();function c(t){return c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},c(t)}function h(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,u(i.key),i)}}function u(t){var e=function(t,e){if("object"!=c(t)||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,"string");if("object"!=c(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==c(e)?e:e+""}function g(t,e,n){return e=f(e),function(t,e){if(e&&("object"==c(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,d()?Reflect.construct(e,n||[],f(t).constructor):e.apply(t,n))}function d(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(d=function(){return!!t})()}function p(){return p="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var i=function(t,e){for(;!{}.hasOwnProperty.call(t,e)&&null!==(t=f(t)););return t}(t,e);if(i){var s=Object.getOwnPropertyDescriptor(i,e);return s.get?s.get.call(arguments.length<3?t:n):s.value}},p.apply(null,arguments)}function f(t){return f=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},f(t)}function _(t,e){return _=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_(t,e)}var y=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),g(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_(t,e)}(e,M.impl.Control),n=e,(i=[{key:"addTo",value:function(t,n){var i=this;t.getMapImpl().getInteractions().forEach((function(t){t instanceof ol.interaction.DoubleClickZoom&&(i.dblClickInteraction_=t)})),p(f(e.prototype),"addTo",this).call(this,t,n)}},{key:"destroy",value:function(){this.facadeMap_.getMapImpl().removeControl(this),this.facadeMap_=null}}])&&h(n.prototype,i),Object.defineProperty(n,"prototype",{writable:!1}),n;var n,i}(),m=n(945),E=n.n(m);const I=JSON.parse('{"exception":{"impl":"The implementation used cannot create Attributions controls.","mode":"Options mode is bad setted. Tip: {mode: 1 | 2 | 3}.","type":"Missing \'type\' options. When \'url\' option is setted the plugin needs \'type\' option. Values = geojson | kml | topojson.","layer_name":"Missing \'layerName\' options. When \'url\' option is setted the plugin needs \'layerName\' option.","attribution_obsolete":"Developer message: M.plugin.Attributions has been deprecated, use the Attributions control instead"},"attribution":"attribution","tooltip":"Acknowledgments"}'),x=JSON.parse('{"exception":{"impl":"La implementación no puede crear controles de Attribution.","mode":"La opción \'mode\' no ha sido establecida correctamente. Consejo: {mode: 1 | 2 | 3}.","type":"La opción \'type\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'type\'. Valores = geojson | kml | topojson.","layer_name":"La opción \'layerName\' no ha sido establecida. Cuando la opción \'url\' es usada el plugin necesita la opción \'layerName\'.","attribution_obsolete":"Mensaje para el desarrollador: M.plugin.Attributions ha quedado obsoleto, utilice en su lugar el control Attributions"},"attribution":"atribución","tooltip":"Reconocimientos"}');var N={en:I,es:x},T=function(t){var e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e="es","function"==typeof M.language.getLang&&(e=M.language.getLang()),e),i=function(t){return"es"===t||"en"===t?N[t]:M.language.getTranslation(t).attributions}(n),s="";return M.utils.isNullOrEmpty(i)?console.warn("The translation '".concat(n,"' has not been defined.")):s=t.split(".").reduce((function(t,e){return t[e]}),i),s};function R(t){return R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},R(t)}function w(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,O(i.key),i)}}function O(t){var e=function(t,e){if("object"!=R(t)||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,"string");if("object"!=R(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==R(e)?e:e+""}function L(t,e,n){return e=C(e),function(t,e){if(e&&("object"==R(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,b()?Reflect.construct(e,n||[],C(t).constructor):e.apply(t,n))}function b(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(b=function(){return!!t})()}function C(t){return C=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},C(t)}function v(t,e){return v=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},v(t,e)}var S=function(t){function e(t,n){var i;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),M.utils.isUndefined(y)&&M.exception(T("exception.impl")),(i=L(this,e,[new y,"Attributions"])).position=t,i.closePanel=n,i}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&v(t,e)}(e,M.Control),n=e,(i=[{key:"createView",value:function(t){var e=this;return this.map=t,console.warn(T("exception.attribution_obsolete")),new Promise((function(t,n){var i=M.template.compileSync(E(),{vars:{icon:"BR"===e.position||"TR"===e.position?"g-cartografia-flecha-derecha":"g-cartografia-flecha-izquierda"}});i.querySelector("#close-button").addEventListener("click",(function(){return e.closePanel()})),e.html_=i,t(i)}))}},{key:"equals",value:function(t){return t instanceof e}},{key:"destroy",value:function(){this.getImpl().destroy()}}])&&w(n.prototype,i),Object.defineProperty(n,"prototype",{writable:!1}),n;var n,i}();function P(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class A{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class D extends Error{constructor(t){super(t),this.name=Object.keys({Exception:D})[0]}toString(){return this.message}}class F extends D{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:F})[0]}}class Y{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function G(){}function q(){}function B(){}G.NaN=NaN,G.isNaN=t=>Number.isNaN(t),G.isInfinite=t=>!Number.isFinite(t),G.MAX_VALUE=Number.MAX_VALUE,G.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,G.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);G.doubleToLongBits=function(i){e[0]=i;let s=0|n[0],r=0|n[1];return(r&t)===t&&1048575&r&&0!==s&&(s=0,r=2146959360),new Y(r,s)},G.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,i=function(){for(let i=53;i>0;i--){const s=n(2,i)-1;if(e(t(s))+1===i)return s}return 0}();G.doubleToLongBits=function(s){let r,o,l,a,c,h,u,g,d;if(s<0||1/s===Number.NEGATIVE_INFINITY?(h=1<<31,s=-s):h=0,0===s)return d=0,g=h,new Y(g,d);if(s===1/0)return d=0,g=2146435072|h,new Y(g,d);if(s!=s)return d=0,g=2146959360,new Y(g,d);if(a=0,d=0,r=e(s),r>1)if(r<=i)a=e(t(r)),a<=20?(d=0,g=r<<20-a&1048575):(l=a-20,o=n(2,l),d=r%o<<32-l,g=r/o&1048575);else for(l=r,d=0;o=l/2,l=e(o),0!==l;)a++,d>>>=1,d|=(1&g)<<31,g>>>=1,o!==l&&(g|=524288);if(u=a+1023,c=0===r,r=s-r,a<52&&0!==r)for(l=0;;){if(o=2*r,o>=1?(r=o-1,c?(u--,c=!1):(l<<=1,l|=1,a++)):(r=o,c?0==--u&&(a++,c=!1):(l<<=1,a++)),20===a)g|=l,l=0;else if(52===a){d|=l;break}if(1===o){a<20?g|=l<<20-a:a<52&&(d|=l<<52-a);break}}return g|=u<<20,g|=h,new Y(g,d)},G.longBitsToDouble=function(t){let e,i,s,r;const o=t.high,l=t.low,a=o&1<<31?-1:1;for(s=((2146435072&o)>>20)-1023,r=0,i=1<<19,e=1;e<=20;e++)o&i&&(r+=n(2,-e)),i>>>=1;for(i=1<<31,e=21;e<=52;e++)l&i&&(r+=n(2,-e)),i>>>=1;if(-1023===s){if(0===r)return 0*a;s=-1022}else{if(1024===s)return 0===r?a/0:NaN;r+=1}return a*r*n(2,s)}}();class U extends D{constructor(t){super(t),this.name=Object.keys({RuntimeException:U})[0]}}class X extends U{constructor(){super(),X.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)U.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];U.constructor_.call(this,t)}}}class z{static isTrue(){if(1===arguments.length){const t=arguments[0];z.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new X:new X(t)}}static shouldNeverReachHere(){if(0===arguments.length)z.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new X("Should never reach here"+(null!==t?": "+t:""))}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];z.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new X("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}function k(){}function j(){}const V=new ArrayBuffer(8),Z=new Float64Array(V),W=new Int32Array(V);class H{constructor(){H.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)H.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];H.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];H.constructor_.call(this,t,e,H.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return Z[0]=t,W[0]^W[1]}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],e=arguments[1];return!!A.equalsWithTolerance(this.x,t.x,e)&&!!A.equalsWithTolerance(this.y,t.y,e)}}setM(t){throw new F("Invalid ordinate index: "+H.M)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||G.isNaN(this.getZ())&&G.isNaN(t.getZ()))}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}copy(){return new H(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,i=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+i*i)}getY(){return this.y}getM(){return G.NaN}setOrdinate(t,e){switch(t){case H.X:this.x=e;break;case H.Y:this.y=e;break;case H.Z:this.setZ(e);break;default:throw new F("Invalid ordinate index: "+t)}}getZ(){return this.z}getOrdinate(t){switch(t){case H.X:return this.x;case H.Y:return this.y;case H.Z:return this.getZ()}throw new F("Invalid ordinate index: "+t)}equals(t){return t instanceof H&&this.equals2D(t)}equalInZ(t,e){return A.equalsWithTolerance(this.getZ(),t.getZ(),e)}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return z.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+H.hashCode(this.x),t=37*t+H.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[q,k,B]}}class K{constructor(){K.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)K.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new F("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:G.isNaN(t)?G.isNaN(e)?0:-1:G.isNaN(e)?1:0}compare(t,e){const n=K.compare(t.x,e.x);if(0!==n)return n;const i=K.compare(t.y,e.y);return 0!==i?i:this._dimensionsToTest<=2?0:K.compare(t.getZ(),e.getZ())}get interfaces_(){return[j]}}H.DimensionalComparator=K,H.NULL_ORDINATE=G.NaN,H.X=0,H.Y=1,H.Z=2,H.M=3;class J{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const i=new H;t.getCoordinate(0,i);let s=i.x,r=i.y;for(let o=1;o<e;o++){t.getCoordinate(o,i);const e=i.x,l=i.y,a=e-s,c=l-r;n+=Math.sqrt(a*a+c*c),s=e,r=l}return n}}class Q{filter(t){}}class $ extends D{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:$})[0]}}class tt{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class et extends D{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:et})[0]}}class nt extends tt{get(){}set(){}isEmpty(){}}class it extends D{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:it})[0]}}class st extends nt{constructor(t){super(),this.array=[],t instanceof tt&&this.addAll(t)}get interfaces_(){return[nt,tt]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new rt(this)}get(t){if(t<0||t>=this.size())throw new et;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class rt{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new it;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class ot extends st{constructor(){super(),ot.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&P(arguments[0],tt)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}toCoordinateArray(){if(0===arguments.length)return this.toArray(ot.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(ot.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof H&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(t))return null;super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof H){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0&&this.get(t-1).equals2D(e))return null;if(t<n&&this.get(t).equals2D(e))return null}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=1;n>i&&(s=-1);for(let r=n;r!==i;r+=s)this.add(t[r],e);return!0}}}ot.coordArrayType=new Array(0).fill(null);class lt extends H{constructor(){super(),lt.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)H.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof lt){const t=arguments[0];H.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof H){const t=arguments[0];H.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];H.constructor_.call(this,t,e,H.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case lt.X:this.x=e;break;case lt.Y:this.y=e;break;default:throw new F("Invalid ordinate index: "+t)}}setZ(t){throw new F("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new lt(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}getZ(){return H.NULL_ORDINATE}getOrdinate(t){switch(t){case lt.X:return this.x;case lt.Y:return this.y}throw new F("Invalid ordinate index: "+t)}}lt.X=0,lt.Y=1,lt.Z=-1,lt.M=-1;class at extends H{constructor(){super(),at.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)H.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof at){const t=arguments[0];H.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof H){const t=arguments[0];H.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];H.constructor_.call(this,t,e,H.NULL_ORDINATE),this._m=n}}setM(t){this._m=t}setZ(t){throw new F("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new at(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case at.X:this.x=e;break;case at.Y:this.y=e;break;case at.M:this._m=e;break;default:throw new F("Invalid ordinate index: "+t)}}getZ(){return H.NULL_ORDINATE}getOrdinate(t){switch(t){case at.X:return this.x;case at.Y:return this.y;case at.M:return this._m}throw new F("Invalid ordinate index: "+t)}}at.X=0,at.Y=1,at.Z=-1,at.M=2;class ct extends H{constructor(){super(),ct.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)H.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof ct){const t=arguments[0];H.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof H){const t=arguments[0];H.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];H.constructor_.call(this,t,e,n),this._m=i}}setM(t){this._m=t}getOrdinate(t){switch(t){case H.X:return this.x;case H.Y:return this.y;case H.Z:return this.getZ();case H.M:return this.getM()}throw new F("Invalid ordinate index: "+t)}copy(){return new ct(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}getM(){return this._m}setOrdinate(t,e){switch(t){case H.X:this.x=e;break;case H.Y:this.y=e;break;case H.Z:this.z=e;break;case H.M:this._m=e;break;default:throw new F("Invalid ordinate index: "+t)}}}class ht{static measures(t){return t instanceof lt?0:t instanceof at||t instanceof ct?1:0}static create(){if(1===arguments.length){const t=arguments[0];return ht.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new lt:3===t&&0===e?new H:3===t&&1===e?new at:4===t&&1===e?new ct:new H}}static dimension(t){return t instanceof lt?2:t instanceof at?3:t instanceof ct?4:3}}class ut{static log10(t){const e=Math.log(t);return G.isInfinite(e)||G.isNaN(e)?e:e/ut.LOG_10}static min(t,e,n,i){let s=t;return e<s&&(s=e),n<s&&(s=n),i<s&&(s=i),s}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static average(t,e){return(t+e)/2}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let i=arguments[0];return t>i&&(i=t),e>i&&(i=e),n>i&&(i=n),i}}}ut.LOG_10=Math.log(10);class gt{static arraycopy(t,e,n,i,s){let r=0;for(let o=e;o<e+s;o++)n[i+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class dt{constructor(){dt.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof H){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof dt){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.init(t,e,n,i)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];let s=Math.min(n.x,i.x),r=Math.max(n.x,i.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r||l<s||(s=Math.min(n.y,i.y),r=Math.max(n.y,i.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),o>r||l<s))}}getArea(){return this.getWidth()*this.getHeight()}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof H){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof dt){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new dt(this)}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof dt){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof H){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}hashCode(){let t=17;return t=37*t+H.hashCode(this._minx),t=37*t+H.hashCode(this._maxx),t=37*t+H.hashCode(this._miny),t=37*t+H.hashCode(this._maxy),t}equals(t){if(!(t instanceof dt))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new dt;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,s=this._maxy<t._maxy?this._maxy:t._maxy;return new dt(e,i,n,s)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof H){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof dt){const t=arguments[0];return!this.isNull()&&!t.isNull()&&t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy}}intersects(){if(1===arguments.length){if(arguments[0]instanceof dt){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof H){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof H&&arguments[1]instanceof H){const t=arguments[0],e=arguments[1];return!this.isNull()&&(!((t.x<e.x?t.x:e.x)>this._maxx)&&(!((t.x>e.x?t.x:e.x)<this._minx)&&(!((t.y<e.y?t.y:e.y)>this._maxy)&&!((t.y>e.y?t.y:e.y)<this._miny))))}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}centre(){return this.isNull()?null:new H((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof H){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof dt){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<i?(this._miny=n,this._maxy=i):(this._miny=i,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}get interfaces_(){return[q,B]}}class pt{static scroll(t,e){const n=pt.indexOf(e,t);if(n<0)return null;const i=new Array(t.length).fill(null);gt.arraycopy(t,n,i,0,t.length-n),gt.arraycopy(t,0,i,t.length-n,n),gt.arraycopy(i,0,t,0,t.length)}static removeRepeatedPoints(t){return pt.hasRepeatedPoints(t)?new ot(t,!1).toCoordinateArray():t}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++){const n=t[i];t[i]=t[e-i],t[e-i]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let i=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[i++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4];for(let r=0;r<s;r++)n[i+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const i=t[n],s=e[t.length-n-1];if(0!==i.compareTo(s))return!1}return!0}static envelope(t){const e=new dt;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static extract(t,e,n){e=ut.clamp(e,0,t.length);let i=(n=ut.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);const s=new Array(i).fill(null);if(0===i)return s;let r=0;for(let i=e;i<=n;i++)s[r++]=t[i];return s}static isRing(t){return!(t.length<4||!t[0].equals2D(t[t.length-1]))}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(pt.indexOf(i,e)<0)return i}return null}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(0!==n.compare(t[i],e[i]))return!1;return!0}}static intersection(t,e){const n=new ot;for(let i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,ht.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static toCoordinateArray(t){return t.toArray(pt.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,ht.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}}pt.ForwardComparator=class{compare(t,e){const n=t,i=e;return pt.compare(n,i)}get interfaces_(){return[j]}},pt.BidirectionalComparator=class{compare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=pt.compare(n,i);return pt.isEqualReversed(n,i)?0:s}OLDcompare(t,e){const n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;const s=pt.increasingDirection(n),r=pt.increasingDirection(i);let o=s>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(i[l]);if(0!==t)return t;o+=s,l+=r}return 0}get interfaces_(){return[j]}},pt.coordArrayType=new Array(0).fill(null);class ft{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class _t{static toDimensionSymbol(t){switch(t){case _t.FALSE:return _t.SYM_FALSE;case _t.TRUE:return _t.SYM_TRUE;case _t.DONTCARE:return _t.SYM_DONTCARE;case _t.P:return _t.SYM_P;case _t.L:return _t.SYM_L;case _t.A:return _t.SYM_A}throw new F("Unknown dimension value: "+t)}static toDimensionValue(t){switch(ft.toUpperCase(t)){case _t.SYM_FALSE:return _t.FALSE;case _t.SYM_TRUE:return _t.TRUE;case _t.SYM_DONTCARE:return _t.DONTCARE;case _t.SYM_P:return _t.P;case _t.SYM_L:return _t.L;case _t.SYM_A:return _t.A}throw new F("Unknown dimension symbol: "+t)}}_t.P=0,_t.L=1,_t.A=2,_t.FALSE=-1,_t.TRUE=-2,_t.DONTCARE=-3,_t.SYM_FALSE="F",_t.SYM_TRUE="T",_t.SYM_DONTCARE="*",_t.SYM_P="0",_t.SYM_L="1",_t.SYM_A="2";class yt{constructor(){yt.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===yt.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(yt.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===yt.TYPECODE_GEOMETRYCOLLECTION)throw new F("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new dt(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),i=e.iterator();for(;n.hasNext()&&i.hasNext();){const t=n.next(),e=i.next(),s=t.compareTo(e);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[k,q,B]}getClass(){return yt}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}yt.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},yt.TYPECODE_POINT=0,yt.TYPECODE_MULTIPOINT=1,yt.TYPECODE_LINESTRING=2,yt.TYPECODE_LINEARRING=3,yt.TYPECODE_MULTILINESTRING=4,yt.TYPECODE_POLYGON=5,yt.TYPECODE_MULTIPOLYGON=6,yt.TYPECODE_GEOMETRYCOLLECTION=7,yt.TYPENAME_POINT="Point",yt.TYPENAME_MULTIPOINT="MultiPoint",yt.TYPENAME_LINESTRING="LineString",yt.TYPENAME_LINEARRING="LinearRing",yt.TYPENAME_MULTILINESTRING="MultiLineString",yt.TYPENAME_POLYGON="Polygon",yt.TYPENAME_MULTIPOLYGON="MultiPolygon",yt.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",yt.geometryChangedFilter={get interfaces_(){return[Q]},filter(t){t.geometryChangedAction()}};class mt{filter(t){}}class Et{}class It{getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return G.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):G.NaN}size(){}getOrdinate(t,e){}get interfaces_(){return[k]}}It.X=0,It.Y=1,It.Z=2,It.M=3;class xt{static scroll(){if(2===arguments.length){if(P(arguments[0],It)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];xt.scroll(t,e,xt.isRing(t))}else if(P(arguments[0],It)&&arguments[1]instanceof H){const t=arguments[0],e=arguments[1],n=xt.indexOf(e,t);if(n<=0)return null;xt.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const i=t.copy(),s=n?t.size()-1:t.size();for(let n=0;n<s;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,i.getOrdinate((e+n)%s,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(s,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const i=Math.min(t.getDimension(),e.getDimension());for(let s=0;s<n;s++)for(let n=0;n<i;n++){const i=t.getOrdinate(s,n),r=e.getOrdinate(s,n);if(!(t.getOrdinate(s,n)===e.getOrdinate(s,n)||G.isNaN(i)&&G.isNaN(r)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return xt.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,i=null;for(let s=arguments[1];s<=e;s++){const e=t.getCoordinate(s);(null===i||i.compareTo(e)>0)&&(i=e,n=s)}return n}}static extend(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();if(xt.copy(e,0,i,0,s),s>0)for(let t=s;t<n;t++)xt.copy(e,s-1,i,t,1);return i}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let i=0;i<=n;i++)xt.swap(t,i,e-i)}static ensureValidRing(t,e){const n=e.size();return 0===n?e:n<=3?xt.createClosedRing(t,e,4):e.getOrdinate(0,It.X)===e.getOrdinate(n-1,It.X)&&e.getOrdinate(0,It.Y)===e.getOrdinate(n-1,It.Y)?e:xt.createClosedRing(t,e,n+1)}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const i=t.getCoordinate(n);(null===e||e.compareTo(i)>0)&&(e=i)}return e}static copyCoord(t,e,n,i){const s=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<s;r++)n.setOrdinate(i,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&t.getOrdinate(0,It.X)===t.getOrdinate(e-1,It.X)&&t.getOrdinate(0,It.Y)===t.getOrdinate(e-1,It.Y)}static swap(t,e,n){if(e===n)return null;for(let i=0;i<t.getDimension();i++){const s=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,s)}}static copy(t,e,n,i,s){for(let r=0;r<s;r++)xt.copyCoord(t,e+r,n,i+r)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,It.X)&&t.y===e.getOrdinate(n,It.Y))return n;return-1}static createClosedRing(t,e,n){const i=t.create(n,e.getDimension()),s=e.size();xt.copy(e,0,i,0,s);for(let t=s;t<n;t++)xt.copy(e,0,i,t,1);return i}}class Nt{filter(t){}}class Tt{filter(t,e){}isGeometryChanged(){}isDone(){}}class Rt extends yt{constructor(){super(),Rt.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];yt.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new dt:this._points.expandEnvelope(new dt)}isRing(){return this.isClosed()&&pt.isRing(this.getCoordinates())}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new Rt(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return xt.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return yt.TYPECODE_LINESTRING}getDimension(){return 1}getBoundary(){throw new $}isEquivalentClass(t){return t instanceof Rt}getCoordinateSequence(){return this._points}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();xt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?_t.FALSE:0}getLength(){return J.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(P(arguments[0],mt)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(P(arguments[0],Tt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else(P(arguments[0],Nt)||P(arguments[0],Q))&&arguments[0].filter(this)}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return yt.TYPENAME_LINESTRING}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new F("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}get interfaces_(){return[Et]}}class wt extends Rt{constructor(){super(),wt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Rt.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new wt(this._points.copy(),this._factory)}getBoundaryDimension(){return _t.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return xt.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return yt.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new F("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<wt.MINIMUM_VALID_SIZE)throw new F("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return yt.TYPENAME_LINEARRING}}wt.MINIMUM_VALID_SIZE=4;class Ot{create(){if(1===arguments.length)arguments[0]instanceof Array||P(arguments[0],It);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class Lt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class bt{constructor(){bt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];bt.constructor_.call(this,t,pt.dimension(t),pt.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new H}else if(P(arguments[0],It)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];bt.constructor_.call(this,t,e,pt.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=ht.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return ht.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new bt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new Lt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getM(t){return this.hasM()?this._coordinates[t].getM():G.NaN}setOrdinate(t,e,n){switch(e){case It.X:this._coordinates[t].x=n;break;case It.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():G.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case It.X:return this._coordinates[t].x;case It.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}get interfaces_(){return[It,B]}}class Ct{static instance(){return Ct.instanceObject}readResolve(){return Ct.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array)return new bt(arguments[0]);if(P(arguments[0],It))return new bt(arguments[0])}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new bt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new bt(arguments[0],e+t,t)}}}get interfaces_(){return[Ot,B]}}Ct.instanceObject=new Ct;class vt extends tt{contains(){}}class St extends vt{}class Pt extends St{constructor(t){super(),this.array=[],t instanceof tt&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++)if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t);return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new $}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new Mt(this.array)}}class Mt{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new it;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new $}}class At{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new st;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class Dt extends yt{constructor(){super(),Dt.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(yt.constructor_.call(this,e),null===t&&(t=[]),yt.hasNullElements(t))throw new F("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new dt;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const i=this._geometries[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Dt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this._geometries.length,e=new st(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return yt.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=_t.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getNumGeometries(){return this._geometries.length}getBoundary(){return yt.checkNotGeometryCollection(this),z.shouldNeverReachHere(),null}getGeometryType(){return yt.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();At.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=_t.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new Pt(At.asList(this._geometries)),n=new Pt(At.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),i=e.getNumGeometries();let s=0;for(;s<n&&s<i;){const n=this.getGeometryN(s),i=e.getGeometryN(s),r=n.compareToSameClass(i,t);if(0!==r)return r;s++}return s<n?1:s<i?-1:0}}apply(){if(P(arguments[0],mt)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(P(arguments[0],Tt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(P(arguments[0],Nt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(P(arguments[0],Q)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}}class Ft{}class Yt extends Dt{constructor(){super(),Yt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Yt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return yt.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new st;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return yt.TYPENAME_MULTIPOLYGON}get interfaces_(){return[Ft]}}class Gt{get(){}put(){}size(){}values(){}entrySet(){}}class qt extends vt{constructor(t){super(),this.map=new Map,t instanceof tt&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new $}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new Bt(this.map)}[Symbol.iterator](){return this.map}}class Bt{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new it;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new $}}class Ut extends Gt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new st,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new qt;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class Xt{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new Xt(t)}}class zt{constructor(){zt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=zt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof kt){const t=arguments[0];this._modelType=t,t===zt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=zt.FIXED,this.setScale(t)}else if(arguments[0]instanceof zt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof zt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return Xt.compare(n,i)}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===zt.FLOATING?t="Floating":this._modelType===zt.FLOATING_SINGLE?t="Floating-Single":this._modelType===zt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];return G.isNaN(t)||this._modelType===zt.FLOATING_SINGLE?t:this._modelType===zt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof H){const t=arguments[0];if(this._modelType===zt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===zt.FLOATING?t=16:this._modelType===zt.FLOATING_SINGLE?t=6:this._modelType===zt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getScale(){return this._scale}isFloating(){return this._modelType===zt.FLOATING||this._modelType===zt.FLOATING_SINGLE}get interfaces_(){return[B,q]}}class kt{constructor(){kt.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,kt.nameToTypeMap.put(t,this)}readResolve(){return kt.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[B]}}kt.nameToTypeMap=new Ut,zt.Type=kt,zt.FIXED=new kt("FIXED"),zt.FLOATING=new kt("FLOATING"),zt.FLOATING_SINGLE=new kt("FLOATING SINGLE"),zt.maximumPreciseValue=9007199254740992;class jt extends Dt{constructor(){super(),jt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new jt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?_t.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return yt.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new $}getGeometryType(){return yt.TYPENAME_MULTILINESTRING}get interfaces_(){return[Et]}}class Vt{}class Zt extends D{constructor(t){super(t),this.name=Object.keys({IllegalStateException:Zt})[0]}}class Wt extends yt{constructor(){super(),Wt.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];yt.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new dt;const t=new dt;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new Wt(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return yt.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new Zt("getX called on empty Point");return this.getCoordinate().x}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return yt.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new Zt("getY called on empty Point");return this.getCoordinate().y}isSimple(){return!0}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return _t.FALSE}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(P(arguments[0],mt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(P(arguments[0],Tt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else(P(arguments[0],Nt)||P(arguments[0],Q))&&arguments[0].filter(this)}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),z.isTrue(t.size()<=1),this._coordinates=t}get interfaces_(){return[Vt]}}class Ht{static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let i=1;i<t.length-1;i++){const s=t[i].x-n,r=t[i+1].y;e+=s*(t[i-1].y-r)}return e/2}if(P(arguments[0],It)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new H,i=new H,s=new H;t.getCoordinate(0,i),t.getCoordinate(1,s);const r=i.x;s.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=i.y,i.x=s.x,i.y=s.y,t.getCoordinate(l+1,s),s.x-=r,o+=i.x*(n.y-s.y);return o/2}}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(Ht.ofRingSigned(t))}if(P(arguments[0],It)){const t=arguments[0];return Math.abs(Ht.ofRingSigned(t))}}}class Kt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this,Jt.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];return Jt.determinant(Jt.valueOf(t),Jt.valueOf(e),Jt.valueOf(n),Jt.valueOf(i))}if(arguments[3]instanceof Jt&&arguments[2]instanceof Jt&&arguments[0]instanceof Jt&&arguments[1]instanceof Jt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return Jt.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return Jt.parse(t)}if("number"==typeof arguments[0])return new Jt(arguments[0])}static sqrt(t){return Jt.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;ft.isWhitespace(t.charAt(e));)e++;let i=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(i=!0))}const s=new Jt;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,ft.isDigit(n)){const t=n-"0";s.selfMultiply(Jt.TEN),s.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=Xt.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=s;a||(o=r);const h=r-o-l;if(0===h)c=s;else if(h>0){const t=Jt.TEN.pow(h);c=s.divide(t)}else if(h<0){const t=Jt.TEN.pow(-h);c=s.multiply(t)}return i?c.negate():c}static createNaN(){return new Jt(G.NaN,G.NaN)}static copy(t){return new Jt(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i}static stringOfChar(t,e){const n=new Kt;for(let i=0;i<e;i++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),i=Jt.magnitude(n._hi);const s=Jt.TEN.pow(i);n=n.divide(s),n.gt(Jt.TEN)?(n=n.divide(Jt.TEN),i+=1):n.lt(Jt.ONE)&&(n=n.multiply(Jt.TEN),i-=1);const r=i+1,o=new Kt,l=Jt.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const i=Math.trunc(n._hi);if(i<0)break;let s=!1,a=0;i>9?(s=!0,a="9"):a="0"+i,o.append(a),n=n.subtract(Jt.valueOf(i)).multiply(Jt.TEN),s&&n.selfAdd(Jt.TEN);let c=!0;const h=Jt.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=i,o.toString()}sqr(){return this.multiply(this)}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}setValue(){if(arguments[0]instanceof Jt){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}multiply(){if(arguments[0]instanceof Jt){const t=arguments[0];return t.isNaN()?Jt.createNaN():Jt.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return G.isNaN(t)?Jt.createNaN():Jt.copy(this).selfMultiply(t,0)}}isNaN(){return G.isNaN(this._hi)}reciprocal(){let t=null,e=null,n=null,i=null,s=null,r=null,o=null,l=null;s=1/this._hi,r=Jt.SPLIT*s,t=r-s,l=Jt.SPLIT*this._hi,t=r-t,e=s-t,n=l-this._hi,o=s*this._hi,n=l-n,i=this._hi-n,l=t*n-o+t*i+e*n+e*i,r=(1-o-l-s*this._lo)/this._hi;const a=s+r;return new Jt(a,s-a+r)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof Jt){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof Jt){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof Jt){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof Jt){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=Jt.SPLIT*o,n=l-o,c=Jt.SPLIT*t,n=l-n,i=o-n,s=c-t,a=o*t,s=c-s,r=t-s,c=n*s-a+n*r+i*s+i*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof Jt){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null,l=null,a=null;return r=this._hi/t._hi,o=Jt.SPLIT*r,e=o-r,a=Jt.SPLIT*t._hi,e=o-e,n=r-e,i=a-t._hi,l=r*t._hi,i=a-i,s=t._hi-i,a=e*i-l+e*s+n*i+n*s,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o,new Jt(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return G.isNaN(t)?Jt.createNaN():Jt.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return Jt.valueOf(1);let e=new Jt(this),n=Jt.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return Jt.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new Jt(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){return this.isNaN()?this:this.add(.5).floor()}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return Jt.valueOf(0);if(this.isNegative())return Jt.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=Jt.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof Jt){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,i=null,s=null,r=null,o=null;return i=this._hi+t,r=i-this._hi,s=i-r,s=t-r+(this._hi-s),o=s+this._lo,e=i+o,n=o+(i-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,s=this._lo+e,a=o-this._hi,c=s-this._lo,l=o-a,r=s-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+s,n=o+a,i=a+(o-n),a=r+i;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof Jt){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,i=null,s=null,r=null,o=null,l=null;o=Jt.SPLIT*this._hi,n=o-this._hi,l=Jt.SPLIT*t,n=o-n,i=this._hi-n,s=l-t,o=this._hi*t,s=l-s,r=t-s,l=n*s-o+n*r+i*s+i*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return Jt.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new Jt(t,e)}negate(){return this.isNaN()?this:new Jt(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}intValue(){return Math.trunc(this._hi)}toString(){const t=Jt.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1;let s=n;if("."===n.charAt(0))s="0"+n;else if(i<0)s="0."+Jt.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){const t=i-n.length;s=n+Jt.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+s:s}toSciNotation(){if(this.isZero())return Jt.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=Jt.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new Zt("Found leading zero: "+n);let s="";n.length>1&&(s=n.substring(1));const r=n.charAt(0)+"."+s;return this.isNegative()?"-"+r+i:r+i}abs(){return this.isNaN()?Jt.NaN:this.isNegative()?this.negate():new Jt(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof Jt){const t=arguments[0];return Jt.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return Jt.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof Jt){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?Jt.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[B,q,k]}}Jt.PI=new Jt(3.141592653589793,12246467991473532e-32),Jt.TWO_PI=new Jt(6.283185307179586,24492935982947064e-32),Jt.PI_2=new Jt(1.5707963267948966,6123233995736766e-32),Jt.E=new Jt(2.718281828459045,14456468917292502e-32),Jt.NaN=new Jt(G.NaN,G.NaN),Jt.EPS=123259516440783e-46,Jt.SPLIT=134217729,Jt.MAX_PRINT_DIGITS=32,Jt.TEN=Jt.valueOf(10),Jt.ONE=Jt.valueOf(1),Jt.SCI_NOT_EXPONENT_CHAR="E",Jt.SCI_NOT_ZERO="0.0E0";class Qt{static orientationIndex(t,e,n){const i=Qt.orientationIndexFilter(t,e,n);if(i<=1)return i;const s=Jt.valueOf(e.x).selfAdd(-t.x),r=Jt.valueOf(e.y).selfAdd(-t.y),o=Jt.valueOf(n.x).selfAdd(-e.x),l=Jt.valueOf(n.y).selfAdd(-e.y);return s.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof Jt&&arguments[2]instanceof Jt&&arguments[0]instanceof Jt&&arguments[1]instanceof Jt){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=Jt.valueOf(t),r=Jt.valueOf(e),o=Jt.valueOf(n),l=Jt.valueOf(i);return s.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,i){const s=new Jt(t.y).selfSubtract(e.y),r=new Jt(e.x).selfSubtract(t.x),o=new Jt(t.x).selfMultiply(e.y).selfSubtract(new Jt(e.x).selfMultiply(t.y)),l=new Jt(n.y).selfSubtract(i.y),a=new Jt(i.x).selfSubtract(n.x),c=new Jt(n.x).selfMultiply(i.y).selfSubtract(new Jt(i.x).selfMultiply(n.y)),h=r.multiply(c).selfSubtract(a.multiply(o)),u=l.multiply(o).selfSubtract(s.multiply(c)),g=s.multiply(a).selfSubtract(l.multiply(r)),d=h.selfDivide(g).doubleValue(),p=u.selfDivide(g).doubleValue();return G.isNaN(d)||G.isInfinite(d)||G.isNaN(p)||G.isInfinite(p)?null:new H(d,p)}static orientationIndexFilter(t,e,n){let i=null;const s=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=s-r;if(s>0){if(r<=0)return Qt.signum(o);i=s+r}else{if(!(s<0))return Qt.signum(o);if(r>=0)return Qt.signum(o);i=-s-r}const l=Qt.DP_SAFE_EPSILON*i;return o>=l||-o>=l?Qt.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}Qt.DP_SAFE_EPSILON=1e-15;class $t{static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new F("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let s=i;do{s-=1,s<0&&(s=e)}while(t[s].equals2D(n)&&s!==i);let r=i;do{r=(r+1)%e}while(t[r].equals2D(n)&&r!==i);const o=t[s],l=t[r];if(o.equals2D(n)||l.equals2D(n)||o.equals2D(l))return!1;const a=$t.index(o,n,l);let c=null;return c=0===a?o.x>l.x:a>0,c}if(P(arguments[0],It)){const t=arguments[0],e=t.size()-1;if(e<3)throw new F("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let s=null,r=i;do{r-=1,r<0&&(r=e),s=t.getCoordinate(r)}while(s.equals2D(n)&&r!==i);let o=null,l=i;do{l=(l+1)%e,o=t.getCoordinate(l)}while(o.equals2D(n)&&l!==i);if(s.equals2D(n)||o.equals2D(n)||s.equals2D(o))return!1;const a=$t.index(s,n,o);let c=null;return c=0===a?s.x>o.x:a>0,c}}static index(t,e,n){return Qt.orientationIndex(t,e,n)}}$t.CLOCKWISE=-1,$t.RIGHT=$t.CLOCKWISE,$t.COUNTERCLOCKWISE=1,$t.LEFT=$t.COUNTERCLOCKWISE,$t.COLLINEAR=0,$t.STRAIGHT=$t.COLLINEAR;class te extends yt{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(yt.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),yt.hasNullElements(e))throw new F("holes must not contain null elements");if(t.isEmpty()&&yt.hasNonEmptyElements(e))throw new F("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let i=0;i<n.length;i++)e++,t[e]=n[i];for(let n=0;n<this._holes.length;n++){const i=this._holes[n].getCoordinates();for(let n=0;n<i.length;n++)e++,t[e]=i[n]}return t}getArea(){let t=0;t+=Ht.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=Ht.ofRing(this._holes[e].getCoordinateSequence());return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,i=this._shell,s=n._shell;if(!i.equalsExact(s,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return yt.TYPECODE_POLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return yt.TYPENAME_POLYGON}getExteriorRing(){return this._shell}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new te(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;const s=t.getY(n);if(s!==e.getMinY()&&s!==e.getMaxY())return!1}let n=t.getX(0),i=t.getY(0);for(let e=1;e<=4;e++){const s=t.getX(e),r=t.getY(e);if(s!==n==(r!==i))return!1;n=s,i=r}return!0}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);At.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),i=xt.minCoordinateIndex(n,0,n.size()-2);xt.scroll(n,i,!0),$t.isCCW(n)===e&&xt.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,i=e._shell,s=n.compareToSameClass(i,t);if(0!==s)return s;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),i=e.getInteriorRingN(l),s=n.compareToSameClass(i,t);if(0!==s)return s;l++}return l<r?1:l<o?-1:0}}apply(){if(P(arguments[0],mt)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(P(arguments[0],Tt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(P(arguments[0],Nt))arguments[0].filter(this);else if(P(arguments[0],Q)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[Ft]}}class ee extends Dt{constructor(){super(),ee.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,t,e)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof yt){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getTypeCode(){return yt.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return yt.TYPENAME_MULTIPOINT}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ee(t,this._factory)}isValid(){return!0}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return _t.FALSE}get interfaces_(){return[Vt]}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)ne.constructor_.call(this,new zt,0);else if(1===arguments.length){if(P(arguments[0],Ot)){const t=arguments[0];ne.constructor_.call(this,new zt,0,t)}else if(arguments[0]instanceof zt){const t=arguments[0];ne.constructor_.call(this,t,0,ne.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ne.constructor_.call(this,t,e,ne.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Ct.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new F("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new H(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new H(t.getMinX(),t.getMinY()),new H(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new H(t.getMinX(),t.getMinY()),new H(t.getMinX(),t.getMaxY()),new H(t.getMaxX(),t.getMaxY()),new H(t.getMaxX(),t.getMinY()),new H(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(P(arguments[0],It))return new Rt(arguments[0],this)}}createMultiLineString(){return 0===arguments.length?new jt(null,this):1===arguments.length?new jt(arguments[0],this):void 0}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(P(arguments[0],It)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof wt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length)return new te(arguments[0],arguments[1],this)}getSRID(){return this._SRID}createGeometryCollection(){return 0===arguments.length?new Dt(null,this):1===arguments.length?new Dt(arguments[0],this):void 0}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(P(arguments[0],It))return new wt(arguments[0],this)}}createMultiPolygon(){return 0===arguments.length?new Yt(null,this):1===arguments.length?new Yt(arguments[0],this):void 0}createMultiPoint(){if(0===arguments.length)return new ee(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new ee(arguments[0],this);if(P(arguments[0],It)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const i=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());xt.copy(t,n,i,0,1),e[n]=this.createPoint(i)}return this.createMultiPoint(e)}}}buildGeometry(t){let e=null,n=!1,i=!1;for(let s=t.iterator();s.hasNext();){const t=s.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof Dt&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ne.toGeometryArray(t));const s=t.iterator().next();if(t.size()>1){if(s instanceof te)return this.createMultiPolygon(ne.toPolygonArray(t));if(s instanceof Rt)return this.createMultiLineString(ne.toLineStringArray(t));if(s instanceof Wt)return this.createMultiPoint(ne.toPointArray(t));z.shouldNeverReachHere("Unhandled geometry type: "+s.getGeometryType())}return s}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof H){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(P(arguments[0],It))return new Wt(arguments[0],this)}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}get interfaces_(){return[B]}}const ie=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class se{constructor(t){this.geometryFactory=t||new ne}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!re[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==ie.indexOf(n)?re[n].call(this,e.coordinates):"GeometryCollection"===n?re[n].call(this,e.geometries):re[n].call(this,e)}write(t){const e=t.getGeometryType();if(!oe[e])throw new Error("Geometry is not supported");return oe[e].call(this,t)}}const re={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!re[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=re.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(new H(...i))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new H(t[0],t[1]),new H(t[2],t[1]),new H(t[2],t[3]),new H(t[0],t[3]),new H(t[0],t[1])])},Point:function(t){const e=new H(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(re.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=re.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(re.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=re.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),i=[];for(let e=1;e<t.length;++e){const n=t[e],s=re.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(s);i.push(r)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(re.Polygon.call(this,i))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},oe={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:oe.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=oe.Point.call(this,i);e.push(s.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const i=n[t];e.push(oe.coordinate.call(this,i))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=oe.LineString.call(this,i);e.push(s.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=oe.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const i=t._holes[n],s=oe.LineString.call(this,i);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=oe.Polygon.call(this,i);e.push(s.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const i=t._geometries[n],s=i.getGeometryType();e.push(oe[s].call(this,i))}return{type:"GeometryCollection",geometries:e}}};class le{constructor(t){this.parser=new se(t||new ne)}read(t){return this.parser.read(t)}}const ae="XY",ce={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},he="EMPTY",ue={};for(const t in ce)ue[t]=ce[t].toUpperCase();class ge{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,i=t;if("("==t)n=2;else if(","==t)n=5;else if(")"==t)n=3;else if(this.isNumeric_(t)||"-"==t)n=4,i=this.readNumber_();else if(this.isAlpha_(t))n=1,i=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=6}return{position:e,value:i,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,i=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(i=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!i&&("e"==t||"E"==t)||i&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class de{constructor(t,e){this.lexer_=t,this.token_,this.layout_=ae,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){return this.consume_(),this.parseGeometry_()}parseGeometryLayout_(){let t=ae;const e=this.token_;if(this.isTokenType(1)){const n=e.value;"Z"===n?t="XYZ":"M"===n?t="XYM":"ZM"===n&&(t="XYZM"),t!==ae&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(2)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(5));if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(2)){const t=this.parsePoint_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(2)){const t=this.parsePointList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(2)){const t=this.parseLineStringTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(2)){let t;if(t=2==this.token_.type?this.parsePointTextList_():this.parsePointList_(),this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(2)){const t=this.parseLineStringTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(2)){const t=this.parsePolygonTextList_();if(this.match(3))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(4))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(5);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(5);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(5);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(5);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(1)&&this.token_.value==he;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>t?new H(...t):new H,n=n=>{const i=n.map((n=>t.createLinearRing(n.map(e))));return i.length>1?t.createPolygon(i[0],i.slice(1)):1===i.length?t.createPolygon(i[0]):t.createPolygon()},i=this.token_;if(this.match(1)){const s=i.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==s){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(s){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new H(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const i=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(i)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const i=e.map(n);return t.createMultiPolygon(i)}default:throw new Error("Invalid geometry type: "+s)}}throw new Error(this.formatErrorMessage_())}}function pe(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function fe(t){const e=t.getCoordinates().map((t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e})),n=[];for(let t=0,i=e.length;t<i;++t)n.push(e[t].join(" "));return n.join(", ")}function _e(t){const e=[];e.push("("+fe(t.getExteriorRing())+")");for(let n=0,i=t.getNumInteriorRing();n<i;++n)e.push("("+fe(t.getInteriorRingN(n))+")");return e.join(", ")}const ye={Point:pe,LineString:fe,LinearRing:fe,Polygon:_e,MultiPoint:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+pe(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+fe(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push("("+_e(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,i=t.getNumGeometries();n<i;++n)e.push(me(t.getGeometryN(n)));return e.join(", ")}};function me(t){let e=t.getGeometryType();const n=ye[e];e=e.toUpperCase();const i=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);return i.length>0&&(e+=" "+i),t.isEmpty()?e+" "+he:e+" ("+n(t)+")"}class Ee{constructor(t){this.geometryFactory=t||new ne,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new ge(t);return new de(e,this.geometryFactory).parse()}write(t){return me(t)}}class Ie{constructor(t){this.parser=new Ee(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class xe{static toLocationSymbol(t){switch(t){case xe.EXTERIOR:return"e";case xe.BOUNDARY:return"b";case xe.INTERIOR:return"i";case xe.NONE:return"-"}throw new F("Unknown location value: "+t)}}xe.INTERIOR=0,xe.BOUNDARY=1,xe.EXTERIOR=2,xe.NONE=-1;class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(_t.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Ne.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Ne){const t=arguments[0];Ne.constructor_.call(this),this._matrix[xe.INTERIOR][xe.INTERIOR]=t._matrix[xe.INTERIOR][xe.INTERIOR],this._matrix[xe.INTERIOR][xe.BOUNDARY]=t._matrix[xe.INTERIOR][xe.BOUNDARY],this._matrix[xe.INTERIOR][xe.EXTERIOR]=t._matrix[xe.INTERIOR][xe.EXTERIOR],this._matrix[xe.BOUNDARY][xe.INTERIOR]=t._matrix[xe.BOUNDARY][xe.INTERIOR],this._matrix[xe.BOUNDARY][xe.BOUNDARY]=t._matrix[xe.BOUNDARY][xe.BOUNDARY],this._matrix[xe.BOUNDARY][xe.EXTERIOR]=t._matrix[xe.BOUNDARY][xe.EXTERIOR],this._matrix[xe.EXTERIOR][xe.INTERIOR]=t._matrix[xe.EXTERIOR][xe.INTERIOR],this._matrix[xe.EXTERIOR][xe.BOUNDARY]=t._matrix[xe.EXTERIOR][xe.BOUNDARY],this._matrix[xe.EXTERIOR][xe.EXTERIOR]=t._matrix[xe.EXTERIOR][xe.EXTERIOR]}}static isTrue(t){return t>=0||t===_t.TRUE}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===_t.SYM_DONTCARE||e===_t.SYM_TRUE&&(t>=0||t===_t.TRUE)||e===_t.SYM_FALSE&&t===_t.FALSE||e===_t.SYM_P&&t===_t.P||e===_t.SYM_L&&t===_t.L||e===_t.SYM_A&&t===_t.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Ne(arguments[0]).matches(t)}}isIntersects(){return!this.isDisjoint()}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this._matrix[n][i]=_t.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&this._matrix[xe.EXTERIOR][xe.INTERIOR]===_t.FALSE&&this._matrix[xe.EXTERIOR][xe.BOUNDARY]===_t.FALSE}isWithin(){return Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&this._matrix[xe.INTERIOR][xe.EXTERIOR]===_t.FALSE&&this._matrix[xe.BOUNDARY][xe.EXTERIOR]===_t.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===_t.A&&e===_t.A||t===_t.L&&e===_t.L||t===_t.L&&e===_t.A||t===_t.P&&e===_t.A||t===_t.P&&e===_t.L)&&this._matrix[xe.INTERIOR][xe.INTERIOR]===_t.FALSE&&(Ne.isTrue(this._matrix[xe.INTERIOR][xe.BOUNDARY])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.INTERIOR])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.BOUNDARY]))}isOverlaps(t,e){return t===_t.P&&e===_t.P||t===_t.A&&e===_t.A?Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&Ne.isTrue(this._matrix[xe.INTERIOR][xe.EXTERIOR])&&Ne.isTrue(this._matrix[xe.EXTERIOR][xe.INTERIOR]):t===_t.L&&e===_t.L&&1===this._matrix[xe.INTERIOR][xe.INTERIOR]&&Ne.isTrue(this._matrix[xe.INTERIOR][xe.EXTERIOR])&&Ne.isTrue(this._matrix[xe.EXTERIOR][xe.INTERIOR])}isEquals(t,e){return t===e&&Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&this._matrix[xe.INTERIOR][xe.EXTERIOR]===_t.FALSE&&this._matrix[xe.BOUNDARY][xe.EXTERIOR]===_t.FALSE&&this._matrix[xe.EXTERIOR][xe.INTERIOR]===_t.FALSE&&this._matrix[xe.EXTERIOR][xe.BOUNDARY]===_t.FALSE}matches(t){if(9!==t.length)throw new F("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Ne.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[xe.INTERIOR][xe.INTERIOR]===_t.FALSE&&this._matrix[xe.INTERIOR][xe.BOUNDARY]===_t.FALSE&&this._matrix[xe.BOUNDARY][xe.INTERIOR]===_t.FALSE&&this._matrix[xe.BOUNDARY][xe.BOUNDARY]===_t.FALSE}isCrosses(t,e){return t===_t.P&&e===_t.L||t===_t.P&&e===_t.A||t===_t.L&&e===_t.A?Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&Ne.isTrue(this._matrix[xe.INTERIOR][xe.EXTERIOR]):t===_t.L&&e===_t.P||t===_t.A&&e===_t.P||t===_t.A&&e===_t.L?Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])&&Ne.isTrue(this._matrix[xe.EXTERIOR][xe.INTERIOR]):t===_t.L&&e===_t.L&&0===this._matrix[xe.INTERIOR][xe.INTERIOR]}isCovers(){return(Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])||Ne.isTrue(this._matrix[xe.INTERIOR][xe.BOUNDARY])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.INTERIOR])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.BOUNDARY]))&&this._matrix[xe.EXTERIOR][xe.INTERIOR]===_t.FALSE&&this._matrix[xe.EXTERIOR][xe.BOUNDARY]===_t.FALSE}isCoveredBy(){return(Ne.isTrue(this._matrix[xe.INTERIOR][xe.INTERIOR])||Ne.isTrue(this._matrix[xe.INTERIOR][xe.BOUNDARY])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.INTERIOR])||Ne.isTrue(this._matrix[xe.BOUNDARY][xe.BOUNDARY]))&&this._matrix[xe.INTERIOR][xe.EXTERIOR]===_t.FALSE&&this._matrix[xe.BOUNDARY][xe.EXTERIOR]===_t.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,_t.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}toString(){const t=new Lt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,_t.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}get interfaces_(){return[k]}}class Te{static isNorthern(t){return t===Te.NE||t===Te.NW}static isOpposite(t,e){return t!==e&&2==(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2==(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Te.SE?t===Te.SE||t===Te.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new F("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Te.NE:Te.SE:e>=0?Te.NW:Te.SW}if(arguments[0]instanceof H&&arguments[1]instanceof H){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new F("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Te.NE:Te.SE:e.y>=t.y?Te.NW:Te.SW}}}Te.NE=0,Te.NW=1,Te.SW=2,Te.SE=3;class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Re.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Re.constructor_.call(this,t),this.init(e,n),this._label=i}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:$t.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),i=n.lastIndexOf("."),s=n.substring(i+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}getLabel(){return this._label}getEdge(){return this._edge}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Te.quadrant(this._dx,this._dy),z.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getCoordinate(){return this._p0}setNode(t){this._node=t}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getQuadrant(){return this._quadrant}getNode(){return this._node}get interfaces_(){return[q]}}class we{static opposite(t){return t===we.LEFT?we.RIGHT:t===we.RIGHT?we.LEFT:t}}we.ON=0,we.LEFT=1,we.RIGHT=2;class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[we.ON]=t}else if(arguments[0]instanceof Oe){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[we.ON]=t,this.location[we.LEFT]=e,this.location[we.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==xe.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===xe.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[we.ON]=this.location[we.ON],t[we.LEFT]=xe.NONE,t[we.RIGHT]=xe.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===xe.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[we.LEFT];this.location[we.LEFT]=this.location[we.RIGHT],this.location[we.RIGHT]=t}get(t){return t<this.location.length?this.location[t]:xe.NONE}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}toString(){const t=new Kt;return this.location.length>1&&t.append(xe.toLocationSymbol(this.location[we.LEFT])),t.append(xe.toLocationSymbol(this.location[we.ON])),this.location.length>1&&t.append(xe.toLocationSymbol(this.location[we.RIGHT])),t.toString()}setLocations(t,e,n){this.location[we.ON]=t,this.location[we.LEFT]=e,this.location[we.RIGHT]=n}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===xe.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(we.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(xe.NONE)}}class Le{constructor(){Le.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Oe(t),this.elt[1]=new Oe(t)}else if(arguments[0]instanceof Le){const t=arguments[0];this.elt[0]=new Oe(t.elt[0]),this.elt[1]=new Oe(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new Oe(xe.NONE),this.elt[1]=new Oe(xe.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new Oe(t,e,n),this.elt[1]=new Oe(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.elt[0]=new Oe(xe.NONE,xe.NONE,xe.NONE),this.elt[1]=new Oe(xe.NONE,xe.NONE,xe.NONE),this.elt[t].setLocations(e,n,i)}}static toLineLabel(t){const e=new Le(xe.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Oe(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(we.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new Kt;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(we.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Oe(this.elt[t].location[0]))}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}}class be{computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new st;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const i=n.iterator();let s=null,r=null;if(!i.hasNext())return null;let o=i.next();do{s=r,r=o,o=null,i.hasNext()&&(o=i.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,s),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}createEdgeEndForNext(t,e,n,i){const s=n.segmentIndex+1;if(s>=t.getNumPoints()&&null===i)return null;let r=t.getCoordinate(s);null!==i&&i.segmentIndex===n.segmentIndex&&(r=i.coord);const o=new Re(t,n.coord,r,new Le(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,i){let s=n.segmentIndex;if(0===n.dist){if(0===s)return null;s--}let r=t.getCoordinate(s);null!==i&&i.segmentIndex>=s&&(r=i.coord);const o=new Le(t.getLabel());o.flip();const l=new Re(t,n.coord,r,o);e.add(l)}}class Ce{constructor(){Ce.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){z.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}isInResult(){return this._isInResult}isVisited(){return this._isVisited}}class ve extends Ce{constructor(){super(),ve.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Le(0,xe.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();)if(t.next().getEdge().isInResult())return!0;return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}computeMergedLocation(t,e){let n=xe.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const i=t.getLocation(e);n!==xe.BOUNDARY&&(n=i)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Le(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof ve){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Le){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===xe.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=xe.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case xe.BOUNDARY:n=xe.INTERIOR;break;case xe.INTERIOR:default:n=xe.BOUNDARY}this._label.setLocation(t,n)}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}}class Se extends Gt{}function Pe(t){return null==t?0:t.color}function Me(t){return null==t?null:t.parent}function Ae(t,e){null!==t&&(t.color=e)}function De(t){return null==t?null:t.left}function Fe(t){return null==t?null:t.right}class Ye extends Se{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,i,s=this.root_;do{if(n=s,i=t.compareTo(s.key),i<0)s=s.left;else{if(!(i>0)){const t=s.value;return s.value=e,t}s=s.right}}while(null!==s);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return i<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)Me(t)===De(Me(Me(t)))?(e=Fe(Me(Me(t))),1===Pe(e)?(Ae(Me(t),0),Ae(e,0),Ae(Me(Me(t)),1),t=Me(Me(t))):(t===Fe(Me(t))&&(t=Me(t),this.rotateLeft(t)),Ae(Me(t),0),Ae(Me(Me(t)),1),this.rotateRight(Me(Me(t))))):(e=De(Me(Me(t))),1===Pe(e)?(Ae(Me(t),0),Ae(e,0),Ae(Me(Me(t)),1),t=Me(Me(t))):(t===De(Me(t))&&(t=Me(t),this.rotateRight(t)),Ae(Me(t),0),Ae(Me(Me(t)),1),this.rotateLeft(Me(Me(t)))));this.root_.color=0}values(){const t=new st;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Ye.successor(e));)t.add(e.value);return t}entrySet(){const t=new qt;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Ye.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Ge{constructor(){Ge.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Ye,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}print(t){for(let e=this.iterator();e.hasNext();)e.next().print(t)}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new st;for(let n=this.iterator();n.hasNext();){const i=n.next();i.getLabel().getLocation(t)===xe.BOUNDARY&&e.add(i)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof H){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof ve){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}}class qe extends U{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new H(e):void 0,this.name=Object.keys({TopologyException:qe})[0]}getCoordinate(){return this.pt}}class Be{static intersection(t,e,n,i){const s=t.x<e.x?t.x:e.x,r=t.y<e.y?t.y:e.y,o=t.x>e.x?t.x:e.x,l=t.y>e.y?t.y:e.y,a=n.x<i.x?n.x:i.x,c=n.y<i.y?n.y:i.y,h=n.x>i.x?n.x:i.x,u=n.y>i.y?n.y:i.y,g=((s>a?s:a)+(o<h?o:h))/2,d=((r>c?r:c)+(l<u?l:u))/2,p=t.x-g,f=t.y-d,_=e.x-g,y=e.y-d,m=n.x-g,E=n.y-d,I=i.x-g,x=i.y-d,N=f-y,T=_-p,R=p*y-_*f,w=E-x,O=I-m,L=m*x-I*E,b=N*O-w*T,C=(T*L-O*R)/b,v=(w*R-N*L)/b;return G.isNaN(C)||G.isInfinite(C)||G.isNaN(v)||G.isInfinite(v)?null:new H(C+g,v+d)}}class Ue{static pointToSegmentString(t,e){if(0===e.length)throw new F("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let i=0;i<e.length-1;i++){const s=Ue.pointToSegment(t,e[i],e[i+1]);s<n&&(n=s)}return n}static segmentToSegment(t,e,n,i){if(t.equals(e))return Ue.pointToSegment(t,n,i);if(n.equals(i))return Ue.pointToSegment(i,t,e);let s=!1;if(dt.intersects(t,e,n,i)){const r=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===r)s=!0;else{const o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(s=!0)}}else s=!0;return s?ut.min(Ue.pointToSegment(t,n,i),Ue.pointToSegment(e,n,i),Ue.pointToSegment(n,t,e),Ue.pointToSegment(i,t,e)):0}static pointToLinePerpendicular(t,e,n){const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(s)*Math.sqrt(i)}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),s=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/i;if(s<=0)return t.distance(e);if(s>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new H,this._intPt[1]=new H,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static nonRobustComputeEdgeDistance(t,e,n){const i=t.x-e.x,s=t.y-e.y,r=Math.sqrt(i*i+s*s);return z.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}static computeEdgeDistance(t,e,n){const i=Math.abs(n.x-e.x),s=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=i>s?i:s;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=i>s?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return z.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}computeIntersection(t,e,n,i){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=i,this._result=this.computeIntersect(t,e,n,i)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}getEdgeDistance(t,e){return Xe.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Xe.COLLINEAR_INTERSECTION}toString(){return Ie.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Ie.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new Lt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Xe.NO_INTERSECTION}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Xe.DONT_INTERSECT=0,Xe.DO_INTERSECT=1,Xe.COLLINEAR=2,Xe.NO_INTERSECTION=0,Xe.POINT_INTERSECTION=1,Xe.COLLINEAR_INTERSECTION=2;class ze extends Xe{constructor(){super()}static nearestEndpoint(t,e,n,i){let s=t,r=Ue.pointToSegment(t,n,i),o=Ue.pointToSegment(e,n,i);return o<r&&(r=o,s=e),o=Ue.pointToSegment(n,t,e),o<r&&(r=o,s=n),o=Ue.pointToSegment(i,t,e),o<r&&(r=o,s=i),s}isInSegmentEnvelopes(t){const e=new dt(this._inputLines[0][0],this._inputLines[0][1]),n=new dt(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,dt.intersects(e,n,t)&&0===$t.index(e,n,t)&&0===$t.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Xe.POINT_INTERSECTION,null;this._result=Xe.NO_INTERSECTION}}intersection(t,e,n,i){let s=this.intersectionSafe(t,e,n,i);return this.isInSegmentEnvelopes(s)||(s=new H(ze.nearestEndpoint(t,e,n,i))),null!==this._precisionModel&&this._precisionModel.makePrecise(s),s}checkDD(t,e,n,i,s){const r=Qt.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(r);gt.out.println("DD in env = "+o+"  --------------------- "+r),s.distance(r)>1e-4&&gt.out.println("Distance = "+s.distance(r))}intersectionSafe(t,e,n,i){let s=Be.intersection(t,e,n,i);return null===s&&(s=ze.nearestEndpoint(t,e,n,i)),s}computeCollinearIntersection(t,e,n,i){const s=dt.intersects(t,e,n),r=dt.intersects(t,e,i),o=dt.intersects(n,i,t),l=dt.intersects(n,i,e);return s&&r?(this._intPt[0]=n,this._intPt[1]=i,Xe.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Xe.COLLINEAR_INTERSECTION):s&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Xe.COLLINEAR_INTERSECTION:Xe.POINT_INTERSECTION):s&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Xe.COLLINEAR_INTERSECTION:Xe.POINT_INTERSECTION):r&&o?(this._intPt[0]=i,this._intPt[1]=t,!i.equals(t)||s||l?Xe.COLLINEAR_INTERSECTION:Xe.POINT_INTERSECTION):r&&l?(this._intPt[0]=i,this._intPt[1]=e,!i.equals(e)||s||o?Xe.COLLINEAR_INTERSECTION:Xe.POINT_INTERSECTION):Xe.NO_INTERSECTION}computeIntersect(t,e,n,i){if(this._isProper=!1,!dt.intersects(t,e,n,i))return Xe.NO_INTERSECTION;const s=$t.index(t,e,n),r=$t.index(t,e,i);if(s>0&&r>0||s<0&&r<0)return Xe.NO_INTERSECTION;const o=$t.index(n,i,t),l=$t.index(n,i,e);return o>0&&l>0||o<0&&l<0?Xe.NO_INTERSECTION:0===s&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,i):(0===s||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this._intPt[0]=e:0===s?this._intPt[0]=new H(n):0===r?this._intPt[0]=new H(i):0===o?this._intPt[0]=new H(t):0===l&&(this._intPt[0]=new H(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,i)),Xe.POINT_INTERSECTION)}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof H&&P(arguments[1],It)){const t=arguments[1],e=new ke(arguments[0]),n=new H,i=new H;for(let s=1;s<t.size();s++)if(t.getCoordinate(s,n),t.getCoordinate(s-1,i),e.countSegment(n,i),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof H&&arguments[1]instanceof Array){const t=arguments[1],e=new ke(arguments[0]);for(let n=1;n<t.length;n++){const i=t[n],s=t[n-1];if(e.countSegment(i,s),e.isOnSegment())return e.getLocation()}return e.getLocation()}}getLocation(){return this._isPointOnSegment?xe.BOUNDARY:this._crossingCount%2==1?xe.INTERIOR:xe.EXTERIOR}isPointInPolygon(){return this.getLocation()!==xe.EXTERIOR}isOnSegment(){return this._isPointOnSegment}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this._p.x>=n&&this._p.x<=i&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=$t.index(t,e,this._p);if(n===$t.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===$t.LEFT&&this._crossingCount++}}}class je{static isInRing(t,e){return je.locateInRing(t,e)!==xe.EXTERIOR}static locateInRing(t,e){return ke.locatePointInRing(t,e)}static isOnLine(){if(arguments[0]instanceof H&&P(arguments[1],It)){const t=arguments[0],e=arguments[1],n=new ze,i=new H,s=new H,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,i),e.getCoordinate(o,s),n.computeIntersection(t,i,s),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof H&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new ze;for(let i=1;i<e.length;i++){const s=e[i-1],r=e[i];if(n.computeIntersection(t,s,r),n.hasIntersection())return!0}return!1}}}class Ve{locate(t){}}class Ze{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof Dt)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new it;const t=this._parent.getGeometryN(this._index++);return t instanceof Dt?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}remove(){throw new $(this.getClass().getName())}get interfaces_(){return[Ze]}}class He{constructor(){He.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return xe.EXTERIOR;const n=e.getExteriorRing(),i=He.locatePointInRing(t,n);if(i!==xe.INTERIOR)return i;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=He.locatePointInRing(t,i);if(s===xe.BOUNDARY)return xe.BOUNDARY;if(s===xe.INTERIOR)return xe.EXTERIOR}return xe.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?je.locateInRing(t,e.getCoordinates()):xe.EXTERIOR}static isContained(t,e){return xe.EXTERIOR!==He.locate(t,e)}static locate(t,e){return e.isEmpty()?xe.EXTERIOR:e.getEnvelopeInternal().intersects(t)?He.locateInGeometry(t,e):xe.EXTERIOR}static containsPointInPolygon(t,e){return xe.EXTERIOR!==He.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof te)return He.locatePointInPolygon(t,e);if(e instanceof Dt){const n=new We(e);for(;n.hasNext();){const i=n.next();if(i!==e){const e=He.locateInGeometry(t,i);if(e!==xe.EXTERIOR)return e}}}return xe.EXTERIOR}locate(t){return He.locate(t,this._geom)}get interfaces_(){return[Ve]}}class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Ye,this._edgeList=null,this._ptInAreaLocation=[xe.NONE,xe.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=xe.NONE;for(let n=this.iterator();n.hasNext();){const i=n.next().getLabel();i.isArea(t)&&i.getLocation(t,we.LEFT)!==xe.NONE&&(e=i.getLocation(t,we.LEFT))}if(e===xe.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const i=e.next(),s=i.getLabel();if(s.getLocation(t,we.ON)===xe.NONE&&s.setLocation(t,we.ON,n),s.isArea(t)){const e=s.getLocation(t,we.LEFT),r=s.getLocation(t,we.RIGHT);if(r!==xe.NONE){if(r!==n)throw new qe("side location conflict",i.getCoordinate());e===xe.NONE&&z.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),n=e}else z.isTrue(s.getLocation(t,we.LEFT)===xe.NONE,"found single null side"),s.setLocation(t,we.RIGHT,n),s.setLocation(t,we.LEFT,n)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,i=e.get(n).getLabel().getLocation(t,we.LEFT);z.isTrue(i!==xe.NONE,"Found unlabelled area edge");let s=i;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();z.isTrue(n.isArea(t),"Found non-area edge");const i=n.getLocation(t,we.LEFT),r=n.getLocation(t,we.RIGHT);if(i===r)return!1;if(r!==s)return!1;s=i}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++)if(this._edgeList.get(e)===t)return e;return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new st(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===xe.NONE&&(this._ptInAreaLocation[t]=He.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new Kt;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();)e.next().computeLabel(t)}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===xe.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const i=n.next(),s=i.getLabel();for(let n=0;n<2;n++)if(s.isAnyNull(n)){let r=xe.NONE;if(e[n])r=xe.EXTERIOR;else{const e=i.getCoordinate();r=this.getLocation(n,e,t)}s.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}print(t){gt.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();)e.next().print(t)}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}}class Je{}const Qe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return Qe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?At.sort(n,e):At.sort(n);const i=t.iterator();for(let t=0,e=n.length;t<e;t++)i.next(),i.set(n[t])},singletonList:function(t){const e=new st;return e.add(t),e}},$e=Qe;class tn{constructor(){tn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(tn.isAdjacentSegments(e,i))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&i===n||0===i&&e===n)return!0}}return!1}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return!(null===e||!this.isBoundaryPointInternal(t,e[0])&&!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;const s=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[i],l=n.getCoordinates()[i+1];this._li.computeIntersection(s,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}}class en{constructor(){en.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=nn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=nn.INSERT,this._label=t,this._xValue=e,this._obj=n}}getObject(){return this._obj}getDeleteEventIndex(){return this._deleteEventIndex}isDelete(){return this._eventType===nn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===nn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}get interfaces_(){return[q]}}nn.INSERT=1,nn.DELETE=2;class sn extends Je{constructor(){super(),sn.constructor_.apply(this,arguments)}static constructor_(){this.events=new st,this.nOverlaps=null}prepareEvents(){$e.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof tn&&P(arguments[0],nt)&&P(arguments[1],nt)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&P(arguments[0],nt)&&arguments[1]instanceof tn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),i=n.getStartIndexes();for(let t=0;t<i.length-1;t++){const i=new en(n,t),s=new nn(e,n.getMinX(t),i);this.events.add(s),this.events.add(new nn(n.getMaxX(t),s))}}processOverlaps(t,e,n,i){const s=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(s.computeIntersections(e,i),this.nOverlaps++)}}}addEdges(){if(1===arguments.length)for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class rn{createNode(t){return new ve(t,null)}}class on extends Re{constructor(){super(),on.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Re.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===xe.EXTERIOR&&e===xe.INTERIOR?1:t===xe.INTERIOR&&e===xe.EXTERIOR?-1:0}setVisited(t){this._isVisited=t}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new qe("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,we.LEFT)===xe.INTERIOR&&this._label.getLocation(e,we.RIGHT)===xe.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[we.LEFT]+"/"+this._depth[we.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}getSym(){return this._sym}isForward(){return this._isForward}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}computeDirectedLabel(){this._label=new Le(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,xe.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,xe.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let i=1;t===we.LEFT&&(i=-1);const s=we.opposite(t),r=e+n*i;this.setDepth(t,e),this.setDepth(s,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new st,this._nodes=null,this._edgeEndList=new st,0===arguments.length)this._nodes=new Ge(new rn);else if(1===arguments.length){const t=arguments[0];this._nodes=new Ge(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();)e.next().getEdges().linkResultDirectedEdges()}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}debugPrintln(t){gt.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const i=n.getLabel();return null!==i&&i.getLocation(t)===xe.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkAllDirectedEdges()}debugPrint(t){gt.out.print(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(t.equals(s[0])&&e.equals(s[1]))return i}return null}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof ve){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof H){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().linkResultDirectedEdges()}matchInSameDirection(t,e,n,i){return!!t.equals(n)&&$t.index(t,e,i)===$t.COLLINEAR&&Te.quadrant(t,e)===Te.quadrant(n,i)}getEdgeEnds(){return this._edgeEndList}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const i=this._edges.get(n),s=i.getCoordinates();if(this.matchInSameDirection(t,e,s[0],s[1]))return i;if(this.matchInSameDirection(t,e,s[s.length-1],s[s.length-2]))return i}return null}insertEdge(t){this._edges.add(t)}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new on(t,!0),i=new on(t,!1);n.setSym(i),i.setSym(n),this.add(n),this.add(i)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}}class an{isInBoundary(t){}}class cn{isInBoundary(t){return t%2==1}get interfaces_(){return[an]}}class hn{isInBoundary(t){return t>0}get interfaces_(){return[an]}}class un{isInBoundary(t){return t>1}get interfaces_(){return[an]}}class gn{isInBoundary(t){return 1===t}get interfaces_(){return[an]}}an.Mod2BoundaryNodeRule=cn,an.EndPointBoundaryNodeRule=hn,an.MultiValentEndPointBoundaryNodeRule=un,an.MonoValentEndPointBoundaryNodeRule=gn,an.MOD2_BOUNDARY_RULE=new cn,an.ENDPOINT_BOUNDARY_RULE=new hn,an.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new un,an.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new gn,an.OGC_SFS_BOUNDARY_RULE=an.MOD2_BOUNDARY_RULE;class dn{constructor(){dn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=an.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new F("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?je.locateInRing(t,e.getCoordinates()):xe.EXTERIOR}intersects(t,e){return this.locate(t,e)!==xe.EXTERIOR}updateLocationInfo(t){t===xe.INTERIOR&&(this._isIn=!0),t===xe.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Wt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof Rt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof te)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof jt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,i))}}else if(e instanceof Yt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const i=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,i))}}else if(e instanceof Dt){const n=new We(e);for(;n.hasNext();){const i=n.next();i!==e&&this.computeLocation(t,i)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?xe.INTERIOR:xe.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return xe.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?je.isOnLine(t,n)?xe.INTERIOR:xe.EXTERIOR:xe.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return xe.EXTERIOR;const n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===xe.EXTERIOR)return xe.EXTERIOR;if(i===xe.BOUNDARY)return xe.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const i=e.getInteriorRingN(n),s=this.locateInPolygonRing(t,i);if(s===xe.INTERIOR)return xe.EXTERIOR;if(s===xe.BOUNDARY)return xe.BOUNDARY}return xe.INTERIOR}locate(t,e){return e.isEmpty()?xe.EXTERIOR:e instanceof Rt?this.locateOnLineString(t,e):e instanceof te?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?xe.BOUNDARY:this._numBoundaries>0||this._isIn?xe.INTERIOR:xe.EXTERIOR)}}class pn{visitItem(t){}}class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){this._min=G.POSITIVE_INFINITY,this._max=G.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Ie.toLineString(new H(this._min,0),new H(this._max,0))}}fn.NodeComparator=class{compare(t,e){const n=t,i=e,s=(n._min+n._max)/2,r=(i._min+i._max)/2;return s<r?-1:s>r?1:0}get interfaces_(){return[j]}};class _n extends fn{constructor(){super(),_n.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class yn extends fn{constructor(){super(),yn.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class mn{constructor(){mn.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new st,this._root=null,this._level=0}buildTree(){$e.sort(this._leaves,new fn.NodeComparator);let t=this._leaves,e=null,n=new st;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new Zt("Index cannot be added to once it has been queried");this._leaves.add(new _n(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){gt.out.println(Ie.toLineString(new H(t._min,this._level),new H(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const i=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(i);else{const i=new yn(t.get(n),t.get(n+1));e.add(i)}}}}class En{constructor(){En.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)En.constructor_.call(this,new H,new H);else if(1===arguments.length){const t=arguments[0];En.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];En.constructor_.call(this,new H(t,e),new H(n,i))}}static midPoint(t,e){return new H((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof En){const t=arguments[0],e=$t.index(this.p0,this.p1,t.p0),n=$t.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof H){const t=arguments[0];return $t.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return En.midPoint(this.p0,this.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),s=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(s*s+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new Zt("Cannot compute offset from zero-length line segment");l=e*s/o,a=e*r/o}return new H(n-a,i+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||G.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}distance(){if(arguments[0]instanceof En){const t=arguments[0];return Ue.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof H){const t=arguments[0];return Ue.pointToSegment(t,this.p0,this.p1)}}equals(t){if(!(t instanceof En))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new ze;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof H){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new H(t);const e=this.projectionFactor(t),n=new H;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof En){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let i=this.project(t.p0);e<0&&(i=this.p0),e>1&&(i=this.p1);let s=this.project(t.p1);return n<0&&(s=this.p0),n>1&&(s=this.p1),new En(i,s)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return Ue.pointToLinePerpendicular(t,this.p0,this.p1)}closestPoint(t){const e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;return i<=0?G.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let i=G.MAX_VALUE,s=null;const r=this.closestPoint(t.p0);i=r.distance(t.p0),n[0]=r,n[1]=t.p0;const o=this.closestPoint(t.p1);s=o.distance(t.p1),s<i&&(i=s,n[0]=o,n[1]=t.p1);const l=t.closestPoint(this.p0);s=l.distance(this.p0),s<i&&(i=s,n[0]=this.p0,n[1]=l);const a=t.closestPoint(this.p1);return s=a.distance(this.p1),s<i&&(i=s,n[0]=this.p1,n[1]=a),n}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return Be.intersection(this.p0,this.p1,t.p0,t.p1)}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),i=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),s=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new H((-r*o-2*e*n*l-2*e*i)/s,(r*l-2*e*n*o-2*n*i)/s)}pointAlong(t){const e=new H;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=G.doubleToLongBits(this.p0.x);t^=31*G.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=G.doubleToLongBits(this.p1.x);return n^=31*G.doubleToLongBits(this.p1.y),e^Math.trunc(n)^Math.trunc(n>>32)}get interfaces_(){return[q,B]}}class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getLines(){if(1===arguments.length){const t=arguments[0];return In.getLines(t,!1)}if(2===arguments.length){if(P(arguments[0],tt)&&P(arguments[1],tt)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();In.getLines(n,t)}return t}if(arguments[0]instanceof yt&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new st;return t.apply(new In(n,e)),n}if(arguments[0]instanceof yt&&P(arguments[1],tt)){const t=arguments[0],e=arguments[1];return t instanceof Rt?e.add(t):t.apply(new In(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&P(arguments[0],tt)&&P(arguments[1],tt)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const i=n.next();In.getLines(i,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof yt&&P(arguments[1],tt)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new In(t,e)),t}}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(In.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(In.getLines(t,e))}}filter(t){if(this._isForcedToLineString&&t instanceof wt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Rt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[Q]}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){this._items=new st}getItems(){return this._items}visitItem(t){this._items.add(t)}get interfaces_(){return[pn]}}class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(P(t,Ft)||t instanceof wt))throw new F("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new Rn(this._geom),this._geom=null);const e=new ke(t),n=new Tn(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ve]}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[pn]}}class Rn{constructor(){Rn.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new mn;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=In.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new En(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),s=Math.max(n.p0.y,n.p1.y);this._index.insert(i,s,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new st;const n=new xn;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}Nn.SegmentVisitor=Tn,Nn.IntervalIndexedGeometry=Rn;class wn{constructor(){wn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new H(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[q]}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Ye,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();)e.next().print(t)}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const i=this.edge.pts[e.segmentIndex],s=e.dist>0||!e.coord.equals2D(i);s||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new H(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return s&&(r[o]=e.coord),new Sn(r,new Le(this.edge._label))}add(t,e,n){const i=new wn(t,e,n),s=this._nodeMap.get(i);return null!==s?s:(this._nodeMap.put(i,i),i)}isIntersection(t){for(let e=this.iterator();e.hasNext();)if(e.next().coord.equals(t))return!0;return!1}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const i=e.next(),s=this.createSplitEdge(n,i);t.add(s),n=i}}}class Ln{constructor(){Ln.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Ln.NULL_VALUE}static depthAtLocation(t){return t===xe.EXTERIOR?0:t===xe.INTERIOR?1:Ln.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Ln.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Ln.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Ln.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let i=0;this._depth[t][n]>e&&(i=1),this._depth[t][n]=i}}}getDelta(t){return this._depth[t][we.RIGHT]-this._depth[t][we.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?xe.EXTERIOR:xe.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const i=t.getLocation(e,n);i!==xe.EXTERIOR&&i!==xe.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Ln.depthAtLocation(i):this._depth[e][n]+=Ln.depthAtLocation(i))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===xe.INTERIOR&&this._depth[t][e]++}}}Ln.NULL_VALUE=-1;class bn{constructor(){bn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)bn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),gt.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=At.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return gt.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class Cn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}findChainEnd(t,e){const n=Te.quadrant(t[e],t[e+1]);let i=e+1;for(;i<t.length&&Te.quadrant(t[i-1],t[i])===n;)i++;return i-1}OLDgetChainStartIndices(t){let e=0;const n=new st;n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return Cn.toIntArray(n)}getChainStartIndices(t){let e=0;const n=new bn(Math.trunc(t.length/2));n.add(e);do{const i=this.findChainEnd(t,e);n.add(i),e=i}while(e<t.length-1);return n.toArray()}}class vn{constructor(){vn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Cn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],s=arguments[4],r=arguments[5];if(e-t==1&&s-i==1)return r.addIntersections(this.e,t,n.e,i),null;if(!this.overlaps(t,e,n,i,s))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((i+s)/2);t<o&&(i<l&&this.computeIntersectsForChain(t,o,n,i,l,r),l<s&&this.computeIntersectsForChain(t,o,n,l,s,r)),o<e&&(i<l&&this.computeIntersectsForChain(o,e,n,i,l,r),l<s&&this.computeIntersectsForChain(o,e,n,l,s,r))}}overlaps(t,e,n,i,s){return dt.intersects(this.pts[t],this.pts[e],n.pts[i],n.pts[s])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)}}class Sn extends Ce{constructor(){super(),Sn.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new On(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Ln,this._depthDelta=0,1===arguments.length){const t=arguments[0];Sn.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Ne&&arguments[0]instanceof Le))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,we.ON),t.getLocation(1,we.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,we.LEFT),t.getLocation(1,we.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,we.RIGHT),t.getLocation(1,we.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Sn(t,Le.toLineLabel(this._label))}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Sn))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,i=!0,s=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--s])||(i=!1),!n&&!i)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Sn.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new vn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new dt;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,i){const s=new H(t.getIntersection(i));let r=e,o=t.getEdgeDistance(n,i);const l=r+1;if(l<this.pts.length){const t=this.pts[l];s.equals2D(t)&&(r=l,o=0)}this.eiList.add(s,r,o)}toString(){const t=new Lt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}}class Pn extends ln{constructor(){super(),Pn.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new Ut,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new dn,2===arguments.length){const t=arguments[0],e=arguments[1];Pn.constructor_.call(this,t,e,an.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?xe.BOUNDARY:xe.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let i=1,s=xe.NONE;s=n.getLocation(t,we.ON),s===xe.BOUNDARY&&i++;const r=Pn.determineBoundary(this._boundaryNodeRule,i);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new tn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const i=this.createEdgeSetIntersector(),s=this._parentGeom instanceof wt||this._parentGeom instanceof te||this._parentGeom instanceof Yt,r=t||!s;return i.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),xe.EXTERIOR,xe.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,xe.INTERIOR,xe.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],xe.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],xe.BOUNDARY)}addLineString(t){const e=pt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Sn(e,new Le(this._argIndex,xe.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),z.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let i=t.iterator();i.hasNext();){const t=i.next();e[n++]=t.getCoordinate().copy()}return e}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,i)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof yt))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Yt&&(this._useBoundaryDeterminationRule=!1),t instanceof te)this.addPolygon(t);else if(t instanceof Rt)this.addLineString(t);else if(t instanceof Wt)this.addPoint(t);else if(t instanceof ee)this.addCollection(t);else if(t instanceof jt)this.addCollection(t);else if(t instanceof Yt)this.addCollection(t);else{if(!(t instanceof Dt))throw new $(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return P(this._parentGeom,Ft)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Nn(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof Rt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();)e.next().eiList.addSplitEdges(t)}computeEdgeIntersections(t,e,n){const i=new tn(e,n,!0);return i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,i),i}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Wt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,xe.INTERIOR)}else if(arguments[0]instanceof H){const t=arguments[0];this.insertPoint(this._argIndex,t,xe.INTERIOR)}}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===xe.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const i=pt.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=i[0],null;let s=e,r=n;$t.isCCW(i)&&(s=n,r=e);const o=new Sn(i,new Le(this._argIndex,xe.BOUNDARY,s,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,i[0],xe.BOUNDARY)}insertPoint(t,e,n){const i=this._nodes.addNode(e),s=i.getLabel();null===s?i._label=new Le(t,n):s.setLocation(t,n)}createEdgeSetIntersector(){return new sn}}class Mn extends Re{constructor(){super(),Mn.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new st,1===arguments.length){const t=arguments[0];Mn.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Re.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Le(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();)e.next().print(t),t.println()}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,i=!1;for(let e=this.iterator();e.hasNext();){const s=e.next().getLabel().getLocation(t);s===xe.BOUNDARY&&n++,s===xe.INTERIOR&&(i=!0)}let s=xe.NONE;i&&(s=xe.INTERIOR),n>0&&(s=Pn.determineBoundary(e,n)),this._label.setLocation(t,s)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const i=n.next();if(i.getLabel().isArea()){const n=i.getLabel().getLocation(t,e);if(n===xe.INTERIOR)return this._label.setLocation(t,e,xe.INTERIOR),null;n===xe.EXTERIOR&&this._label.setLocation(t,e,xe.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,we.LEFT),this.computeLabelSide(t,we.RIGHT)}updateIM(t){Sn.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();)t.next().getLabel().isArea()&&(e=!0);this._label=e?new Le(xe.NONE,xe.NONE,xe.NONE):new Le(xe.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class An extends Ke{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();)e.next().updateIM(t)}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Mn(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class Dn extends ve{constructor(){super(),Dn.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ve.constructor_.call(this,t,e)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}updateIMFromEdges(t){this._edges.updateIM(t)}}class Fn extends rn{constructor(){super()}createNode(t){return new Dn(t,new An)}}class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static constructor_(){this._li=new ze,this._ptLocator=new dn,this._arg=null,this._nodes=new Ge(new Fn),this._im=null,this._isolatedEdges=new st,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),i=this._arg[1].getGeometry().getDimension(),s=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===i?s&&e.setAtLeast("212101212"):2===n&&1===i?(s&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(s&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const i=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,xe.EXTERIOR)}computeIM(){const t=new Ne;if(t.set(xe.EXTERIOR,xe.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new be,i=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(i);const s=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(s),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();)t.next().getEdges().computeLabelling(this._arg)}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.find(n.coord);s.getLabel().isNull(t)&&(i===xe.BOUNDARY?s.setLabelBoundary(t):s.setLabel(t,xe.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),i=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),s=this._nodes.addNode(n.coord);i===xe.BOUNDARY?s.setLabelBoundary(t):s.getLabel().isNull(t)&&s.setLabel(t,xe.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();z.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();)e.next().updateIM(t);for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(xe.INTERIOR,xe.EXTERIOR,e.getDimension()),t.set(xe.BOUNDARY,xe.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(xe.EXTERIOR,xe.INTERIOR,n.getDimension()),t.set(xe.EXTERIOR,xe.BOUNDARY,n.getBoundaryDimension()))}}class Gn{constructor(){Gn.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new ze,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Pn(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Gn.constructor_.call(this,t,e,an.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Pn(0,t,n),this._arg[1]=new Pn(1,e,n)}}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getArgGeometry(t){return this._arg[t].getGeometry()}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new qn(t).contains(e)}isContainedInBoundary(t){if(t instanceof te)return!1;if(t instanceof Wt)return this.isPointContainedInBoundary(t);if(t instanceof Rt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new H,i=new H;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Wt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof H){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){this._li=new ze,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new H(t.getMinX(),t.getMinY()),this._diagUp1=new H(t.getMaxX(),t.getMaxY()),this._diagDown0=new H(t.getMinX(),t.getMaxY()),this._diagDown1=new H(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new dt(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let i=!1;return e.y>t.y&&(i=!0),i?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Un{constructor(){Un.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof Dt)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class Xn{constructor(){Xn.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Xn(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new zn(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new kn(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const i=new jn(this._rectangle);return i.applyTo(t),!!i.intersects()}}class zn extends Un{constructor(){super(),zn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}intersects(){return this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}isDone(){return!0===this._intersects}}class kn extends Un{constructor(){super(),kn.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}visit(t){if(!(t instanceof te))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new H;for(let i=0;i<4;i++)if(this._rectSeq.getCoordinate(i,n),e.contains(n)&&He.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}isDone(){return!0===this._containsPoint}}class jn extends Un{constructor(){super(),jn.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new H,this._p1=new H;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Bn(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=In.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Vn extends Gn{constructor(){super(),Vn.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Gn.constructor_.call(this,t,e),this._relate=new Yn(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Gn.constructor_.call(this,t,e,n),this._relate=new Yn(this._arg)}}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Vn.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){return 2===arguments.length?new Vn(arguments[0],arguments[1]).getIntersectionMatrix():3===arguments.length?new Vn(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix():void 0}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Vn(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static disjoint(t,e){return!Vn.intersects(t,e)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Vn(t,e).getIntersectionMatrix().isCovers())}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Xn.intersects(t,e);if(e.isRectangle())return Xn.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let i=0;i<e.getNumGeometries();i++)if(Vn.intersects(t.getGeometryN(n),e.getGeometryN(i)))return!0;return!1}return new Vn(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Vn(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Vn(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?qn.contains(t,e):new Vn(t,e).getIntersectionMatrix().isContains())}getIntersectionMatrix(){return this._relate.computeIM()}}function Zn(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=Array(e);n<e;n++)i[n]=t[n];return i}function Wn(t,e,n){return e=Kn(e),function(t,e){if(e&&("object"==$n(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Hn()?Reflect.construct(e,n||[],Kn(t).constructor):e.apply(t,n))}function Hn(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Hn=function(){return!!t})()}function Kn(t){return Kn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Kn(t)}function Jn(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Qn(t,e)}function Qn(t,e){return Qn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Qn(t,e)}function $n(t){return $n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$n(t)}function ti(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ei(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,ii(i.key),i)}}function ni(t,e,n){return e&&ei(t.prototype,e),n&&ei(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function ii(t){var e=function(t,e){if("object"!=$n(t)||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,"string");if("object"!=$n(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==$n(e)?e:e+""}var si=function(t){function e(t,n){return ti(this,e),Wn(this,e,[function(e,n){var i=null;return M.utils.isNullOrEmpty(e)||(i=e.getGeometry()),t(i,n)},n])}return Jn(e,t),ni(e)}(function(t){function e(t){var n,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return ti(this,e),(n=Wn(this,e)).filterFunction_=t,n.cqlFilter_="",M.utils.isNullOrEmpty(i.cqlFilter)||(n.cqlFilter_=i.cqlFilter),n}return Jn(e,t),ni(e,[{key:"setFunction",value:function(t){this.filterFunction_=t}},{key:"getFunctionFilter",value:function(){return this.filterFunction_}},{key:"execute",value:function(t){return t.filter(this.filterFunction_)}},{key:"toCQL",value:function(){return this.cqlFilter_}}])}(function(){return ni((function t(){ti(this,t)}),[{key:"getFunctionFilter",value:function(){}},{key:"execute",value:function(t){}},{key:"toCQL",value:function(){}}])}())),ri=function(t,e){var n="",i=new M.format.WKT;return e.forEach((function(e,s){0!==s&&(n+=" OR ");var r=new M.Feature("filtered_geom",{type:"Feature",geometry:e}),o=i.write(r);n+="".concat(t,"({{geometryName}}, ").concat(o,")")})),n},oi=function(t){var e=function(t){var e,n=t,i=[];return n instanceof M.layer.Vector?i=function(t){if(Array.isArray(t))return Zn(t)}(e=n.getFeatures().map((function(t){return t.getGeometry()})))||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(e)||function(t,e){if(t){if("string"==typeof t)return Zn(t,e);var n={}.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?Zn(t,e):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}():(M.utils.isArray(n)||(n=[n]),i=n.map((function(t){var e;return t instanceof M.Feature?e=t.getGeometry():M.isObject(t)&&(e=t),e}))),i}(t);return new si((function(t,n){var i=new le,s=i.read(t);return e.some((function(t){var e=i.read(t);return Vn.intersects(s,e)}))}),{cqlFilter:ri("INTERSECTS",e)})};function li(t){return li="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},li(t)}function ai(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,ci(i.key),i)}}function ci(t){var e=function(t,e){if("object"!=li(t)||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,"string");if("object"!=li(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==li(e)?e:e+""}function hi(t,e,n){return e=gi(e),function(t,e){if(e&&("object"==li(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ui()?Reflect.construct(e,n||[],gi(t).constructor):e.apply(t,n))}function ui(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ui=function(){return!!t})()}function gi(t){return gi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},gi(t)}function di(t,e){return di=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},di(t,e)}var pi=function(t){function e(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),t=hi(this,e),1!==n.mode||M.utils.isNullOrEmpty(n.url)||M.utils.isNullOrEmpty(n.type)&&console.warn(T("exception.type")),1!==n.mode||M.utils.isNullOrEmpty(n.layerName)||M.utils.isNullOrEmpty(n.type)&&console.warn(T("exception.layerName")),t.map_=null,t.controls_=[],t.mode_=Number.parseInt(n.mode,10)||1,t.url_=n.url||"https://componentes.cnig.es/api-core/files/attributions/WMTS_PNOA_20170220/atribucionPNOA_Url.kml",t.type_=n.type||"kml",t.layerName_=n.layerName||"attributions",t.layer_=n.layer,t.scale_=Number.parseInt(n.scale,10)||1e4,t.attributionParam_=n.attributionParam||"atribucion",t.urlParam_=n.urlParam||"url",t.minWidth_=n.minWidth||"100px",t.maxWidth_=n.maxWidth||"200px",t.position_=n.position||"BL",t.defaultAttribution_=n.defaultAttribution||"Instituto Geogr&aacute;fico Nacional",t.defaultURL_=n.defaultURL||"https://www.ign.es/",t.tooltip_=n.tooltip||T("tooltip"),t.urlAttribute=n.urlAttribute||"Gobierno de España",window.addEventListener("resize",(function(e){return t.setCollapsiblePanel(e)})),t.order=n.order>=-1?n.order:null,t.options=n,t}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&di(t,e)}(e,M.Plugin),n=e,i=[{key:"addTo",value:function(t){var e=this;this.map_=t,this.impl_=new a(t),this.control_=new S(this.position_,this.closePanel),this.controls_.push(this.control_),this.panel_=new M.ui.Panel("Attributions",{collapsible:window.innerWidth<769,position:M.ui.position[this.position_],className:"m-panel-attributions",collapsedButtonClass:"g-cartografia-info",tooltip:this.tooltip_,order:this.order}),this.panel_.addControls(this.control_),this.map_.addPanels(this.panel_),this.initMode(),this.onMoveEnd((function(){e.changeAttributions()}))}},{key:"destroy",value:function(){this.map_.removeControls([this.control_]),this.panel_=null}},{key:"initMode",value:function(){if(1===this.mode_){if(!(this.layer_ instanceof M.layer.Vector)){var t={name:this.layerName_,url:this.url_};"geojson"===this.type_?this.layer_=new M.layer.GeoJSON(t,{displayInLayerSwitcher:!1}):"kml"===this.type_?this.layer_=new M.layer.KML(t,{displayInLayerSwitcher:!1}):this.type}this.map_.getLayers({name:this.layer_}).length<1&&(this.map_.addLayers(this.layer_),this.layer_.displayInLayerSwitcher=!1,this.layer_.setVisible(!1))}}},{key:"changeAttributions",value:function(){if(this.clearContent(),this.map_.getScale()<=this.scale_){this.setVisible(!0);var t=[];if(1===this.mode_){t=this.getMapAttributions();var e=this.map_.getZoom(),n=this.map_.getBaseLayers()[0],i=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;t=void 0!==n&&"OI.OrthoimageCoverage"===n.name||i?e<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):void 0===n||"IGNBaseTodo"!==n.name&&"EL.GridCoverageDSM"!==n.name?void 0!==n&&"LC.LandCoverSurfaces"===n.name?e<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t):[{attribution:this.defaultAttribution_,url:this.defaultURL_}].concat(t):[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}].concat(t)}this.addContent(t)}else{var s=this.map_.getZoom(),r=this.map_.getBaseLayers()[0],o=[{attribution:this.defaultAttribution_,url:this.defaultURL_}],l=this.map_.getLayers().filter((function(t){return"WMTS"===t.type&&!t.displayInLayerSwitcher&&"OI.OrthoimageCoverage"===t.name})).length>0;void 0!==r&&"OI.OrthoimageCoverage"===r.name||l?o=s<14?[{attribution:"Copernicus Sentinel 2019",url:"https://sentinel.esa.int/web/sentinel/home"}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]:void 0===r||"IGNBaseTodo"!==r.name&&"EL.GridCoverageDSM"!==r.name?void 0!==r&&"LC.LandCoverSurfaces"===r.name&&(o=s<14?[{attribution:"CORINE-Land Cover. Instituto Geográfico Nacional",url:this.defaultURL_}]:[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}]):o=[{attribution:"Sistema Cartográfico Nacional",url:"http://www.scne.es/"}],this.addContent(o)}}},{key:"addContent",value:function(t){var e=this,n=this.control_.getElement(),i=t.map((function(t,n,i){var s=document.createElement("a");s.target="_blank",s.href=t.url,s.setAttribute("rol","link"),s.setAttribute("tabindex",e.order),s.innerHTML=t.attribution;var r=e.map_.getScale()>e.scale_?"":", ".concat(e.urlAttribute);return s.innerHTML+=i.length-1===n?r:",",s})),s=document.createElement("div");i.forEach((function(t){s.append(t)})),n.append(s)}},{key:"clearContent",value:function(){if(!M.utils.isNullOrEmpty(this.control_)){var t=this.control_.getElement();t.querySelectorAll("div").forEach((function(e){return t.removeChild(e)}))}}},{key:"setVisible",value:function(t){this.control_.getElement().style.display=!1===t?"none":""}},{key:"getMapAttributions",value:function(){var t=this;this.updateBBoxFeature();var e=this.map_.getLayers().filter((function(t){return t.name.includes("attributions")}))[0].getFeatures();return oi(this.bboxFeature_).execute(e).map((function(e){return{attribution:e.getAttribute(t.attributionParam_)||"",url:e.getAttribute(t.urlParam_)||t.defaultURL_}})).filter((function(t,e,n){return n.map((function(t){return t.attribution})).indexOf(t.attribution)===e}))}},{key:"getLayerAttributions",value:function(){}},{key:"closePanel",value:function(){this.getPanel().collapse()}},{key:"changeContentAttribution",value:function(t){this.control_.changeContent(t)}},{key:"updateBBoxFeature",value:function(){var t=this.map_.getBbox(),e=t.x,n=t.y;this.bboxFeature_=new M.Feature("bbox_feature",{type:"Feature",properties:{},geometry:{type:"Polygon",coordinates:[[[e.min,n.min],[e.min,n.max],[e.max,n.max],[e.max,n.min],[e.min,n.min]]]}})}},{key:"setCollapsiblePanel",value:function(t){this.getPanel()&&this.getPanel().getTemplatePanel()&&(t.target.innerWidth<769?(this.getPanel().getTemplatePanel().classList.remove("no-collapsible"),this.closePanel()):(this.getPanel().getTemplatePanel().classList.add("no-collapsible"),this.getPanel().getTemplatePanel().classList.remove("collapsed")))}},{key:"onMoveEnd",value:function(t){this.impl_.registerEvent("moveend",(function(e){return t(e)}))}},{key:"getPanel",value:function(){return this.panel_}},{key:"name",get:function(){return"attributions"}},{key:"mode",get:function(){return this.mode_}},{key:"position",get:function(){return this.position_}},{key:"scale",get:function(){return this.scale_}},{key:"defaultAttribution",get:function(){return this.defaultAttribution_}},{key:"defaultURL",get:function(){return this.defaultURL_}},{key:"url",get:function(){return this.url_}},{key:"type",get:function(){return this.type_}},{key:"layerName",get:function(){return this.layerName_}},{key:"attributionParam",get:function(){return this.attributionParam_}},{key:"urlParam",get:function(){return this.urlParam_}},{key:"getAPIRest",value:function(){return"".concat(this.name,"=").concat(this.position,"*").concat(this.tooltip_,"*").concat(this.mode,"*").concat(this.scale,"*").concat(this.defaultAttribution,"*").concat(this.defaultURL,"*").concat(this.url,"*").concat(this.type,"*").concat(this.layerName,"*").concat(this.attributionParam_,"*").concat(this.urlParam,"*").concat(this.minWidth_,"*").concat(this.maxWidth_,"*").concat(this.urlAttribute)}},{key:"getAPIRestBase64",value:function(){return"".concat(this.name,"=base64=").concat(M.utils.encodeBase64(this.options))}}],s=[{key:"getJSONTranslations",value:function(t){return"en"===t||"es"===t?"en"===t?I:x:M.language.getTranslation(t).attributions}}],i&&ai(n.prototype,i),s&&ai(n,s),Object.defineProperty(n,"prototype",{writable:!1}),n;var n,i,s}();window.M.plugin||(window.M.plugin={}),window.M.control||(window.M.control={}),window.M.impl||(window.M.impl={}),window.M.impl.control||(window.M.impl.control={}),window.M.plugin.Attributions=pi,window.M.control.AttributionsControl=S,window.M.impl.control.AttributionsControl=y})()})();
//# sourceMappingURL=attributions.ol.min.js.map